var documenterSearchIndex = {"docs":
[{"location":"itensors/#ITensor-extension","page":"ITensor extension","title":"ITensor extension","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"FuzzifiED also supports an ITensor extension, including convertion with the Site and OpSum objects from ITensor library and management of DMRG sweeping process. To use the extension, make sure the packages ITensors, ITensorMPS are properly installed, and include","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"using ITensors, ITensorMPS","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"at the heading of the Julia script.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"During intialisation, the optimal configuration for parallelisation is already automatically set.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"BLAS.set_num_threads(1);\nNDTensors.Strided.disable_threads();\nITensors.enable_threaded_blocksparse();","category":"page"},{"location":"itensors/#Format-conversion","page":"ITensor extension","title":"Format conversion","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"FuzzyfiED defines a new SityType \"FuzzyFermion\" that can be initialised from QNDiags to avoid overwriting the original \"Fermion\" type.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"ITensors.space( :: SiteType\"FuzzyFermion\"; o :: Int, qnd :: Vector{QNDiag})","category":"page"},{"location":"itensors/#ITensors.space-Tuple{SiteType{FuzzyFermion}}","page":"ITensor extension","title":"ITensors.space","text":"ITensors.space( :: SiteType\"FuzzyFermion\" ; o :: Int, qnd :: Vector{QNDiag})\n\nDefine a new site type \"FuzzyFermion\" which inherits all the features of ITensor type \"Fermion\". It can be initialised by a set of QNDiag's and the site index o.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"The Sites objects in ITensor can be converted to a QNDiags and Confs with the QNs extracted. ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"GetQNDiags(sites :: Vector{Index{Vector{Pair{QN, Int64}}}})\nConfs(sites :: Vector{Index{Vector{Pair{QN, Int64}}}}, sec_qn :: QN)","category":"page"},{"location":"itensors/#FuzzifiED.GetQNDiags-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}}","page":"ITensor extension","title":"FuzzifiED.GetQNDiags","text":"GetQNDiags(sites :: Vector{<:Index})\n\nConverts a Sites object in the ITensors package to a set of QNDiags. \n\nArguments\n\nsites :: Vector{<:Index} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.Confs-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}","page":"ITensor extension","title":"FuzzifiED.Confs","text":"Confs(sites :: Vector{<:Index}, sec_qn :: QN)\nConfs(sites :: Vector{<:Index}, cf_ref :: Vector{Int64})\n\nConverts a Sites object in the ITensors package to the Confs object\n\nArguments\n\nsites :: Vector{<:Index} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \nsec_qn :: QN is a QN object that specifies the the quantum number of the selected configuration. Alternatively, cf_ref :: Vector{Int64}) is a reference configuration composed of 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Conversely, the  Sites objects in ITensors can also be generated from a set of diagonal quantum numbers ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"GetSites(qnd :: Vector{QNDiag})","category":"page"},{"location":"itensors/#FuzzifiED.GetSites-Tuple{Vector{QNDiag}}","page":"ITensor extension","title":"FuzzifiED.GetSites","text":"GetSites(qnd :: Vector{QNDiag}) :: Vector{<:Index}\n\nreturns the ITensors Sites of type \"FuzzyFermion\" from a set of QNDiags.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"If the number of quantum numbers are too many, it can be truncated by ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64 = 3, trunc_wt :: Vector{Int64} = [ 10 ^ (i - trunc_lth) for i = trunc_lth : length(qnd)]) ","category":"page"},{"location":"itensors/#FuzzifiED.TruncateQNDiag-Tuple{Vector{QNDiag}}","page":"ITensor extension","title":"FuzzifiED.TruncateQNDiag","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64, trunc_wt :: Vector{Int64}) :: Vector{QNDiag}\n\ntruncates the list of N_U QNDiags from to a number N_U acceptable by ITensors. The new quantum numbers are \n\nbeginaligned\n    Q_1=Q_1 Q_2=Q_2  Q_N_U-1=Q_N_U-1\n    Q_N_U=λ_N_UQ_N_U+λ_N_U+1Q_N_U+1++λ_N_UQ_N_U\nendaligned\n\nArguments\n\nqnd :: Vector{QNDiag} stores the set of QNDiags. \ntrunc_lth :: Int64 stores the truncated numbers of QNDiags. Facultative, 3 by default. \ntrunc_wt :: Vecotr{Int64} stores the N_U-N_U+1 coefficients λ. Facultative, 1101001000 by default. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"The OpSum objects in ITensor can be converted with the collection of Term's","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Terms(opsum :: Sum{Scaled{ComplexF64, Prod{Op}}})\nOpSum(tms :: Terms)","category":"page"},{"location":"itensors/#FuzzifiED.Terms-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}","page":"ITensor extension","title":"FuzzifiED.Terms","text":"Terms(opsum :: OpSum)\n\nConverts a OpSum object in ITensors to a series of terms. Note that the only operators supported are \"C\", \"Cdag\" \"N\" and \"I\".\n\n\n\n\n\n","category":"method"},{"location":"itensors/#ITensors.Ops.OpSum-Tuple{Vector{Term}}","page":"ITensor extension","title":"ITensors.Ops.OpSum","text":"OpSum(tms :: Terms)\n\nConverts a series of terms to OpSum object in ITensors.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Easy-sweep","page":"ITensor extension","title":"Easy sweep","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. This extension required the packages HDF5. We also recommand using the package ITensorMPOConstruction for the generation of Hamiltonian MPO, which can be installed by ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"using Pkg ; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String = \"./\", dim_list :: Vector{Int64} = [1000,2000,3000,4000,5000,6000], proj :: Vector{String} = String[], e_tol1 :: Float64 = 1E-6, e_tol :: Float64 = 1E-7, cutoff :: Vector{Float64} = [1E-9], maxdim0 :: Vector{Int64} = [10,20,50,100,200,500], noise0 :: Vector{Float64} = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], noise :: Vector{Float64} = [1E-6,2E-7,5E-8,1E-8,0], nsweeps :: Int64 = 10, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol1))\nSweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String = \"./\", cutoff :: Vector{Float64} = [1E-9], maxdim :: Vector{Int64} = [dim1], nsweeps :: Int64 = 10, noise :: Vector{Float64} = [1E-6,1E-7,0], proj :: Vector{String} = String[], e_tol :: Float64 = 1E-6, weight :: Float64 = 100.0, observer :: AbstractObserver = EasySweepObserver(e_tol))\nGetMPOSites(id :: String, tms :: Union{Terms, Sum{Scaled{ComplexF64, Prod{Op}}}}, qnd :: Vector{QNDiag} ; path :: String = \"./\", mpo_method :: Function = MPO)\nGetMPO(id :: String, tms :: Union{Terms, Sum{Scaled{ComplexF64, Prod{Op}}}}, sites :: Vector{<:Index} ; path :: String = \"./\", mpo_method :: Function = MPO)","category":"page"},{"location":"itensors/#FuzzifiED.EasySweep-Tuple{String, MPO, MPS}","page":"ITensor extension","title":"FuzzifiED.EasySweep","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String, dim_list :: Vector{Int64}, proj :: Vector{String}, e_tol1 :: Float64, e_tol :: Float64, cutoff :: Vector{Float64}, maxdim0 :: Vector{Float64}, noise0 :: Vector{Float64}, noise :: Vector{Int64}, nsweeps :: Int64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function automatically performs several rounds of DMRG sweeps with increasing bond dimensions. It first checks the file st_$(id).h5 in a specified repository. If the key st_fin exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process. For each round, it will try to access the results from the key st_d$(dim_i) in st_$(id).h5, where dim_i is either 0 representing the initial round, or an element of array dim_list. If the key exist, it will read the result ; otherwise it will perform the sweeps using SweepOne. For the initial round, it will take the initial state from st00, the maximal bond dimensions from maxdim0, noise from noise0 and record the results in the key E_d0 and st_d0 in st_$(id).h5. For each of the following round, it will take the result from the previous round as the initial state and perform nsweeps sweeps with the bond dimension dim_list[i]. Each round will be stopped if the energy difference is less than e_tol1. The entire process will be stopped if the energy difference between two rounds is less than e_tol or the bond dimension of the result is less than 0.9 times the maximal bond dimension. The projected states will be accessed from the files specified by proj. It will try to access first the states with the same bond dimension as the projected states. If such states do not exist, it will then access the final state. The resulting energy will be written into the key E_fin in the file st_$(id).h5, and the MPS written into st_fin. The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst00 :: MPS is an MPS specifying the initial state. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ndim_list :: Vector{Int64} :: Int64 is a list that specifies the maximal bond dimensions of each round of sweeps starting from the second round. Facultative, [1000,2000,3000,4000,5000,6000] by default\nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol1 :: Float64 specifies the energy tolerence as a criteria to end the round of sweeps for each round of sweeps. Facultative, 1E-6 by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the entire process. Facultative, 1E-7 by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim0 :: Vector{Int64} specifies the maximal bond dimensions of the first round of sweeps. Facultative, [10,20,50,100,200,500] by default. \nnoise0 :: Vector{Float64} specifies the noise of each sweep in the initial round and will be sent into DMRG. Facultative, [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7] by default. \nnoise :: Vector{Float64} specifies the noise of each sweep from the second round and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nnsweeps :: Int64 specifies the number of sweeps in each round from the second rounds. Facultative, 10 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep starting from the second round. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \ndmrg_options :: Dict specifies other options to be sent into DMRG. E.g., to specify write_when_maxdim_exceeds = 1000 and write_path = \"./tmp/\", one can put dmrg_options = Dict(:write_when_maxdim_exceeds => 1000, :write_path => \"./tmp/\").\nclear_previous :: Bool. If set true, the file st_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}","page":"ITensor extension","title":"FuzzifiED.SweepOne","text":"SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String, cutoff :: Vector{Float64}, maxdim :: Vector{Int64}, nsweeps :: Int64, noise :: Vector{Float64}, proj :: Vector{String}, e_tol :: Float64, weight :: Float64, observer :: AbstractObserver, dmrg_options :: Dict, dmrg_options :: Dict) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function performs one round of nsweeps sweeps. It first checks the file st_$(id).h5 in a specified repository. If the key st_d$(dim1) exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process with the maximal bond dimension specified by maxdim if it exists, or dim1. The projected states will be read from the key st_d$(dim1) if it exists or st_fin in the file st_$(fi).h5 in the same repository for each string fi in the array proj. The sweeps will be ended if the energy difference is less than etol or whatever criteria is given in observer. The resulting energy will be written into the key E_d$(dim1) in the file st_$(id).h5, and the MPS written into st_d$(dim1). The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst0 :: MPS is an MPS specifying the initial state. \ndim1 :: Int64 is a bond dimension that will be used to identify the result. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim :: Vector{Int64} specifies the maximal bond dimension of each sweep. Facultative, [dim1] by default. \nnsweeps :: Int64 specifies the number of sweeps in the round. Facultative, 10 by default. \nnoise :: Vector{Float64} specifies the noise of each sweep and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the sweeps. Facultative, 1E-6 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \ndmrg_options :: Dict specifies other options to be sent into DMRG. E.g., to specify write_when_maxdim_exceeds = 1000 and write_path = \"./tmp/\", one can put dmrg_options = Dict(:write_when_maxdim_exceeds => 1000, :write_path => \"./tmp/\").\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{QNDiag}}","page":"ITensor extension","title":"FuzzifiED.GetMPOSites","text":"GetMPOSites(id :: String, tms, qnd :: Vector{QNDiag} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nFunction\n\nThis function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and sites and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in qnd. Then it will generate the MPO with the terms of the operator given in tms. The MPO and sites will be written into the file op_$(id).h5 in the fields mpo and sites. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Terms or tms :: OpSum is either an array of terms or a OpSum objects that specifies the expression of the operator. \nqnd :: Vector{QNDiag} is a list of diagonal quantum numbers. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. N.b., MPO_new only applies to the cases that the operator do not carry charge under any of the quantum numbers.\nclear_previous :: Bool. If set true, the file op_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.GetMPO-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{<:Index}}","page":"ITensor extension","title":"FuzzifiED.GetMPO","text":"GetMPO(id :: String, tms :: Union{Terms, OpSum}, sites :: Vector{<:Index} ; path :: String, mpo_method :: Function) :: MPO\n\nFunction\n\nThis function returns the MPO for a given operator and a given set of sites. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and return the MPO it has read. Otherwise it will generate the MPO with the terms of the operator given in tms. The MPO and Sites will be written into the file op_$(id).h5 in the fields mpo. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Terms or tms :: OpSum is either an array of terms or a OpSum objects that specifies the expression of the operator. \nsites :: Vector{<:Index} specifies the sites that the operator is acting on. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. N.b., MPO_new only applies to the cases that the operator do not carry charge under any of the quantum numbers.\nclear_previous :: Bool. If set true, the file op_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Modified-version-of-ITensor","page":"ITensor extension","title":"Modified version of ITensor","text":"","category":"section"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"We have forked ITensors and made some modifications to better suit our need. To install the modified packages, please use ","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"using Pkg \nPkg.add(url=\"https://github.com/FuzzifiED/ITensors.jl.git\")\nPkg.add(url=\"https://github.com/FuzzifiED/ITensorMPS.jl.git\")\nPkg.add(url=\"https://github.com/FuzzifiED/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"The modifications made include","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Modify ITensors to allow up to 10 quantum numbers ; \nModify ITensorMPS to allow write_when_maxdim_exceeds in DMRG in the presence of projection matrices ;\nModify ITensorMPOConstruction to allow building MPOs that has symmetry flux ;\nModify ITensorMPOConstruction to allow compatibility with the newest version of ITensors.","category":"page"},{"location":"itensors/","page":"ITensor extension","title":"ITensor extension","text":"Please be warned that the robustness and the backward compatibility of these modifications are not warranted. ","category":"page"},{"location":"core/#Core-functions","page":"Core functions","title":"Core functions","text":"","category":"section"},{"location":"core/#Environment-parameters","page":"Core functions","title":"Environment parameters","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The following environment parameters defines how FuzzifiED works, viz. whether it outputs logs, how many threads it uses and where it reads its libraries. In general, you can keep it at default. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"FuzzifiED.SilentStd\nFuzzifiED.NumThreads\nFuzzifiED.Libpath\nFuzzifiED.ElementType\nFuzzifiED.OpenHelp!()","category":"page"},{"location":"core/#FuzzifiED.SilentStd","page":"Core functions","title":"FuzzifiED.SilentStd","text":"FuzzifiED.SilentStd :: Bool = false\n\na flag to determine whether logs of the FuzzifiED functions should be turned off. False by default. If you want to evaluate without log, put FuzzifiED.SilentStd = true. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.NumThreads","page":"Core functions","title":"FuzzifiED.NumThreads","text":"FuzzifiED.NumThreads :: Int = Threads.nthreads()\n\nan integer to define how many threads OpenMP uses. By default, it is the same as the number of threads in Julia. If you use Jupyter notebooks, which by default uses one core only, you may need to define this by hand, e.g., FuzzifiED.NumThreads = 8. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.Libpath","page":"Core functions","title":"FuzzifiED.Libpath","text":"FuzzifiED.Libpath :: String = FuzzifiED_jll.LibpathFuzzifiED\n\ndefine path of the Fortran library libfuzzified.so. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.ElementType","page":"Core functions","title":"FuzzifiED.ElementType","text":"FuzzifiED.ElementType :: DataType = ComplexF64\n\nset the default type of the operator elements, either ComplexF64 or Float64. ComplexF64 by default. \n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.OpenHelp!-Tuple{}","page":"Core functions","title":"FuzzifiED.OpenHelp!","text":"FuzzifiED.OpenHelp!()\n\nA shortcut to open the link for documentation docs.fuzzified.world in the system browser. \n\n\n\n\n\n","category":"method"},{"location":"core/#Quantum-numbers","page":"Core functions","title":"Quantum numbers","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"FuzzifiED implements diagonal and off-diagonal quantum numbers. They are defined as","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"QNDiag\nQNOffd","category":"page"},{"location":"core/#FuzzifiED.QNDiag","page":"Core functions","title":"FuzzifiED.QNDiag","text":"QNDiag\n\nThe mutable type QNDiag records the information of a diagonal mathrmU(1) or ℤ_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_oq_on_o\n\nor\n\nQ=_o=1^N_oq_on_o mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of site, n_o=c^_oc_o, and q_o is a set of coefficients that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number.\ncharge :: Vector{Int64} is the symmetry charge q_o of each site.\nmodul :: Vector{Int64} is the modulus p, set to 1 for mathrmU(1) QNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNDiag([name :: String, ]charge :: Vector{Int64}[, modul :: Int64])\n\nThe arguments name and modul are facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.QNOffd","page":"Core functions","title":"FuzzifiED.QNOffd","text":"QNOffd\n\nThe mutable type QNOffd records the information of an off-diagonal ℤ_p quantum number in the form of a discrete transformation\n\n𝒵 c_o α_o^* c^(p_o)_π_o  c_o^ α_o c^(1-p_o)_π_o\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, π_o is a permutation of 1N_o, α_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\nperm :: Vector{Int64} is a length-N_o vector that records the permutation π_o.\nph :: Vector{Int64} is a length-N_o vector that records p_o to determine whether or not to perform a particle-hole transformation.\nfac :: Vector{ComplexF64} is a length-N_o vector that records the factor α_o in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNOffd(perm :: Vector{Int64}[, ph :: Vector{Int64}][, fac :: Vector{ComplexF64}][, cyc :: Int64])\nQNOffd(perm :: Vector{Int64}, ph_q :: Bool[, fac :: Vector{ComplexF64}])\n\nThe arguments ph, fac and cyc are facultative. By default ph is set all 0, fac is set to all 1 and cyc is set to 2. If ph_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The QNDiag can be added or multiplied by a number ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"+(qnd1 :: QNDiag, qnd2 :: QNDiag)\n*(fac :: Int64, qnd :: QNDiag)","category":"page"},{"location":"core/#Base.:+-Tuple{QNDiag, QNDiag}","page":"Core functions","title":"Base.:+","text":"+(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag \n-(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag\n\nreturns the sum or substraction of two QNDiags, whose name is the samea as qnd1, charge is the same as qnd1 ± qnd2, and modulus is the GCD of qnd1 and qnd2. If qnd1 and qnd2 are both ℤ_p quantum numbers and their modulus are coprime, a trivial QNDiag will be returned. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Int64, QNDiag}","page":"Core functions","title":"Base.:*","text":"*(fac :: Int64, qnd :: QNDiag) :: QNDiag \n*(qnd :: QNDiag, fac :: Int64) :: QNDiag \n÷(qnd :: QNDiag, fac :: Int64) :: QNDiag \n-(qnd :: QNDiag) :: QNDiag\n\nreturns the QNDiag multiplied or divided by an integer factor, where the charge is multiplied or integer-divided by the factor. For ℤ_p quantum numbers, their modulus will be multiplied or integer-divided by the absolute value. If qnd.modul ÷ abs(fac) ≤ 1, a trivial QNDiag will be returned.  \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The QNOffd can be composed","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(qnf1 :: QNOffd, qnf2 :: QNOffd)","category":"page"},{"location":"core/#Base.:*-Tuple{QNOffd, QNOffd}","page":"Core functions","title":"Base.:*","text":"*(qnf1 :: QNOffd, qnf2 :: QNOffd) :: QNOffd\n\nreturns the composition of two QNOffd transformations. The cycle is set to be the LCM of two QNOffds.\n\n\n\n\n\n","category":"method"},{"location":"core/#Configurations","page":"Core functions","title":"Configurations","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs","category":"page"},{"location":"core/#FuzzifiED.Confs","page":"Core functions","title":"FuzzifiED.Confs","text":"Confs\n\nThe mutable type Confs stores all the configurations that respects the diagonal quantum numbers (QNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nno :: Int64 is the number of sites.\nncf :: Int64 is the number of configurations.\nconf :: Vector{Int64} is an array of length ncf containing all the configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \nnor :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated from the QNDiags.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)","category":"page"},{"location":"core/#FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{QNDiag}}","page":"Core functions","title":"FuzzifiED.Confs","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64, disp_std :: Bool)\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nno :: Int64 is the number of sites N_o.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{QNDiag} is the set of QNDiags.\nnor :: Int64 is the number of less significant bits used to generate the Lin table. Facultative, N_o2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: Confs is a Confs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the number of electrons.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The inverse look-back for a configuration can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfId(cfs :: Confs, cf :: Int64)","category":"page"},{"location":"core/#FuzzifiED.GetConfId-Tuple{Confs, Int64}","page":"Core functions","title":"FuzzifiED.GetConfId","text":"GetConfId(cfs :: Confs, cf :: Int64) :: Int64\n\ninversely look up the index from the configuration\n\nArguments\n\ncfs :: Confs stores the configurations.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \n\nOutput\n\nid :: Int64 is the id of the configuration such that cfs.conf[id] == cf.\n\n\n\n\n\n","category":"method"},{"location":"core/#Basis","page":"Core functions","title":"Basis","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis","category":"page"},{"location":"core/#FuzzifiED.Basis","page":"Core functions","title":"FuzzifiED.Basis","text":"Basis\n\nThe mutable type Basis stores the information of the basis that respects both diagonal and off-diagonal quantum numbers. The states in the basis is in the form \n\nI=λ_i_I1i_I1+λ_i_I2i_I2++λ_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i.e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: Confs stores the configurations that respect the QNDiags.\ndim :: Int64 is the dimension of the basis.\nszz :: Int64 records the maximum size max m_I of groups.\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to.\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients λ_i of each configuration.\ngrel :: Matrix{Int64} is a szz*dim matrix that records the configurations in each group i_Ik (k = 1m_I).\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th = NumThreads, disp_std = !SilentStd)\nBasis(cfs :: Confs)","category":"page"},{"location":"core/#FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{QNOffd}}","page":"Core functions","title":"FuzzifiED.Basis","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th :: Int64, disp_std :: Bool)\n\ngenerates the basis that respects the off-diagonal ℤ_p quantum numbers (QNOffd)\n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations.\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector.\nqnf :: Vector{QNOffd} is a vector of off-diagonal quantum numbers.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: Basis is the resulting Basis object.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.Basis-Tuple{Confs}","page":"Core functions","title":"FuzzifiED.Basis","text":"Basis(cfs :: Confs)\n\nGenerate a basis from the configurations without off-diagonal ℤ_n symmetries.\n\nArguments\n\ncfs :: Confs is the diagonal QN–preserving configurations.\n\nOutput\n\nbs :: Basis is the resulting Basis object.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The look-back of the weight of a configuration in a state can be done by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetConfWeight(bs :: Basis, st :: Union{Vector{ComplexF64}, Vector{Float64}}, cf :: Int64)","category":"page"},{"location":"core/#FuzzifiED.GetConfWeight-Tuple{Basis, Union{Vector{ComplexF64}, Vector{Float64}}, Int64}","page":"Core functions","title":"FuzzifiED.GetConfWeight","text":"GetConfWeight(bs :: Basis, st :: Vector{<:Number}, cf :: Int64) :: ComplexF64\n\nlooks up a the weight of a configuration in a state. \n\nArguments\n\nbs :: Basis is the basis of the state.\nst :: Vector{ComplexF64} or st :: Vector{Float64} is a vector of length bs.dim that stores the state.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \n\nOutput\n\nThe weight of the configuration in the state.\n\n\n\n\n\n","category":"method"},{"location":"core/#Term","page":"Core functions","title":"Term","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Term\nTerms","category":"page"},{"location":"core/#FuzzifiED.Term","page":"Core functions","title":"FuzzifiED.Term","text":"Term\n\nThe mutable type Term records a term that looks like Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l in an operator\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U.\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string.\n\nInitialisation\n\nIt can be generated by the function\n\nTerm(coeff :: Number, cstr :: Vector{Int64})\n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.Terms","page":"Core functions","title":"FuzzifiED.Terms","text":"Terms\n\nTerms is an alias for Vector{Term} for convenience\n\nInitialisation\n\nTerms(coeff :: Number, cstr :: Vector{Int64})\n\nGives a Terms with a single Term.\n\nSpecial elements\n\nThe zero and identity terms are defined.\n\nzero(Terms) = Term[]\none(Terms) = Terms(1, [-1, -1])\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(fac :: Number, tms :: Terms)\n+(tms1 :: Terms, tms2 :: Terms)\n*(tms1 :: Terms, tms2 :: Terms)\nadjoint(tms :: Terms)\nParticleHole(tms :: Terms)","category":"page"},{"location":"core/#Base.:*-Tuple{Number, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"*(fac :: Number, tms :: Terms) :: Terms\n-(tms :: Terms) :: Terms\n*(tms :: Terms, fac :: Number) :: Terms\n/(tms :: Terms, fac :: Number) :: Terms\n\nReturn the product of a collection of terms with a number. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:+","text":"+(tms1 :: Terms, tms2 :: Terms) :: Terms\n-(tms1 :: Terms, tms2 :: Terms) :: Terms\n\nReturn the naive sum of two series of terms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}","page":"Core functions","title":"Base.:*","text":"*(tms1 :: Terms, tms2 :: Terms) :: Terms\n^(tms :: Terms, pow :: Int64) :: Terms\n\nReturn the naive product of two series of terms or the power of one terms. The number of terms equals the product of the number of terms in tms1 and tms2. For each term in tms1 Uc^(p_1)_o_1 and tms2 Uc^(p_1)_o_1, a new term is formed by taking UUc^(p_1)_o_1 c^(p_1)_o_1.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.adjoint-Tuple{Vector{Term}}","page":"Core functions","title":"Base.adjoint","text":"adjoint(tm :: Term) :: Term\nadjoint(tms :: Terms) :: Terms\n\nReturn the Hermitian conjugate of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the adjoint is barUc^(1-p_l)_o_l c^(1-p_2)_o_2c^(1-p_1)_o_1.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.ParticleHole-Tuple{Vector{Term}}","page":"Core functions","title":"FuzzifiED.ParticleHole","text":"ParticleHole(tm :: Term) :: Term\nParticleHole(tms :: Terms) :: Terms\n\nReturn the particle-hole transformation of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the transformation results in Uc^(1-p_1)_o_1c^(1-p_2)_o_2c^(1-p_l)_o_l.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The terms can be simplified by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"NormalOrder(tm :: Term)\nSimplifyTerms(tms :: Terms)","category":"page"},{"location":"core/#FuzzifiED.NormalOrder-Tuple{Term}","page":"Core functions","title":"FuzzifiED.NormalOrder","text":"NormalOrder(tm :: Term) :: Terms\n\nrearrange a term such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe site index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of terms whose result is equal to the original term. \n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}","page":"Core functions","title":"FuzzifiED.SimplifyTerms","text":"SimplifyTerms(tms :: Terms ; cutoff :: Float64 = eps(Float64)) :: Terms\n\nsimplifies the sum of terms such that \n\neach term is normal ordered,\nlike terms are combined, and terms with zero coefficients are removed.\n\nArgument\n\ncutoff :: Float64 is the cutoff such that terms with smaller absolute value of coefficients will be neglected. Facultative, eps(Float64) by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Operator","page":"Core functions","title":"Operator","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator","category":"page"},{"location":"core/#FuzzifiED.Operator","page":"Core functions","title":"FuzzifiED.Operator","text":"Operator\n\nThe mutable type Operator records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0.\nntm :: Int64 is the number of terms.\nnc :: Int64 is the maximum number of operators in an operator string.\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Operator(bsd :: Basis, bsf :: Basis, terms :: Terms ; red_q :: Int64 = 0, sym_q :: Int64 = 0)","category":"page"},{"location":"core/#FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}","page":"Core functions","title":"FuzzifiED.Operator","text":"Operator(bsd :: Basis[, bsf :: Basis], terms :: Terms ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool)\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: Terms records the terms.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(op :: Operator, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\n*(op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Sparse-matrix","page":"Core functions","title":"Sparse matrix","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat{T}","category":"page"},{"location":"core/#FuzzifiED.OpMat","page":"Core functions","title":"FuzzifiED.OpMat","text":"OpMat{ComplexF64}\nOpMat{Float64}\n\nThe mutable type OpMat{T} where the element type T can be Float64 and ComplexF64 stores a sparse matrix in the same form as SparseMatrixCSC in SparseArrays. If the matrix is Hermitian or symmetric, only the lower triangle is stored. \n\nFields\n\ndimd :: Int64 and dimf :: Int64 are the number of columns and rows of the matrix.\nsymq :: Int64 records whether or not the matrix is Hermitian or symmetric.\nnel :: Int64 records the number of elements.\ncolptr :: Vector{Int64}, rowid :: Vector{Int64} and elval :: Vector{ComplexF64} records the elements of the sparse matrix as in the SparseMatrixCSC elements of Julia. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core functions","title":"Core functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"OpMat(op :: Operator ; type :: DataType = ElementType)","category":"page"},{"location":"core/#FuzzifiED.OpMat-Tuple{Operator}","page":"Core functions","title":"FuzzifiED.OpMat","text":"OpMat[{T}](op :: Operator ; num_th :: Int64, disp_std :: Bool)\n\nGenerates the sparse matrix from the operator. The parametric type T is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: Operator is the operator.\nT :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The lowest eigenstates of the sparse matrix can be calculated by ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64 = 1E-8, ncv :: Int64 = max(2 * nst, nst + 10))","category":"page"},{"location":"core/#FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}","page":"Core functions","title":"FuzzifiED.GetEigensystem","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64, ncv :: Int64, initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nGetEigensystem(mat :: OpMat{Float64}, nst :: Int64 ; tol :: Float64, ncv :: Int64, initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\ncalls the Arpack package to calculate the lowest eigenstates of sparse matrix. \n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix.\nnst :: Int64 is the number of eigenstates to be calculated.\ntol :: Float64 is the tolerence for the Arpack process. The default value is 1E-8.\nncv :: Int64 is an auxiliary parameter needed in the Arpack process. The default value is max(2 * nst, nst + 10).\ninitvec :: Vector{ComplexF64} or initvec :: Vector{Float64} is the initial vector. If empty, a random initialisation shall be used. Facultative, empty by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64})","category":"page"},{"location":"core/#Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: Vector{ComplexF64}\n*(mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Vector{Float64}\n\nMeasure the action of a sparse matrix on a state. st_d must be of length mat.dimd. Returns a vector of length mat.dimf that represents the final state. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Float64\n\nMeasuring the inner product between two states and a sparse matrix. st_d must be of length mat.dimd and st_fp must be of length mat.dimf, and st_fp must be an adjoint. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. ","category":"page"},{"location":"core/","page":"Core functions","title":"Core functions","text":"stf = Operator(bsd, bsf, one(Terms)) * std","category":"page"},{"location":"core/#Transformation","page":"Core functions","title":"Transformation","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"Transf\nTransf(bsd :: Basis, bsf :: Basis, qnf :: QNOffd)\n*(trs :: Transf, st_d :: Vector{ComplexF64} ; num_th = NumThreads)","category":"page"},{"location":"core/#FuzzifiED.Transf","page":"Core functions","title":"FuzzifiED.Transf","text":"Transf\n\nThe mutable type Transf records a transformation in the same form as a QNOffd\n\n𝒵 c_o α_o^* c^(p_o)_π_o  c_o^ α_o c^(1-p_o)_π_o\n\ntogether with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state.\nperm :: Vector{Int64}, ph :: Vector{Int64} and fac :: Vector{ComplexF64} records the transformation in the same form as a QNOffd.\n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.Transf-Tuple{Basis, Basis, QNOffd}","page":"Core functions","title":"FuzzifiED.Transf","text":"Transf(bsd :: Basis[, bsf :: Basis], qnf :: QNOffd)\n\ngenerates a transformation object from a QNOffd. \n\nArguments\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state. Facultative, the same as bsd by default.\nqnf :: QNOffd records the transformation.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Transf, Vector{ComplexF64}}","page":"Core functions","title":"Base.:*","text":"*(trs :: Transf, st_d :: Vector{ComplexF64} ; num_th = NumThreads) :: Vector{ComplexF64}\n*(trs :: Transf, st_d :: Vector{Float64} ; num_th = NumThreads) :: Vector{Float64}\n\nAct a transformation on a state. st_d must be of length trs.bsd.dim. Returns a vector of length trs.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Entanglement","page":"Core functions","title":"Entanglement","text":"","category":"section"},{"location":"core/","page":"Core functions","title":"Core functions","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number})\nGetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{Int64}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2)))","category":"page"},{"location":"core/#FuzzifiED.StateDecompMat-Tuple{Vector{<:Number}, Basis, Basis, Basis, Vector{<:Number}, Vector{<:Number}}","page":"Core functions","title":"FuzzifiED.StateDecompMat","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{ComplexF64}, amp_ob :: Vector{ComplexF64}) :: Matrix{ComplexF64}\n\nDecompose a state ψ=v_II into a direct-product basis of two subsystems ψ=M_JII_AJ_B\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nbsa :: Basis is the basis for the subsystem A.\nbsb :: Basis is the basis for the subsystem B. \namp_oa :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem A. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \namp_ob :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem B. \n\nOutput\n\nA complex matrix of dimension bsb.dim * bsa.dim that corresponds to the state in the decomposed basis ψ=M_JII_AJ_B. This is equivalent to R_μν^Ap in PRB 85, 125308 (2012). After calculating all the sectors, the reduced density matrix will be ρ_B=mathbfMmathbfM^.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, Basis, Vector{Vector{Vector{Int64}}}, Vector{Vector{Vector{Int64}}}}","page":"Core functions","title":"FuzzifiED.GetEntSpec","text":"GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{secd_a, secf_a, secd_b, secf_b}, Vector{Float64}}\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nsecd_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNDiag sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nsecf_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNOffd sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nqnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} specifies the diagonal and off-diagonal quantum numbers of the subsystems A and B. qnd_b and qnf_b are facultative and the same as qnd_a and qnf_a by default. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries secd_a, secf_a, secd_b, secf_b and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"intro/#An-introduction-to-the-fuzzy-sphere","page":"Introduction","title":"An introduction to the fuzzy sphere","text":"","category":"section"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#Conformal-field-theory","page":"Introduction","title":"Conformal field theory","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conformal field theory (CFT) is one of the central topics of modern physics. It refers to a field theory that is invariant under conformal transformations that preserve the angles between vectors. In spacetime dimension d2, the global conformal symmetry is generated by translation, mathrmSO(d) rotation (In this note we work in Euclidean signature. In Lorentzian signature it is the Lorentz transformation mathrmSO(1d-1)), dilatation (scale transformation), and special conformal transformation (SCT). These transformations altogether generate the conformal group mathrmSO(d+11). Each CFT operator must transform under irreducible representations of rotation and dilatation. The representations are labelled by mathrmSO(d) spin l and scaling dimension Delta, respectively. A special kind of operators that are invariant under SCT called « primaries » deserve particular attension. By acting the space derivatives on the primaries, their « descendants » are obtained. The conformal symmetry is the maximal spacetime symmetry that a field theory can have. It gives powerful constraint on the property of the field theory. In particular, conformal symmetry uniquely determines the form of two-point and three-point correlation functions. The three-point correlator of three primary operators Phi_iPhi_jPhi_k contains a universal coefficient called the OPE coefficient f_Phi_iPhi_jPhi_k. The collection of scaling dimensions and the OPE coefficients Delta_Phi_if_Phi_iPhi_jPhi_k is called the conformal data. Theoretically, with full knowledge of the CFT data, an arbitrary correlation function of a CFT can be obtained. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CFT has provided important insights into various fields of theoretical physics. In condensed matter physics, it has produced useful prediction about the critical phenomena. Many classical and quantum phase transitions are conjectured to have emergent conformal symmetry in the IR. The universal critical exponents are directly determined by the scaling dimensions of the primary operators. E.g., in Ising transitions that spontaneously break mathbbZ_2 symmetry, most critical exponents are given by the scaling dimensions of the lowest mathbbZ_2-odd operator sigma and mathbbZ_2-even operator epsilon, such as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"eta=2Delta_sigma-1qquadnu=frac13-Delta_epsilon","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CFT is also closely related to string theory and quantum gravity in high energy physics. In the string theory, CFT  describes the 2d worldsheet ; in quantum gravity, there is a conjectured duality between the gravity theory in (d+1)-dimensional anti-de Sitter (AdS) space in the bulk and a d-dimensional CFT on the boundary. Moreover, CFT plays an important role in our understanding of quantum field theories. It describes many fixed points in the RG flow and many QFTs can be seen as a CFT with perturbations. It also helps us understand how physics change under a change of scale and reveals some fundamental structure of the RG flow. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In 2d CFTs, besides the global conformal symmetry mathrmSO(31), there also exists an infinite dimensional local conformal symmetry. Altogether, they form the Virasoro algebra. The infinite dimensional conformal algebra has made many theories exactly solvable, especially the rational theories such as the minimal models and more generally the Wess-Zumino-Witten (WZW) theories. On the other hand, going to the higher dimensions, the CFTs are much less well-studied due to a much smaller conformal group. The existing methods include numerical conformal bootstrap and Monte Carlo lattice simulations. Numerical boostrap bounds the conformal data by making use of consistency conditions such as reflection positivity together with some information of the CFT such as the global symmetry and a certain amount of assumptions. It has achieved great success in 3d Ising, mathrmO(N) Wilson-Fisher, Gross-Neveu-Yukawa CFTs, etc. On the other hand, one can study a CFT by constructing a lattice model that goes through a phase transition in the corresponding universality class, and study the phase transition by Monte Carlo simulation. The extraction of universal data usually involves complicated and expensive finite-size scaling, and only the lowest few CFT operators can be accessed in this way. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Among these higher dimensional CFTs, we especially focus on d=3, as many Lagrangians in dge 4 flow to free theories. ","category":"page"},{"location":"intro/#Fuzzy-sphere","page":"Introduction","title":"Fuzzy sphere","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In addition to these existing approaches, the « fuzzy sphere regularisation » has recently emerged as a new powerful method to study 3d CFTs. The idea is to put an interacting quantum Hamiltonian on a 2-sphere S^2. This geometry preserves the full rotation symmetry (on the contrary, lattice models often only preserve a discrete subgroup). Moreover, when the system is tuned to a critical point or critical phase, combined with the time evolution direction, the system is described by a quantum field theory living on a generalised cylinder S^2timesmathbbR, a manifold that is conformally equivalent to flat spacetime through the Weyl transformation","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    (hatmathbfntau)in S^2timesmathbbR longmapsto rhatmathbfninmathbbR^3qquad r=e^tauR","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where R is the radius of the sphere. This conformal transformation maps each time slice of the cylinder to a cocentric sphere in the the flat spacetime. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Thanks to the conformal flatness that is not owned by other manifolds (e.g., a lattice model with periodic boundary condition lives on the torus T^2 which is not conformally flat), we can make use of some nice properties of conformal field theories, the most important one of which is the state-operator correspondance. Specifically, there is a one-to-one correspondence between the eigenstates of the critical Hamiltonian on the sphere and the CFT operators.  One can colloquially understand the state Phirangle as the insertion of the corresponding operator Phi(0) at the origin point into the vacuum 0rangle : Phirangle=Phi(0)0rangle. The state and its corresponding operator has the same mathrmSO(3) spin and representation under global symmetry. More importantly, as the Weyl transformation maps the Hamiltonian H corresponding to the time translation on the cylinder to the dilatation D on the flat spacetime, the excitation energy of a state Phirangle is proportional to the scaling dimension of the corresponding operator Delta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_Phi-E_0=fracvRDelta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where E_0 is the ground state energy, R is the radius of the sphere, and v is the speed of light that is dependent on the microscopic model and is the same for different states. With this property, one can calculate the scaling dimensions simply by obtaining the energy spectrum of the quantum Hamiltonian without doing complicated finite size scalings, and one can obtain the OPE coefficients simply from the inner product of a local operator.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Although the quantum Hamiltonians on a sphere enjoy the full rotation symmetry and the property of state-operator correspondence, it is difficult to put a lattice on the sphere due to the curvature (in particular the non-zero Euler characteristic), especially to recover an mathrmSO(3)-symmetric theomodynamic limit. An alternative way we take is to fuzzify the sphere. We consider charged free particles moving on a sphere with a magnetic monopole with a flux 4pi s (sinmathbbZ2) placed at its centre. The monopole exerts a uniform magnetic field on the sphere, which modifies the single particle Hamiltonian and the single particle eigenstates. Now the single particle eigenstates form highly degenerate spherical Landau levels. The lowest Landau level has a degeneracy (2s+1). By setting the single particle gap to be the leading energy scale, adding interactions, and projecting onto the lowest Landau level, we obtain a finite Hilbert space. For the sake of numerical simulation, the system is analoguous to a length-(2s+1) spin chain with long range interaction, where different Landau level orbitals behave like the lattice sites. The difference is that the (2s+1) orbital forms a spin-s representation of the mathrmSO(3) rotation group, and in this way the continuous rotation symmetry is preserved. The word « fuzzy » means the non-commutativity, in our case, due to the presence of magnetic field. The non-commutativity provides a natural length scale which serves as a UV regulator of the quantum field theory. The radius of the sphere scales as Rsimsqrt s. The thermodynic limit can be taken as stoinfty, and we then recover a regular sphere without non-commutativity. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The power of this approach has been first demonstrated in the context of the 3D Ising transition, where the presence of emergent conformal symmetry has been convincingly established and a wealth of conformal data has been accurately computed. The study has then been extended to accessing various conformal data such as the OPE coefficients, correlation functions, entropic F-function, conformal generators in the 3d Ising CFT, studying conformal defects and boundaries such as the magnetic line defect, various conformal boundaries in 3D Ising CFT, and realising various 3d CFTs such as Wilson-Fisher CFTs, mathrmSO(5) deconfined criticality, mathrmSp(N) symmetric CFTs, etc. In the following sections, we shall review the existing works, technical details and the numerical methods. ","category":"page"},{"location":"intro/#Review-of-existing-work","page":"Introduction","title":"Review of existing work","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this section, we review the existing work related to fuzzy sphere. ","category":"page"},{"location":"intro/#Zhu2022","page":"Introduction","title":"The pioneering work","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhu 2022] Uncovering conformal symmetry in the 3d Ising transition : state-operator correspondence from a quantum fuzzy sphere regularisation, Wei Zhu, Chao Han, Emilie Huffman, Johannes S. Hofmann, and Yin-Chen He, arXiv:2210.13482, Phys. Rev. X 13, 021009 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work first proposes the idea of fuzzy sphere and apply it to a pedagogical example of 3d Ising CFT. This work constructs a model with two flavours of fermions that resembles the spin-up and spin-down in the lattice transverse-field Ising model. At half-filling, one can colloquially think that a spin degree of freedom lives on each orbital. The Hamiltonian contains a density-density interaction that resembles the Ising ferromagnetic interaction and a polarising terms that resembles the transverse field. By tuning the ratio of the two terms, a transition between quantum Hall ferromagnet (a two-fold degenerate state where either of the two flavours is completely occupied) and paramagnet (a one-fold degenerate state where the superpositions of the two flavours at each orbital are occupied) occurs. This transition spontaneously breaks a mathbbZ_2 symmetry and falls into the Ising criticality. This work then make use of a unique feature of spherical models described by CFT – state-operator correspondence – at the critical point to extract the scaling dimensions of the scaling local operators. This work finds evidence for conformal symmetry, including that (1) there exists a conserved stress tensor with Delta=3 (which is used as the calibrator), and (2) all the levels can be classified into conformal multiplet where the spacing between operators' scaling dimensions are very close to integer. This is one of the first numerical evidence that 3d Ising transition has emergent conformal symmetry. More remarkably, the scaling dimensions of primaries such as sigmaepsilonepsilon are already very close to the most accurate known value by numerical bootstrap with an error within 12 at a small system size N_m=16, for which the computational cost is comparable to a 4times4 lattice system. The structure of Ising CFT operator spectrum already starts to show up at an even smaller system size N_m=4. All these clues point towards a curious observation that fuzzy sphere suffers from a remarkably small finite-size effect. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This seminal work opens a new avenue for studying 3d conformal field theories. After that, most of the researches on fuzzy sphere can roughly be catagorised into three directions (with several exceptions) :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Accessing various conformal data, \nRealising various 3d CFTs, and\nStudying conformal defects and boundaries.","category":"page"},{"location":"intro/#Accessing-various-conformal-data","page":"Introduction","title":"Accessing various conformal data","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first direction is to develop methods to calculate various data and quantities of 3d CFTs on fuzzy sphere. Typically, these methods are tested on the simplest example of 3d Ising CFT. For many of those CFT data, fuzzy sphere is the first non-perturbative method to access them ; for the others, the fuzzy sphere has achieved great consistency with previous methods such as quantum Monte Carlo and conformal bootstrap. So far, the accessible CFT data include operator spectrum, OPE coefficients, correlation functions, entropic F-function and conformal generators. ","category":"page"},{"location":"intro/#Hu2023Mar","page":"Introduction","title":"OPE coefficients","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hu 2023Mar] Operator product expansion coefficients of the 3d Ising criticality via quantum fuzzy sphere, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2303.08844, Phys. Rev. Lett 131, 031601 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from the operator spectrum, a wealth of CFT data can be obtained from the local operators. This work studies the local observables on the fuzzy sphere, including the density operators and certain four-fermion operators. These observables can be expressed as the linear combination of CFT local scaling operators. After a finite size scaling that takes into account the data from different system sizes, the subleading contribution can be substracted and only the leading contribution are left. In this way, the lowest primaries in Ising CFT in each symmetry sector, viz. mathbbZ_2-odd sigma and mathbbZ_2-even epsilon, can be realised. The OPE coefficients are then evaluated by taking the inner product of a fuzzy sphere local observable with two CFT states langlePhi_1Phi_2(hatmathbfn)Phi_3rangle. This work computes 17 OPE coefficients of low-lying CFT primary fields with high accuracy, including 4 that has not being reported before. The rest are consistent with numerical bootstrap results. It is also worth noting that this work start to apply DMRG to the fuzzy sphere. The maximal system size is increased from N_m=18 by ED to N_m=48 by DMRG.","category":"page"},{"location":"intro/#Han2023Jun","page":"Introduction","title":"Correlation functions","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Han 2023Jun] Conformal four-point correlators of the 3d Ising transition via the quantum fuzzy sphere, Chao Han, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.04681, Phys. Rev. B 108, 235123 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In addition to the OPE coefficients, the local observables can also be used to calculate correlation functions. By taking the inner product of two local observables (density operators) at a time displacement langlePhi_1Phi_2(hatmathbfn_0)Phi_3(hatmathbfntau)Phi_4rangle with two CFT states, a general four-point function can be calculated. This piece of CFT data in practice cannot be derived from the rest. This work calculates this four-point function in 3d Ising CFT with DMRG. A non-trivial check of conformality, the crossing symmetry, is verified for the correlator langlesigmasigmasigmasigmarangle. The special case – two-point functions by taking Phi_1=Phi_4=mathbbI – are also studied and compared with the expected results by conformal symmetry. ","category":"page"},{"location":"intro/#Hu2024","page":"Introduction","title":"Entropic F-function","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hu 2024] Entropic F-function of 3d Ising conformal field theory via the fuzzy sphere regularisation, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2401.17362.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Beyond the correlators of local operators, a wealth of information can be learnt from the entanglement entropy and entanglement spectrum. A remarkable quantity is called the F-function, which is defined through the scaling behaviour of the entanglement entropy. Specifically, consider a quantum system that lives on mathbbR^2. A circle with radius R_d divides the system into inner part A and outer part B. The entanglement entropy is defined and expected to scale with R_d as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    S_A(R_d)=operatornametr_Arhologrho=alpha R_ddelta-F","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where delta is a UV-regulator. The constant part is known as the F-function of a 3d CFT. The F-function is proved to be RG-monotonic, i.e., along a renormalisation group flow from UV to IR, the value of F-function is non-increasing, analogous to the central charge in 2d CFTs. Despite its importance, it has never been calculated before through non-perturbative approaches in interacting 3d CFTs. This work has performed the first non-perturbative computation of F function for paradigmatic 3d Ising CFT on fuzzy sphere. The sphere is cut in the real space into two crowns along a latitude circle theta, and the entanglement entropy S_A(theta) as a function of theta is calculated. The F-function is extracted from the S_A(theta) in vicinity of the equator, and the result yields F_A=00612(5) after a finite size scaling.","category":"page"},{"location":"intro/#Fardelli2024","page":"Introduction","title":"Conformal generators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Fardelli 2024] Constructing the infrared conformal generators on the fuzzy sphere, Giulia Fardelli, A. Liam Fitzpatrick, and Emanuel Katz, arXiv:2409.02998.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Fan 2024] Note on explicit construction of conformal generators on the fuzzy sphere, Ruihua Fan, arXiv:2409.08257.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Within the generators of conformal symmetry, the mathrmSO(3) rotation and the dilatation are manifest and act as rotation and time translation on fuzzy sphere. The rest two, viz. translation P^mu and special conformal transformation (SCT) K^mu needs to be emergent in the IR at the conformal point but broken along the RG flow. It is worthwhile to construct these IR generators by the UV operators on fuzzy sphere. These works invest in such construction with the help of stress tensor T^munu. The time component T^tautau of stress tensor equals the Hamiltonian density mathscrH and it integrates into the generator Lambda^mu=P^mu+K^mu=intmathrmdhatmathbfnn^mumathscrH. The action of this generator send a scaling operator to other operators in the same multiplet with the number of partial derivatives increased or decreased by one. These works calculate the matrix elements of the generators Lambda^mu and compare it with the theoretical values in the CFT and find good agreement, which is another non-trivial verification of conformal symmetry. Furthermore, the separate generators P^mu and K^mu can be obtained by considering the commutatator HLambda^mu, which is useful in determining the primaries.","category":"page"},{"location":"intro/#Realising-various-3d-CFTs","page":"Introduction","title":"Realising various 3d CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The second direction is to study various other CFTs beyond 3d Ising. Fuzzy sphere has revealed many new information about these theories ; the previously known results are also consistent with the fuzzy sphere. So far, the accessible CFTs include mathrmSO(5) deconfined criticality, mathrmO(3) Wilson-Fisher and a series of new theories with mathrmSp(N) symmetry. ","category":"page"},{"location":"intro/#Zhou2023","page":"Introduction","title":"The mathrmSO(5) deconfined criticality","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2023] The mathrmSO(5) deconfined phase transition under the fuzzy sphere microscope: approximate conformal symmetry, pseudo-criticality, and operator spectrum, Zheng Zhou, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.16435, Phys. Rev. X 14, 021044 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first theory besides Ising CFT to which fuzzy sphere is applied is the mathrmSO(5) deconfined quantum critical point (DQCP). Deconfined quantum critical point (DQCP) is one of the pioneering example of phase transitions beyond Landau paradigm. It has led to numerous theoretical surprises including the emergent mathrmSO(5) symmetry and the duality between interacting theories. Despite extensive studies over the past two decades, its nature remains controversial. Numerical simulations have shown no signal of discontinuity, but abnormal scaling behaviors have been observed~\\cite{Senthil2023DQCP}. A plausible proposal to reconcile the tension is that DQCP is pseudocritical, i.e., a weakly first-order phase transition that has approximate critical behaviour, and is controlled by a pair of complex fixed points very close to the pseudocritical region.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The DQCP can be conveniently studied on the fuzzy sphere by constructing a non-linear sigma model (NLσM) on target space S^4 with a level-1 topological Wess-Zumino-Witten (WZW) term, which serves as a dual description of the DQCP with an exact mathrmSO(5) symmetry. The idea is to construct a four-flavour model with global symmetry mathrmSp(2)mathbbZ_2=mathrmSO(5) (mathbbZ_2 means to gauge the pseudoreal representations). At half-filling, it can be described by a NLσM on the Grassmannian tfracmathrmSp(2)mathrmSp(1)timesmathrmSp(1)cong S^4 and the WZW level can be matched. This work provides evidence that the DQCP exhibits approximate conformal symmetry. This work has identified 19 conformal primaries and their 82 descendants. Furthermore, by examining the renormalisation group flow of the lowest symmetry singlet, this work demonstrates that the DQCP is more likely pseudo-critical, with the approximate conformal symmetry plausibly emerging from nearby complex fixed points.","category":"page"},{"location":"intro/#Han2023Dec","page":"Introduction","title":"The mathrmO(3) Wilson-Fisher","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Han 2023Dec] Conformal operator content of the Wilson-Fisher transition on fuzzy sphere bilayers, Chao Han, Liangdong Hu, and Wei Zhu, arXiv:2312.04047, Phys. Rev. B 110, 115113 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The mathrmO(N) Wilson-Fisher theories are probably one of the most studied theories for 3d criticalities with wide range of applications. Specifically, this work focus on the mathrmO(3) WF CFT. The construction involves two copies of mathrmSU(2) ferromagnet with altogether 4 flavours. Briefly speaking, the model contains two competing terms : (1) a mathrmSU(2) ferromagnetic interaction which favours a Heisenberg ferromagnetic phase where each of the two copies being half-filled and the symmetry-breaking order parameter lives on a S^2 manifold, (2) a transverse field which favours one of the two copies being completely filled, corresponding to a Heisenberg paramagnet. The transition between these two phases falls into the mathrmO(3) Wilson-Fisher universality. Through the energy spectrum at the transition, this work provides evidence that mathrmO(3) Wilson-Fisher fixed point exhibits conformal symmetry, as well as revealing a wealth of information about the CFT can be revealed, such as the instability to cubic anisotropy. This work also calculates several OPE coefficients.","category":"page"},{"location":"intro/#Zhou2024Oct","page":"Introduction","title":"A series of new mathrmSp(N)-symmetric CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2024Oct] A new series of 3d CFTs with mathrmSp(N) global symmetry on fuzzy sphere, Zheng Zhou, and Yin-Chen He, arXiv:2410.00087.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The quest to discover new 3d CFTs has been intriguing for physicists. A virgin land on this quest is the parity-breaking CFTs. In 3d, the Chern-Simons-matter theories stand out as the most well known and possibly the only known type of parity-breaking CFTs. Fuzzy sphere is a promising platform to study these theories. This work makes a concrete construction by generalising the DQCP to the WZW-NLσM on the target space of a general symplectic Grassmannian","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    fracmathrmSp(N)mathrmSp(M)timesmathrmSp(N-M)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Several candidate Chern-Simons-matter theories are known to exist on its phase diagram which have N flavour of gapless bosons or fermions coupled to a non-Abelian (viz. mathrmSp(1), mathrmSp(2), etc.) Chern-Simons gauge field. On the fuzzy sphere, this WZW-NLσM can be realised by a 2N layer model with mathrmSp(N) global symmetry, and 2M out of the 2N layers are filled. This work numerically verifies the emergent conformal symmetry by observing the integer-spaced conformal multiplets and studying the finite-size scaling of the conformality. ","category":"page"},{"location":"intro/#Yang2025","page":"Introduction","title":"The 3-state Potts model","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Yang 2025] Microscopic study of 3d Potts phase transition via fuzzy sphere regularisation, Shuai Yang, Yan-Guang Yue, Yin Tang, Chao Han, Wei Zhu, and Yan Chen, arXiv:2501.14320","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The Potts models describe transitions that spontaneously break S_Q symmetries where QinmathbbZ is known as the number of states. In 2d, the transitions with Qleq Q_c=4 are continuous and captured by CFTs, while QQ_c are first order. Specifically, 2d 5-state Potts transition is pseudocritical and described by a pair of complex CFTs in its vicinity in a similar manner with mathrmSO(5) DQCP. In 3d, the 3-state Potts model is found to be first-order. This work constructs a 3-flavour model on the fuzzy sphere with S_3 permutation symmetry between layers. The interacting Hamiltonian resembles the Ising model. Interestingly, this work finds out that the transition point of the 3d 3-state Potts model, despite being probably first-order, exhibits approximate conformal symmetry, indicating that there might be an underlying CFT describing it. However, it is difficult to determine the nature of the transition from the operator spectrum (specifically, from the relevance of the second singlet epsilon) due to the complicated finite size effect.","category":"page"},{"location":"intro/#Studying-conformal-defects-and-boundaries","page":"Introduction","title":"Studying conformal defects and boundaries","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from the bulk CFTs, fuzzy sphere can also be used to study their conformal defects and boundaries. Deforming a CFT with interactions living on a sub-dimensional defect may trigger a RG flow towards a non-trivial interacting IR fixed point. A defect IR theory that own a smaller conformal symmetry is called a defect CFT. The dCFTs own rich physical structure such as defect operators and bulk-to-defect correlation functions. Moreover, a bulk CFT can flow to several different dCFTs. So far, the accessible defects/boundaries include the magnetic line defect of 3d Ising CFT, including its defect operator spectrum, correlators, g-function, defect changing operators, its cusp, and the conformal boundaries of 3d Ising CFT.","category":"page"},{"location":"intro/#Hu2023Aug","page":"Introduction","title":"Conformal magnetic line defect","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hu 2023Aug] Solving conformal defects in 3d conformal field theory using fuzzy sphere regularisation, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2308.01903, Nat. Commun. 15, 3659 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This is the first work that studies conformal defects with fuzzy sphere. The simplest example of conformal defect is the magnectic line defect of the 3d Ising CFT, where the defect line is completely polarised and the mathbbZ_2 symmetry is explicitly broken. Taking a defect line along z-direction that passes the origin point, after the radial quantisation, this corresponds to the north and south poles of the sphere being polarised. Hence, to realise the magnetic line defect on fuzzy sphere, one only needs to apply a pinning magnetic field to the north and south poles (Since only the m=+s orbital has non-zero amplitude at the north pole and m=-s at the south pole due to the locality, one only need to pin the m=pm s orbitals). ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work demonstrates that the defect IR fixed point has emergent conformal symmetry mathrmSO(21)timesmathrmO(2) : in the operator spectrum, there exists a displacement operator as the non-conservation of stress tensor at exactly Delta_mathrmD=2, and the defect primaries and descendants have integer spacing ; the bulk-to-defect one-point (1-pt) and two-point (2-pt) correlation functions follow a power law. This work has identified 6 low-lying defect primary operators and extract their scaling dimensions, as well as computing one-point bulk correlators and two-point bulk-defect correlators.","category":"page"},{"location":"intro/#Zhou2024Jan","page":"Introduction","title":"The g-function and defect changing operators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2024Jan] The g-function and defect changing operators from wavefunction overlap on a fuzzy sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, Yijian Zou, arXiv:2401.00039, SciPost Phys. 17, 021 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work studies the g-function of conformal defects and the defect creation and changing operators. Similar to the central charge and the F-function in bulk CFTs, there exists a RG-monotonic quantity called the g-function for the line defects that is non-increasing along the flow. It is defined as the ratio between the partition functions of the defect CFT and the bulk CFT. On the other hand, consider two semi-infinite magnetic line defects that are pinned towards opposite directions joint at one point, a defect changing operator lives at the joining point. Similarly, a defect creation operator lives at the endpoint of a semi-infinite line defect. The relevance of the defect changing operator is related to the stability of spontaneous symmetry-breaking (SSB) on the line defect. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work realises the defect creation and changing operators for the Ising mangetic line defect by acting a pinning field at the north pole, and opposite pinning fields at the north and south poles, respectively. The scaling dimensions are calculated through state operator correspondence Delta_mathrmcreation=0108(5)Delta_mathrmchanging=084(5), indicating the instability of SSB on the Ising mangetic line. Moreover, this work shows that the g-function, along with many other CFT data, can be calculated by taking the overlaps between the eigenstates of different defect configurations. Most importantly, this paper has given the first non-perturbative result for the g-function g=0602(2).","category":"page"},{"location":"intro/#Cuomo2024","page":"Introduction","title":"Cusp","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Cuomo 2024] Impurities with a cusp : general theory and 3d Ising, Gabriel Cuomo, Yin-Chen He, Zohar Komargodski, arXiv:2406.10186, J. High Energy Phys. 11 (2024) 061. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A cusp is two semi-infinite defect lines joined at one point at an angle. This can be realised on fuzzy sphere through pinning fields at two points at an angle. This work studies the cusps through various theoretical and numerical approaches. In particular, on fuzzy sphere, this paper calculates the cusp anomalous dimension as a function of the angle for the Ising magnetic line defects, and verifies its relation with the Zamolodchikov norm of the displacement operator. ","category":"page"},{"location":"intro/#Zhou2024Jul","page":"Introduction","title":"Conformal boundaries of 3d Ising CFT","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2024Jul] Studying the 3d Ising surface CFTs on the fuzzy sphere, Zheng Zhou, and Yijian Zou, arXiv:2407.15914.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Dedushenko 2024] Ising BCFTs from the fuzzy hemisphere, Mykola Dedushenko, arXiv:2407.15948.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from line defects, boundaries are also important extended objects in CFT. For the Ising CFT, there exists several conformal boundaries : normal boundary CFT (bCFT) with explicitly broken mathbbZ_2 symmetry, ordinary bCFT that is stable and has preserved mathbbZ_2 symmetry, extraordinary bCFT with spontaneously broken mathbbZ_2 symmetry, and special bCFT as the transition between ordinary and extraordinary bCFTs. These works focus on the normal and ordinary bCFTs and show that they can be realised by acting a polarising field on a hemisphere. By noting that the LLL orbitals are localised along latitude circles, the bCFTs can equivalently be realised by pinning the orbitals with m0. By studying the operator spectrum, these works show numerical evidence for conformal symmetry and estimates the scaling dimensions of the conformal primaries. These works also calculates the bulk-to-boundary 1-pt and 2-pt functions and extract the corresponding OPE coefficients. Interestings, these works notice certain correspondence between the boundary energy spectrum and bulk entanglement spectrum through orbital cut.","category":"page"},{"location":"intro/#Other-works-on-the-fuzzy-sphere","page":"Introduction","title":"Other works on the fuzzy sphere","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Besides the three directions of works, several other works push the boundary of our knowledge of and techniques for the fuzzy sphere. ","category":"page"},{"location":"intro/#Lao2023","page":"Introduction","title":"Conformal perturbation","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Lao 2023] 3d Ising CFT and exact diagonalisation on icosahedron : the power of conformal perturbation theory, Bing-Xin Lao, and Slava Rychkov arXiv:2307.02540, SciPost Phys. 15, 243 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The energy spectrum calculated numerically at finite size does not coincide with that of the CFT. Part of the finite-size correction comes from the higher irrelavant operators that are not exactly tuned to zero (e.g., in the Ising CFT, the irrelavent operators include epsilon C_munurhosigma T_munu, etc., and the lowest singlets epsilon and epsilon are tuned away through the two parameters). These irrelevant operators exert perturbations on the states and their energy. This paper captures this kind of correction by the conformal perturbation theory. By making use of the fact that the corrections from an irrelevant operator on the energy of the primary and its descendants are not independent, the coefficients of the irrelevant operators can be fitted.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Although this work is does not exactly carry out study on the fuzzy sphere, it opens up a new route of improving the precision of scaling dimensions on fuzzy sphere by making better use of the existing data, and the method to partly remove the finite-size correction through conformal perturbation theory is widely used by following works.","category":"page"},{"location":"intro/#Hofmann2024","page":"Introduction","title":"Quantum Monte Carlo on fuzzy sphere","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hofmann 2024] Quantum Monte Carlo simulation of the 3d Ising transition on the fuzzy sphere, Johannes S. Hofmann, Florian Goth, Wei Zhu, Yin-Chen He, and Emilie Huffman, arXiv:2310.19880, SciPost Phys. Core 7, 028 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Up to the time of this work, the numerical methods that has been applied to fuzzy sphere include exact diagonalisation (ED) and density matrix renormalisation group (DMRG). This work further presents the numerical studies of fuzzy sphere with quantum Monte Carlo (QMC) simulation, which is known for its potential of studying criticalities in (2+1) dimensions at larger system size. Specifically, this work makes use of the determinant quantum Monte Carlo (DQMC) method that converts the simulation of fermions into the simulation of bosonic auxiliary fields. To overcome the sign problem, this work considers two copies of the original model and constructs the Ising CFT on a 4-flavour model. This work determines the lowest energy spectra within each symmetry sector by calculating the time-displaced correlation functions. This work also calculates the equal-time correlation functions and compares them with the two-point functions of CFT. ","category":"page"},{"location":"intro/#Voinea2024","page":"Introduction","title":"Ising CFT on top of FQHE state","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Voinea 2024] Regularising 3d conformal field theories via anyons on the fuzzy sphere, arXiv:2411.15299.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Up to the time of this work, all the constructions of CFTs on fuzzy sphere are based on the quantum Hall ferromagnet. Specifically, before the interaction is added, an integer number of the lowest Landau levels are fully occupied. This state has a finite charge gap that guarentees that the gapless spin degree of freedom do not strongly couple with the charge degree of freedom when one adds the interactions. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work further explores the possibility to construct CFTs on other states with charge gap – in particular, the Haldane-Laughlin states that captures the fractional quantum Hall effect (FQHE). Specifically, this work studies the fermionic LLL at fillings of nu=13 and 15. The model Hamiltonian contains (1) a dominant projection term that put the ground state on the Haldane-Laughlin state, and (2) an interaction term as a perturbation that drives the Ising-type phase transition. This work shows that the energy spectra at the critical point exhibit conformal symmetry. More noticeably, this work also makes the construction with respect to the bosonic LLL at a filling of nu=12. ","category":"page"},{"location":"intro/#Han2025","page":"Introduction","title":"Fuzzy circle","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Han 2025] Quantum phase transitions on the noncommutative circle, Chao Han, and Wei Zhu, Phys. Rev. B 111, 085113 (2025)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Besides the fuzzy sphere S^2, the regularisation with the lowest Landau level can also be used for other manifolds or even dimensions. This work studies the 2d CFT on a `fuzzy circle'. Although Landau levels can only be defined on even space dimensions~\\cite{Hasebe2020Landau}, one can reach odd space dimensions by compactifying one of the even dimensions. Specifically, this work constructs the LLL on a thin torus T^2 and sends one of the lengths to infinity while fixing the other. In this way, a circle S^1 is recovered in the thermodynamic limit. This work constructs the 2d Ising and 3-state Potts CFTs on the fuzzy circle and compares the operator spectrum and OPE coefficients with the Virasoro multiplet structure and the exactly solvable minimal models.","category":"page"},{"location":"intro/#Model-construction","page":"Introduction","title":"Model construction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this section, we review the process to construct a model on fuzzy sphere and extract conformal data. We aim at providing the necessary technical information for those who want to participate in the research on fuzzy sphere, especially the aspects that are rarely covered by other literature. ","category":"page"},{"location":"intro/#Projection-onto-the-lowest-Landau-level","page":"Introduction","title":"Projection onto the lowest Landau level","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To build the setup of fuzzy sphere, we consider a sphere with radius R and put a 4pi s-monopole at its centre. Consider free electrons moving on the sphere. The monopole will modify the single particle Hamiltonian. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_0=frac12MR^2(partial^mu+iA^mu)^2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where mu=thetaphi and the gauge connection is taken as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    A_theta=0quad A_phi=-fracsRoperatornamectgtheta","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The eigenstates of the Hamiltonian are the monopole spherical harmonics","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Y_lm^(s)(hatmathbfn)quad l=ss+1dotsquad m=-ldotsl-1l","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where hatmathbfn is the unit vector of the point on the sphere specified by angular coordinates theta and phi, and the energies are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_l=frac12MR^2(l(l+1)-s^2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Each level, known as a Landau level, has a degeneracy (2l+1). Specifically, the wavefunctions on the lowest Landau level (LLL) l=s is easy to write out :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Y_sm^(s)(hatmathbfn)=C_me^imphicos^s+mfractheta2sin^s-mfractheta2quad C_m=frac1sqrt4piBeta(s+m+1s-m+1)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where C_m is the normalising factor, and Beta is the Euler's beta function. The LLL has a degeneracy N_m=2s+1.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We now consider N_f flavours of fermions moving on the sphere, characterised by the second-quantised fermion operator hatpsi_f(hatmathbfn), with a flavour index f=1dotsN_f. We partially fill the lowest Landau level and set the single energy gap to be much larger than the scale of interaction H_0gg H_mathrmint, so that the quantum fluctuation can be constrained on the lowest Landau level. In practice, we often fill integer number of flavours N_e=kN_m (kinmathbbZ) so that a quantum Hall ferromagnet (i.e., the state where integer number of LLLs are filled) is preferred in the absence of interaction, for which the charge degree of freedom is gapped and will not couple strongly to the CFT degree of freedom in the presence of the interaction.  ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then project the system onto the LLL. Technically, this can be done by write the fermion operators in terms of the annihilation operators of the LLL orbitals","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    hatpsi_f(hatmathbfn)=sum_m=-s^s Y^(s)_sm(hatmathbfn)hatc_mf","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where hatc^(dagger)_mf annihilates/creates an electron with L^z-quantum number m at the f-th flavour of the lowest Landau level. In the following sections, we will omit the hats on the operators. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"After the projection, we obtain a finite Hilbert space on which numerical simulation can be carried out. For the sake of numerical simulation, the system is analoguous to a length-(2s+1) spin chain with long range interaction, where different Landau level orbitals behave like the lattice sites. The difference is that the (2s+1) orbital forms a spin-s representation of the mathrmSO(3) rotation group, and in this way the continuous rotation symmetry is preserved. The exact rotation symmetry reduces the UV effect and the finite-size effect, so that the numerical results are considerably accurate even at small system size.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The word « fuzzy » means non-commutativity. Here the magnetic field results in a the non-commutativity of the coordinates. More concretely, we project write the coordinate operators as a matrix on the lowest Landau level","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    X^mu_m_1m_2=intmathrmd^2hatmathbfnn^mu barY_sm_1^(s)(hatmathbfn)Y_sm_2^(s)(hatmathbfn)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"These matrices mathbfX^mu (mu=xyz) satisfy relation ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathbfX_mumathbfX^mu=fracss+1mathbbIqquad mathbfX^mumathbfX^nu=frac1s+1iepsilon^munurhomathbfX_rho","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first equation involves the radius R of the sphere, and the second equation involves the magnetic length l_B that determines the non-commutativity. An arbitrary scale factor can change these lengths but their ratio is fixed and scales as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Rl_BsimsqrtssimsqrtN_m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We can take l_B=1 as the unit length. In this way, the radius scales with the square root of number of orbitals. The thermodynamic limit can be taken by N_mtoinfty, where a regular sphere is recovered.","category":"page"},{"location":"intro/#Density-operator","page":"Introduction","title":"Density operator","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Having constructed the single particle states, we then consider the interacting many-body Hamiltonian. The simplest building block is the density operators, i.e., local fermion bilinears. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(hatmathbfn)=psi_f^dagger(hatmathbfn)M_ffpsi_f(hatmathbfn)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here the matrix insertion M put the density operators at a certain representation of the flavour symmetry. For example, for a 2-flavour system, M can be taken as the Pauli matrices mathbbIsigma^xsigma^ysigma^z ; for a system with N_f flavours in the fundamental representation of mathrmSU(N_f) flavour symmetry, one can put n_M in the singlet or adjoint representation ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        n_S(hatmathbfn)=psi_c^dagger(hatmathbfn)psi^c(hatmathbfn)\n        n_a^b(hatmathbfn)=psi_a^dagger(hatmathbfn)psi^b(hatmathbfn)-tfrac1Ndelta_a^bpsi_c^dagger(hatmathbfn)psi^c(hatmathbfn)\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Like the fermion operator, the density operator can also be expressed in the orbital space. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(hatmathbfn)=sum_lmY_lm(hatmathbfn)n_Mlm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conversely,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        n_Mlm=intmathrmd^2hatmathbfnbarY_lmn_M(hatmathbfn)\n        =intmathrmd^2hatmathbfnbarY_lmleft(sum_m_1barY^(s)_sm_1c^dagger_m_1f_1right)M_f_1f_2left(sum_m_2Y^(s)_sm_2c_m_1f_2right)\n        =sum_m_1m_2c^dagger_m_1f_1M_f_1f_2c_m_1f_2intmathrmd^2hatmathbfnbarY_lmbarY^(s)_sm_1Y^(s)_sm_2\n        =sum_m_1c^dagger_m_1f_1M_f_1f_2c_m+m_1f_2(-1)^s+m+m_1(2s+1)sqrtfrac2l+14pibeginpmatrixslsm_1m-m_1-mendpmatrixbeginpmatrixslsm_1m-m_1-mendpmatrix\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here we have used the properties of the monopole spherical harmonics","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        barY_lm^s=(-1)^s+mY_l-m^(-s)\n        intmathrmd^2hatmathbfnY_lm^(s)barY_lm^(s)=delta_lldelta_mm\n        intmathrmd^2hatmathbfnY_l_1m_1^(s_1)Y_l_2m_2^(s_2)Y_l_3m_3^(s_3)=sqrtfrac(2l_1+1)(2l_2+1)(2l_3+1)4pibeginpmatrixl_1l_2l_3m_1m_2m_3endpmatrixbeginpmatrixl_1l_2l_3-s_1-s_2-s_3endpmatrix\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and beginpmatrixl_1l_2l_3m_1m_2m_3endpmatrix is the 3j-symbol. In this way, we have fully expressed the density operator in terms of the operators in the orbital space c^(dagger)_mf. ","category":"page"},{"location":"intro/#Density-density-interaction","page":"Introduction","title":"Density-density interaction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The most straightforward way to construct an interaction term is to add a density-density interaction potential with a potential function. We note that this is not the simplest construction and we will present the simpler construction in terms of pseudopotentials in the next section. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_mathrmint=intmathrmd^2hatmathbfn_1mathrmd^2hatmathbfn_2U(hatmathbfn_1-hatmathbfn_2)n_M(hatmathbfn_1)n_M(hatmathbfn_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The interacting potentials can be expanded in terms of the Legendre polynomials ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U(mathbfr_12)=sum_ltildeU_lP_l(costheta_12)=sum_lmfrac4pi2l+1barY_lm(hatmathbfn_1)Y_lm(hatmathbfn_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where mathbfr_12=hatmathbfn_1-hatmathbfn_2 and mathbfr_12=2sintheta_122. Conversely ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    tildeU_l=intsintheta_12mathrmdtheta_12frac2l+12U(mathbfr_12)P_l(costheta_12)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Specifically, for local and super-local interactions","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        U(mathbfr_12)=delta(mathbfr_12)tildeU_l=2l+1\n        U(mathbfr_12)=nabla^2delta(mathbfr_12)tildeU_l=-l(l+1)(2l+1)\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"By expanding the density operators into the orbital space and completing the integrals,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_mathrmint=sum_lmfrac4pi tildeU_l2l+1n^dagger_Mlmn_Mlm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"With these ingrediants, we can now considerhow to construct models. This comes down to matching the symmetry and phase diagram. E.g., for the Ising model, the mathbbZ_2 global symmetry is realised as the exchange of the two flavours psi_uparrow(mathbfr)psi_downarrow(mathbfr). We need a phase diagram with a paramagnetic (PM) phase where the mathbbZ_2 symmetry is conserved and a ferromagnetic phase where the mathbbZ_2 symmetry is spontaneously broken. The PM phase is favoured by a polarising term that ressembles a transverse field","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    -hintmathrmd^2hatmathbfnn_x(hatmathbfn)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and the FM phase where either of the two flavours is fully filled is favoured by a repulsion between the two flavours","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    intmathrmd^2hatmathbfn_1mathrmd^2hatmathbfn_2U(hatmathbfn_1-hatmathbfn_2)n_uparrow(hatmathbfn_1)n_(hatmathbfn_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the density operators are defined as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_x(hatmathbfn)=psi^dagger_downarrow(hatmathbfn)psi_uparrow(hatmathbfn)+psi^dagger_uparrow(hatmathbfn)psi_downarrow(hatmathbfn)quad n_uparrow=psi^dagger_uparrow(hatmathbfn)psi_uparrow(hatmathbfn)quad n_downarrow=psi^dagger_downarrow(hatmathbfn)psi_downarrow(hatmathbfn)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and the potentials can be most conveniently taken as a combination of local and super-local interactions. Altogether the model Hamiltonian reads","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_mathrmint=intmathrmd^2hatmathbfn_1mathrmd^2hatmathbfn_2U(hatmathbfn_1-hatmathbfn_2)n_(hatmathbfn_1)n_(hatmathbfn_2)-hintmathrmd^2hatmathbfnn_x(hatmathbfn)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"By tuning the ratio between h and U(mathbfr_12), a phase transition described by the Ising CFT is realised.","category":"page"},{"location":"intro/#Interaction-in-terms-of-pseudopotentials","page":"Introduction","title":"Interaction in terms of pseudopotentials","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Another way that is much more convenient to construct the interactions is through Haldane pseudopotential. To explain the idea, we take the 3d Ising model as an example. We first classify all the fermion bilinears lambda_mmffc_mfc_mf. To simplify the discussion, we can take a specific isospin index lambda_mmc_muparrowc_mdownarrow. The fermion bilinears can be classified into irreducible representations of mathrmSO(3) rotation symmetry. Since c_mf carries the spin-s representation, the spin of its bilinear ranges from 0 to 2s and takes integer values. The spin-(2s-l) combination reads","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm=sum_m_1langle sm_1s(m-m_1)(2s-l)mrangle c_m_1uparrowc_m-m_1downarrow","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where m=-(2s-l)dots(2s-l), and the Clebshbar-Gordan coefficients is related to the 3j-symbol by","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    langle l_1m_1l_2m_2lmrangle=(-1)^-l_1+l_2-msqrt2l+1beginpmatrixl_1l_2lm_1m_2-mendpmatrix","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A four-fermion interaction term is formed by contracting these paring operators with its conjugate. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=sum_lU_lH_lquad H_l=sum_mDelta_lm^daggerDelta_lm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Putting these altogether, the interaction Hamiltonian can be expressed as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=sum_lm_1m_2m_3m_4U_lC^l_m_1m_2m_3m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow-hsum_m(c_muparrow^dagger c_mdownarrow+mathrmhc)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the matrix elements are ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    C^l_m_1m_2m_3m_4=delta_m_1+m_2m_3+m_4langle sm_1sm_2(2s-l)(m_1+m_2)ranglelangle sm_3sm_4(2s-l)(m_3+m_4)rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The coupling strength U_l of the spin-(2s-l) channel is called the Haldane pseudopotentials. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We need also to consider the constraint that the two fermions must be anti-symmetrised : for even l, the orbital index is symmetrised, so the spin index must be antisymmetrised, so the two fermions form a spin-singlet which is invariant under the mathrmSU(2) transformation ; for odd l, the orbital index is anti-symmetrised, so the spin index is symmetrised, breaking the flavour symmetry from mathrmSU(2) to mathbbZ_2. Hence, an odd-l pseudopotential must be added (This fact escapes the construction by density-density interaction).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The fermion bilinears with other isospin configurations lambda_mmpm(c_muparrowc_muparrowpm c_mdownarrowc_mdownarrow) can be analysed in a similar way. After that, we have enumerated all possible four-fermion interaction terms. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For systems with more complicated continuous symmetries, classification in terms of representation of flavour symmetry must also be considered, and the indices must be overall antisymmetrised. We explain that through the example of a 2N-flavour system with mathrmSp(N) global symmetry [Zhou 2024Oct]. The maximal flavour symmetry is mathrmSU(2N), so interactions must be added to break the symmetry from mathrmSU(2N) to mathrmSp(N). The fermion operators live in the mathrmSp(N) fundamental representation. We shall show that all the allowed terms are ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=sum_substacklinmathbbZm_1m_2m_3m_4U_lC^l_m_1m_2m_3m_4c^dagger_m_1ac^dagger_m_2bc_m_3bc_m_4a-frac12sum_substacklin 2mathbbZm_1m_2m_3m_4V_lC^l_m_1m_2m_3m_4Omega_aaOmega_bbc^dagger_m_1ac^dagger_m_2ac_m_3bc_m_4b","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where Omega=beginpmatrix0mathbbI_N-mathbbI_N0endpmatrix.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To find out all the four-fermion interactions allowed by the rotation symmetry mathrmSO(3) and flavour symmetry mathrmSp(N), we classify all the fermion bilinears c_m_1ac_m_2b into irreducible representations (irrep) of mathrmSO(3)timesmathrmSp(N). For each irrep, by contracting the bilinear with its Hermitian conjugate, we obtain an allowed four-fermion interaction term. Each fermion carries mathrmSO(3) spin-s and mathrmSp(N) fundamental. For the rotation symmetry mathrmSO(3), the bilinear can carry spin-(2s-l)(l=0dots2s) represetation ; for even l, the orbital indices are symmetrised ; for odd l, the orbital indices are antisymmetrised. For the flavour symmetry mathrmSp(N), the bilinear can carry singlet S, traceless antisymmetric rank-2 tensor A and symmetric rank-2 tensor T representation ; for S and A, the flavour indices are antisymmetrised ; for T, the flavour indices are symmetrised. As the two fermions altogether should be antisymmetrised, the allowed combinations are ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Case 1. mathrmSp(N) singlet and mathrmSO(3) spin-(2s-l) with even l, the bilinears are ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm=sum_m_1m_2langle sm_1sm_2(2s-l)mrangleOmega_aac_m_1ac_m_2adelta_mm_1+m_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The corresponding interaction term H_Sl=sum_mDelta_lm^daggerDelta_lm is the even-l pseudopotential for the V-term.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Case 2. mathrmSp(N) antisymmetric and mathrmSO(3) spin-(2s-l) with even l, the bilinears are ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lmab=sum_m_1m_2langle sm_1sm_2(2s-l)mrangleleft(c_m_1ac_m_2b-c_m_1bc_m_2a-tfrac1NOmega_abOmega_ccc_m_1cc_m_2cright)delta_mm_1+m_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The corresponding interaction term H_Al=sum_mDelta_lmab^daggerDelta_lmab is the even-l pseudopotential for the U-term.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Case 3. mathrmSp(N) symmetric and mathrmSO(3) spin-(2s-l) with odd l, the bilinears are ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm(ab)=sum_m_1m_2langle sm_1sm_2(2s-l)mrangleleft(c_m_1ac_m_2b+c_m_1bc_m_2aright)delta_mm_1+m_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The corresponding interaction term H_Tl=sum_mDelta_lm(ab)^daggerDelta_lm(ab) is the odd-l pseudopotential for the U-term.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In summary, all allowed interactions are the U_l terms with both even and odd l, and the V_l terms with only even l.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We also note that each pseudopotential can correspond to a profile of interaction potential functions. The conversion between the pseudopotentials U_l and the Legendre expansion coefficients of the potential function tildeU_l ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U(mathbfr_12)=sum_ltildeU_lP_l(costheta_12)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"is ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"U_l=sum_k tildeU_k(-1)^l(2s+1)^2beginBmatrix2s-lsskssendBmatrixbeginpmatrixsks-s0sendpmatrix^2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where dots is the 6j-symbol. Specifically, a local interaction contains only pseudopotential U_0 ; a superlocal interaction of form (nabla^2)^ldelta(mathbfr_12) contains U_0U_1dotsU_l. Here we give the expressions for the lowest pseudopotentials explicitly.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    beginaligned\n        U(mathbfr_12)=delta(mathbfr_12)U_0=frac(2s+1)^24s+1\n        U(mathbfr_12)=nabla^2delta(mathbfr_12)U_0=-fracs(2s+1)^24s+1U_1=fracs(2s+1)^24s-1\n    endaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"More details are given in Fan 2024.","category":"page"},{"location":"intro/#Operator-spectrum-and-search-for-conformal-point","page":"Introduction","title":"Operator spectrum and search for conformal point","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Having introduced how to construct an interacting model on fuzzy sphere, we now turn to the verification of the conformal symmetry and the extraction of the CFT data. The most straightforward approach is to extract the scaling dimensions from the energy spectrum through the state-operator correspondence. Specifically, there is a one-to-one correspondence between the eigenstates of the Hamiltonian and the CFT operators. The state and its corresponding operator has the same mathrmSO(3) spin and representation under flavour symmetry, and the excitation energy of a state Phirangle is proportional to the scaling dimension of the corresponding operator Delta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_Phi-E_0=fracvRDelta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where E_0 is the ground state energy, R is the radius of the sphere (here we take R=sqrtN_m), and v is the model-dependent speed of light. The constant vR can be determined through a calibration process, i.e., comparing the spectrum to some known properties of a CFT spectrum. The criteria to determine the conformal symmetry include ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The existence of a conserved stress tensor T^munu. The stress tensor is the symmetry current of the translation transformation. It is known to be a singlet under the flavour symmetry, have spin-2 under mathrmSO(3) rotation and scaling dimension exactly Delta_T^munu=3.\nThe existence of a conserved flavour symmetry current J^mu if there is a continuous flavour symmetry. The symmetry current typically lives in the antisymmetric rank-2 tensor representation of the flavour symmetry. E.g., if the flavour symmetry is mathrmU(1), then the symmetry current has charge-0 ; if the flavour symmetry is mathrmO(3), then the symmetry current has spin-1 and is odd under the improper mathbbZ_2 transformation ; if the flavour symmetry is mathrmO(n) (nge 4) or mathrmSU(n) (nge 3), then the symmetry current lives in the antisymmetric rank-2 tensor representation. \nThe organisation of the operator spectrum into conformal multiplets. All the levels in the spectrum of a CFT can be organised into the conformal primaries and their descendants. The descendants live in the same representation under the flavour symmetry as the primary, and the difference between the scaling dimensions of a primary and its descendant is an integer. Specifically, for a scalar primary Phi, its descendants have the form Box^npartial^mu_1partial^mu_2dotspartial^mu_lPhi-textrm(trace) (nl=012dots) with mathrmSO(3) spin-l and scaling dimension Phi+2n+l, where Box=partial_mupartial^nu. For a spinning primary Phi^mu_1dotsmu_s, its descendants has the two forms : Box^npartial^nu_1dotspartial^nu_mpartial_rho_1dotspartial_rho_kPhi^rho_1dotsrho_kmu_1dots mu_s-k (k=0dotss, nm=01dots) with scaling dimension Delta_Phi+k+m+2n and mathrmSO(3) spin-(s-k+m), and Box^npartial^nu_1dotspartial^nu_mpartial_rho_1dotspartial_rho_kepsilon^sigma_tildemutildenupartial^tildenuPhi^rho_1dotsrho_ktildemumu_1dots mu_s-k-1 (k=0dotss-1, nm=01dots) with scaling dimension Delta_Phi+k+m+2n+1 and mathrmSO(3) spin-(s-k+m). For the second form, the fully antisymmetric tensor epsilon alters the parity.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The most convenient way of determining the coefficient vR is by utilising criteria 1 or 2 :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    fracvR=fracE_T^munu-E_03quadtextrmorquadfracE_J^mu-E_02","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Alternatively, one can define a cost function that depends on the tuning parameter and the speed of light and compares the scaling dimensions obtained from fuzzy sphere and the prediction by conformal symmetry. E.g., for the Ising CFT, the tuning parameters are the pseudopotentials U_i and the transverse field h. The criteria for conformal symmetry we use include the stress tensor T^munu and the descendants partial^musigma, partial^mupartial^nusigma, Boxsigma, partial^muepsilon. The cost function is the root-mean-square of the deviations of these criteria from the expectation of the conformal symmetry","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Q(U_ihvN_m)=frac1N_sleft(Delta_T^munu^(mathrmFS)-3)^2+(Delta_partial^musigma^(mathrmFS)-Delta_sigma^(mathrmFS)-1)^2+(Delta_partial^mupartial^nusigma^(mathrmFS)-Delta_sigma^(mathrmFS)-1)^2+(Delta_Boxsigma^(mathrmFS)-Delta_sigma^(mathrmFS)-1)^2+(Delta_partial^muepsilon^(mathrmFS)-Delta_epsilon^(mathrmFS)-1)^2right","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where N_s=5 is the number of criteria, the scaling dimensions of an operator Phi on the fuzzy sphere is determined as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_Phi^(mathrmFS)(U_ihvN_m)=fracE_Phi-E_0vR","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The optimal conformal point and calibrator are determined by minimising this cost function for each system size N_m. Note that this optimal point depends on the system size. In order to do finite size scaling, if the CFT describes a phase transition, one could fix all but one parameters at the optimal point in the largest accessible system size and tune the last parameter to determine the critical point through a finite size scaling. ","category":"page"},{"location":"intro/#Local-observables","page":"Introduction","title":"Local observables","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We have introduced how to determine the scaling dimensions from the energy spectrum. Beyond that, evaluating other CFT quantities requires realising local CFT operators on the fuzzy sphere. Any gapless local observables mathscrO(hatmathbfn) on the fuzzy sphere can be written as the linear combination of CFT operators that lives in the same representation of flavour symmetry and parity.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathscrO(hatmathbfntau)=sum_alpha lambda_alphaPhi^(mathrmcyc)_alpha(hatmathbfntau)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here special care should be taken for the CFT operator Phi^(mathrmcyc)_alpha(hatmathbfntau) on the cylinder. A conformal transformation produces a scale factor Lambda(mathbfr)^Delta_Phi to a primary operator Phi. For the Weyl transformation from the flat spacetime to the cylinder, the scale factor is Lambda(mathbfr)=rR. Hence,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi^(mathrmcyc)_alpha(hatmathbfntau)=left(frace^tauRRright)^Delta_Phi_alphaPhi_alpha^mathrm(flat)(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For descendants, certain other factors may be produced, but the conversion factors still scale with the radius of the sphere as R^-Delta where Delta is the scaling dimension of the descendants. For simplicity, hereafter we focus on the equal-time correlators with tau=0, for which Phi^(mathrmcyc)_alpha(hatmathbfn)=R^-Delta_Phi_alphaPhi_alpha^mathrm(flat)(mathbfr). The operator with larger system size decays faster when increasing system size. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The simplest local observable is the density operator. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n^M(hatmathbfn)=sum_f_1f_2psi_f_1^dagger(hatmathbfn)M_f_1f_2psi_f_2(hatmathbfn)=sum_m_1m_2f_1f_2barY^(s)_sm_1(hatmathbfn)Y^(s)_sm_2(hatmathbfn)c^dagger_m_1f_1M_f_1f_2c_m_2f_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The angular modes are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(hatmathbfn)=sum_lmY_lm(hatmathbfn)n_Mlm\n    n_Mlm=sum_m_1c^dagger_m_1f_1M_f_1f_2c_m+m_1f_2(-1)^s+m+m_1(2s+1)sqrtfrac2l+14pibeginpmatrixslsm_1m-m_1-mendpmatrixbeginpmatrixslsm_1m-m_1-mendpmatrix","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"From the CFT perspective, the density operators are the superpositions of scaling operators with corresponding quantum numbers, i.e., with the same representation under flavour symmetry and parity. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Take the Ising model as an example. Consider the density operators n^x and n^z with matrix insertion M=sigma^xsigma^z. In the leading order, they can be used as UV realisations of CFT operators sigma and epsilon. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    n^x(hatmathbfn)=lambda_0+lambda_epsilonepsilon(hatmathbfn)+lambda_partial^muepsilonpartial^muepsilon(hatmathbfn)+lambda_T^munuT^munu(hatmathbfn)+dotsepsilon_mathrmFS=fracn^x-lambda_0lambda_epsilon+dots\n    n^z(hatmathbfn)=lambda_sigmasigma(hatmathbfn)+lambda_partial^musigmapartial^muepsilon(hatmathbfn)+lambda_partial^mupartial^nusigmapartial^mupartial^nusigma(hatmathbfn)+dotssigma_mathrmFS=fracn^zlambda_sigma+dots\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the coefficients lambda_0lambda_epsilonlambda_sigmadots are model-dependent and need to be determined, and all the operators on the right hand side are defined on the cylinder. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We first consider the insertion of a single operator langlePhi_1Phi_2(hatmathbfn)Phi_3rangle. It helps us produce the OPE coefficients. For the simplest example of three scalars,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    f_Phi_1Phi_2Phi_3=lim_r_inftytoinftyr_infty^-2Delta_Phi_1langle Phi_1(x_infty)Phi_2(x)Phi_3(0)rangle_mathrmflat=langlePhi_1Phi_2^(mathrmflat)(x)Phi_3rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where x_infty is a point on the sphere with radius r_infty, x is a point on the unit sphere, the states are obtained from acting the operator at the origin point on the vacuum state","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    Phi_3rangle=Phi_3(0)0rangle\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and its Hermitian conjugate is defined as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_1^dagger(infty)=(Phi_1(0))^dagger=lim_r_inftytoinftyr_infty^2Delta_Phi_1Phi_1(x_infty)qquadlanglePhi_1=langle0Phi_1^dagger(infty)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"After the Weyl transformation from the flat spacetime to the cylinder, we obtain the expression on fuzzy sphere ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    f_Phi_1Phi_2Phi_3=R^Delta_Phi_2langlePhi_1Phi^(mathrmcyl)_2(hatmathbfn)Phi_3rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The UV realisation of Phi_2 contains many other operators with different spins. By integrating the correlation function against different spherical harmonics, i.e., take the angular modes of the operator inserted ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    intmathrmdhatmathbfnbarY_lm(hatmathbfn)langlePhi_1Phi_2(hatmathbfn)Phi_3rangle=langlePhi_1Phi_2lmPhi_3rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"we can filter out the subleading contributions with different spin. For the spinning operators, this will also tell us about different OPE structures. By taking Phi_3=mathbbI, we can recover the two point functions ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    langlePhi_2Phi_2000rangle=R^-Phi_2\n    Phi_2(hatmathbfn)0rangle=R^-Phi_2leftPhi_2rangle+lambda_mu(hatmathbfn)partial^muPhi_2rangle+lambda(hatmathbfn)BoxPhi_2rangle+lambda_munu(hatmathbfn)partial^mupartial^nuPhi_2rangleright\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It is worthnoting acting a primary Phi_2(hatmathbfn) on the vacuum will also produce various descendants in the multiplet.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In the example of Ising CFT, we first use the insertion of a single operator to determine the coefficients lambda_0lambda_epsilonlambda_sigma.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    lambda_0=frac1sqrt4pilangle 0n^x_000ranglequadlambda_epsilon=fracR^Delta_epsilonsqrt4pilangle epsilonn^x_000ranglequadlambda_sigma=fracR^Delta_sigmasqrt4pilangle sigman^z_000rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Take the OPE coefficient f_sigmasigmaepsilon as an example. It can be expressed either as a one point function of sigma or epsilon","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    f_sigmasigmaepsilon=R^Delta_sigmalangleepsilonsigma(hatmathbfn)sigmarangle=fraclangleepsilonn_00^zsigmaranglelangle 0n_00^zsigmarangle+mathscrO(R^-2)\n    =R^Delta_epsilonlanglesigmaepsilon(hatmathbfn)sigmarangle=fraclanglesigman^x_00sigmarangle-langle0n^x_000ranglelangleepsilonn^x_000rangle+mathscrO(R^-(3-Delta_epsilon))\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For the first line, the subleading contribution comes from the contribution of the descendant Boxsigma to n_00^z. As sigma(hatmathbfn) scales as R^-Delta_sigma and Boxsigma(hatmathbfn) as R^-Delta_sigma-2, ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    langleepsilonn_00^zsigmarangle=f_sigmasigmaepsilonlambda_sigma R^-Delta_sigma(1+c_1R^-2+dots)\n    langleepsilonn_00^zsigmarangle=lambda_sigma R^-Delta_sigma(1+c_1R^-2+dots)\n    fraclangleepsilonn_00^zsigmaranglelangle 0n_00^zsigmarangle=\n    f_sigmasigmaepsilon+mathscrO(R^-2)\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here c_1 and c_1 are constant factors that represents the contribution of Boxsigma and does not scale with system size. Hence, the subleading contribution scales as R^-2. For the second line, the subleading contribution comes from the stress tensor T^munu. Similarly, the power of the scaling is the difference of the scaling dimension R^-(Delta_T^munu-Delta_epsilon)=R^-(3-Delta_epsilon).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then proceed to the insertion of two operators. This can help us determine up to a four-point function. Through conformal transformation, any four point function can be expressed in the form of","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    langlePhi_1Phi^mathrm(cyl)_2(hatmathbfntau)Phi^mathrm(cyl)_3(hatmathbfz)Phi_4rangle=frace^Delta_Phi_2tauRR^Delta_Phi_2+Delta_Phi_3langlePhi_1^dagger(infty)Phi_2(mathbfr)Phi_3(hatmathbfz)Phi_4(0)rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the time-displaced operator can be defined as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_2(hatmathbfntau)=e^-HtauPhi_2(hatmathbfn)e^Htau","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"As a sanity check, By taking Phi_1=Phi_4=mathbbI, Phi_2=Phi_3 and tau=0, the two-point function on the unit sphere is recovered ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    langle0Phi^mathrm(cyl)_2(hatmathbfn)Phi^mathrm(cyl)_2(hatmathbfz)0rangle=R^-2Delta_Phi_2langlePhi_2(hatmathbfn)Phi_2(hatmathbfz)rangle=frac1R^2Delta_Phi_2hatmathbfn-hatmathbfz^2Delta_Phi_2=frac1R^2Delta_Phi_2(1-costheta)^Delta_Phi_2","category":"page"},{"location":"intro/#Conformal-generators","page":"Introduction","title":"Conformal generators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"So far, in the conformal group, we know that the rotation and the dilatation is manifest on the fuzzy sphere. The rest, viz. translation and SCT, are emergent. In this section, we consider how to express the generators of these emergent symmetries in terms of the microscopic operators. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A general Noether current and corresponding generator of the infinitesimal spacetime transformation x^mumapsto x^mu+ϵ^μ(x) can be expressed in terms of the stress tensor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    j_epsilon^mu(x)=ϵ^ν(x)T^μ_ν(x) Q_ϵ=int_Sigmamathrmd^d-1xsqrtgj_epsilon^0(x)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Specifically, for the generators P^muK^mu of translation and SCT in the embedded sphere","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    P^mu=intmathrmd^2hatmathbfn(n^mu T^0_0+iT^0mu)quad K^mu=intmathrmd^2hatmathbfn(n^mu T^0_0-iT^0mu)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Hence, the conformal generator Lambda^mu=P^mu+K^mu is the l=1 component of the Hamiltonian density mathscrH=T^0_0","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=P_m+K_m=sqrtfrac4pi3intmathrmd^2mathbfhatnbarY_1m(mathbfhatn)mathscrH(mathbfhatn)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"(Here the indices mu and m are two equivalent way to express the components) By acting it on the the states, the number of derivatives is increased or decreased by 1, e.g., for a primary Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    Lambda^muPhirangle=mathrmconsttimespartial^muPhirangle\n    Lambda^mupartial_muPhirangle=mathrmconsttimesPhirangle+mathrmconsttimespartial^mupartial^nuPhirangle+mathrmconsttimesBoxPhirangle\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The derivation of the expression and the constant factors are calculated and given in Fardelli 2024 and Fan 2024. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then need to find the expression for the Hamiltonian density. For example, for Ising model, it is the local density operator and density-density interactions with some full derivatives","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathscrH(mathbfr)=n_zleft(g_0+g_1nabla^2right)n_z-hn_x+g_D1nabla^2n_x+g_D2nabla^2n_z^2+dots","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where g_Di are undetermined constants that does not affect the Hamiltonian H=intmathrmd^2mathbfrmathscrH. We have only listed a few examples of the allowed full derivatives. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To determine those constants, we consider another strategy by consider all the possible two-fermion and four-fermion operators that are singlet under flavour symmetry and spin-1 under mathrmSO(3). We consider the example of Ising CFT. The two-fermion terms include the density operactors","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n^x_10quadtextrmandquad n^0_10","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Similar to what we have done for Hamiltonian, the four-fermion operators can be obtained by combining the fermion bilinears Delta_lm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    sum_substackl_1l_2m_1m_2tildeU_l_1l_2Delta^dagger_l_1m_1Delta_l_2m_2langle (2s-l_1)(-m_1)(2s-l_2)m_21mrangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For l_1in2mathbbZ, the spin index in the pairing operator is anti-symmetrised ; For l_1in2mathbbZ+1, the spin index in the pairing operator is symmetrised. Therefore, l_1-l_2in2mathbbZ for non-zero results. And since l_1-l_2leq 1, we conclude l_1=l_2. so","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=sum_substacklm_1m_2tildeU_lDelta^dagger_lm_1Delta_lm_2beginpmatrix\n        2s-l2s-l1-m_1m_2m\n    endpmatrix+tildehn^x_1m+tildemun^0_1m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here, tildeU_ltildehtildemu are tuning parameters. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"After obtaining Lambda^mu=P^mu+K^mu, the separate P^mu and K^mu can be obtained by considering the commutator with the dilatation generator D, which is proportional to the Hamiltonian. As DP^mu=P^mu and DK^mu=-K^mu.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    P^mu=tfrac12Lambda^mu+tfrac12DLambda^mu\n    K^mu=tfrac12Lambda^mu-tfrac12DLambda^mu\nendaligned","category":"page"},{"location":"intro/#Numerical-methods","page":"Introduction","title":"Numerical methods","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this section, we briefly review the numerical methods supported in FuzzifiED. The numerical methods that have been applied to fuzzy sphere include exact diagonalisation (ED), density matrix renormalisation group (DMRG) and determinant quantum Monte Carlo (DQMC). Among these ED and DMRG have been implemented in FuzzifiED. ","category":"page"},{"location":"intro/#Exact-diagonalisation-(ED)","page":"Introduction","title":"Exact diagonalisation (ED)","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Exact diagonalisation (ED) might be the most straightforward method to solve a quantum many-body Hamiltonian. In ED, one construct a many-body basis and write down all the elements of the Hamiltonian matrix on these basis. The eigenstates of the Hamiltonian with the lowest energy can be solved without finding the full eigensystem by Arnoldi or Lanczos algorithm. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Briefly speaking, the Arnoldi algorithm is an iterative method. In each iteration, it constructs an orthonormal basis of the Krylov subspace from an initial vector and finds an approximation to the eigenvector in that basis. This approximate eigenvector is then used as the initial vector for the next iteration. An example of Krylov subspace is spanned by acting the matrix H repeatedly on the initial vector irangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathcalK_r(Hirangle)=operatornamespanleftirangleHirangleH^2irangledotsH^n-1irangleright","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The ED calculation can be optimised in several ways. The storage of the Hamiltonian matrix may be compressed by data structure taylored for sparse matrix such as compressed sârse column (CSC). The Hamiltonian matrix is usually block diagonal due to symmetry of the Hamiltonian. The Hilbert space is divided into several sectors that carry different representation under the symmetry, and acting the Hamiltonian on a state in a sector results in a state in the same sector. \\textit{E.g.}, in the ED calculation for the Ising model on the fuzzy sphere, the symmetries we can use include two mathrmU(1) symmetries, \\textit{viz.} the conservation of particle number and the angular momentum in the z-direction, and three mathbbZ_2 symmetries, \\textit{viz.} the Ising mathbbZ_2 flavour symmetry, the particle-hole symmetry and the pi-rotation along the y-axis\\footnote{So far, FuzzifiED only supports mathrmU(1) and mathbbZ_p symmetries. We are still trying to implement non-abelian symmetries.}.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The ED method enjoy several advantages, including (1) the full knowledge of the eigenstate wavefunction and (2) the ability to access relatively high excited states. However, despite these optimisations, the dimension of the Hilbert space scales exponentially with the number of orbitals. This results in exponentially growing space and time complexity. \\textit{E.g.}, for the Ising model on the fuzzy sphere, for N_m=12, the dimension of Hilbert space dimmathcalH=16times10^4 and the number of elements in the Hamiltonian is N_ mathrmel=65times 10^5~; for N_m=14, the number have already grown to dimmathcalH=18times10^5 and N_textrmel=11times 10^7, which translates to a memory demand of 02 gigabytes. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In FuzzifiED, we use the celebrated Fortran library Arpack to perform the Arnoldi algorithm. ","category":"page"},{"location":"intro/#Density-matrix-renormalisation-group-(DMRG)","page":"Introduction","title":"Density matrix renormalisation group (DMRG)","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To overcome the size limit of ED, density matrix renormalisation group (DMRG) is a powerful method calculating the ground state of a quasi-one-dimensional system. It has been first first invented by S. R. White as an improvement to the numerical renormalisation group (NRG) used in the Kondo problem. Since its proposal, it has been proven powerful in various problems in condensed matter physics, such as the static and dynamic properties of one-dimensional models such as the Heisenberg, t–-J and Hubbard models. Later, Schollw\\\"ock has discovered a new point of view that implements the DMRG in the language of matrix product states (MPS). ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Briefly speaking, in this language, DMRG is a variational method that optimises the fidelity between the exact ground state and the variational MPS. To find the lowest excited state, one need to add projection 0ranglelangle 0 of the ground state 0rangle to the Hamiltonian by hand. Due to the complexity of this process, the higher excited state are difficult to access.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Although the fuzzy sphere deals with (2+1)-dimensional quantum systems, the basis of lowest Landau level provides a natural way to express it as a quasi-1d problem. Therefore, DMRG has been a powerful numerical method for fuzzy sphere. However, like other (2+1)d models, the DMRG on fuzzy sphere also suffers from the divergence of the required maximal bond dimension with system size. One should thus be careful with checking the convergence of the results when doing DMRG. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In FuzzifiED, we use the ITensor Package in Julia to perform the DMRG calculations. ","category":"page"},{"location":"models/#Built-in-models","page":"Built-in models","title":"Built-in models","text":"","category":"section"},{"location":"models/#Diagonal-quantum-numbers-on-fuzzy-sphere","page":"Built-in models","title":"Diagonal quantum numbers on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following diagonal quantum numbers (symmetry charges) on fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetNeQNDiag(no :: Int64)\nGetLz2QNDiag(nm :: Int64, nf :: Int64)\nGetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Union{Dict{Int64, Int64}, Vector{Int64}}, id :: Int64 = 1, modul :: Int64 = 1)\nGetZnfChargeQNDiag(nm :: Int64, nf :: Int64)\nGetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}, id :: Int64 = 1) ","category":"page"},{"location":"models/#FuzzifiED.GetNeQNDiag-Tuple{Int64}","page":"Built-in models","title":"FuzzifiED.GetNeQNDiag","text":"GetNeQNDiag(no :: Int64) :: QNDiag\n\nReturn the QNDiag of the number of electrons, implemented as \n\nQNDiag(\"Ne\", fill(1, no))\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetLz2QNDiag-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetLz2QNDiag","text":"GetLz2QNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of twice the angular momentum 2L_z, implemented as \n\nQNDiag(\"Lz\", collect(0 : nm * nf - 1) .÷ nf .* 2 .- (nm - 1))\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetFlavQNDiag","page":"Built-in models","title":"FuzzifiED.GetFlavQNDiag","text":"GetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Dict{Int64, Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag \nGetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Vector{Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of linear combination of number of electrons in each flavour, \n\n    Q = _fq_fn_f\n\nthe factor q_f can either be given by a length-N_f vector or a dictionary containing non-zero terms. E.g., for Q=n_f=1-n_f=3 in a 4-flavour system, qf = [1, 0, -1, 0] or qf = Dict(1 => 1, 3 => -3). id is an index to be put in the name to distinguish. For qf given as vector, the function is implemented as \n\nQNDiag(\"Sz$id\", qf[collect(0 : nm * nf - 1) .% nf .+ 1], modul)\n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetZnfChargeQNDiag-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetZnfChargeQNDiag","text":"GetZnfChargeQNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of a ℤ_N_f-charge, \n\n    Q = _f=0^N_f-1fn_fmod N_f\n\nimplemented as \n\nQNDiag(\"Q_Z$nf\", collect(0 : nm * nf - 1) .% nf, nf)\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPinOrbQNDiag","page":"Built-in models","title":"FuzzifiED.GetPinOrbQNDiag","text":"GetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}[, id :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of the number of electrons in the subset of sites pin_o, implemented as\n\nQNDiag(\"Npin$i\", [ o in pin_o ? 1 : 0 for o = 1 : no])\n\nThis QNDiag is useful in pinning defects, where certain subset of sites need to be set empty or filled. To empty the sites, set this QNDiag to 0 ; to fill the sites, set this QNDiag to length(pin_o). id is an index to be put in the name to distinguish. \n\n\n\n\n\n","category":"function"},{"location":"models/#Off-diagonal-quantum-numbers-on-fuzzy-sphere","page":"Built-in models","title":"Off-diagonal quantum numbers on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following off-diagonal quantum numbers (transformations) on fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetParityQNOffd(nm :: Int64, nf :: Int64, permf :: Union{Dict{Int64, Int64}, Vector{Vector{Int64}}, Vector{Int64}} = Dict{Int64, Int64}(), fac :: Union{Dict{Int64, <: Number}, Vector{<: Number}} = Dict{Int64, ComplexF64}()) \nGetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf :: Union{Dict{Int64, Int64}, Vector{Vector{Int64}}, Vector{Int64}}, fac :: Union{Dict{Int64, <: Number}, Vector{<: Number}} = Dict{Int64, ComplexF64}())\nGetRotyQNOffd(nm :: Int64, nf :: Int64)","category":"page"},{"location":"models/#FuzzifiED.GetParityQNOffd","page":"Built-in models","title":"FuzzifiED.GetParityQNOffd","text":"GetParityQNOffd(nm :: Int64, nf :: Int64[, permf, fac])\n\nReturn the particle-hole transformation \n\n    𝒫 c^_mfα_fc_mπ_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation π_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor α_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetFlavPermQNOffd","page":"Built-in models","title":"FuzzifiED.GetFlavPermQNOffd","text":"GetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf, fac][, cyc :: Int64])\n\nReturn the flavour permutaiton transformation \n\n    𝒵 c^_mfα_fc^_mπ_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation π_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor α_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \ncyc :: Int64 is the period of the permutation. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetRotyQNOffd-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetRotyQNOffd","text":"GetRotyQNOffd(nm :: Int64, nf :: Int64)\n\nReturn the π-rotation with respect to the y-axis. \n\n    ℛ_y c^_mf(-)^m+sc^_-mf\n\n\n\n\n\n","category":"method"},{"location":"models/#Operators-on-fuzzy-sphere","page":"Built-in models","title":"Operators on fuzzy sphere","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{<:Number})\nGetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number} = Matrix{Float64}(I, nf, nf), mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mats_a :: Vector{<:AbstractMatrix{<:Number}}, mats_b :: Vector{<:AbstractMatrix{<:Number}} = [Matrix(mat_a') for mat_a in mats_a])\nGetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}, mat_b :: Matrix{<:Number} = Matrix(mat_a'))\nGetPolTerms(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetL2Terms(nm :: Int64, nf :: Int64)\nGetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{<:AbstractMatrix{<:Number}})","category":"page"},{"location":"models/#FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetIntMatrix","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{<:Number}) :: Array{ComplexF64, 3}\n\nArgument\n\nnm :: Int64 is the number of orbitals.\nps_pot :: Vector{<:Number} is the vector of non-zero pseudopotentials.\n\nOutput\n\nA nm*nm*nm array giving the interaction matrix U_m_1m_2m_3-m_1-m_2-m_3.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDenIntTerms","page":"Built-in models","title":"FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64[, ps_pot :: Vector{<:Number}][, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the normal-ordered density-density term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default. \nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetDenIntTerms-2","page":"Built-in models","title":"FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Vector{<:AbstractMatrix{<:Number}}[, mat_b :: Vector{<:AbstractMatrix{<:Number}}][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the sum of a series of normal-ordered density-density term in the Hamiltonian \n\n_m_if_iαU_m_1m_2m_3m_4(M^A_α)_f_1f_4(M^B_α)_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default.\nmat_a :: Vector{<:AbstractMatrix{<:Number}} is a vector of nf*nf matrix specifying (M^A_α)_ff. Facultative, I_N_f by default. \nmat_b :: Vector{<:AbstractMatrix{<:Number}} is a vector of nf*nf matrix specifying (M^B_α)_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetPairIntTerms","page":"Built-in models","title":"FuzzifiED.GetPairIntTerms","text":"GetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_3f_4c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nf*nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nf*nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetPolTerms-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetPolTerms","text":"GetPolTerms(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; fld_m :: Vector{<:Number}]) :: Terms\n\nReturn the polarisation term in the Hamiltonian \n\n_mffc^_mfM_ffc_mf\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours. \nmat :: Matrix{<:Number} is a nf*nf matrix specifying M_ff. Facultative, I_N_f by default. \nfld_m :: Vector{<:Number} gives an orbital dependent polarisation\n\n_mffh_mc^_mfM_ffc_mf\n\nFacultative. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetL2Terms-Tuple{Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetL2Terms","text":"GetL2Terms(nm :: Int64, nf :: Int64) :: Terms\n\nReturn the terms for the total angular momentum.\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetC2Terms-Tuple{Int64, Int64, Vector{<:AbstractMatrix{<:Number}}}","page":"Built-in models","title":"FuzzifiED.GetC2Terms","text":"GetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{Matrix{<:Number}}[, mat_tr :: Vector{Matrix{<:Number}}]) :: Terms\n\nReturn the terms for the quadratic Casimir of the flavour symmetry.\n\n    C_2=_immfrac(c^_mf_1G_if_1f_2c_mf_2)(c^_mf_3G^_if_3f_4c_mf_4)operatornametrG_i^G_i-_immfrac(c^_mf_1T_if_1f_2c_mf_2)(c^_mf_3T^_if_3f_4c_mf_4)operatornametrT_i^T_i\n\nwhere G_i are the generator matrices, and T_i are the trace matrices. \n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nmat_gen :: Vector{Matrix{Number}}) is a list of the matrices that gives the generators. It will automatically be normalised such that its square traces to unity. \nmat_tr :: Vector{Matrix{Number}}) is a list of trace matrices that will be normalised automatically and substracted. Facultative.\n\n\n\n\n\n","category":"method"},{"location":"models/#Spherical-observables","page":"Built-in models","title":"Spherical observables","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"FuzzifiED supports local observables on sphere that can be decomposed into angular components Phi(Omega)=sum_lmPhi_lmY^(s)_lm","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"SphereObs","category":"page"},{"location":"models/#FuzzifiED.SphereObs","page":"Built-in models","title":"FuzzifiED.SphereObs","text":"SphereObs\n\nThe mutable type SphereObs stores the information of a local observable (or local operator) Phi that can be decomposed into angular components.\n\n    Phi(Omega)=_lmPhi_lmY^(s)_lm\n\nFields\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the observable is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)\nSphereObs(s2 :: Int64, l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Terms})","category":"page"},{"location":"models/#FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}","page":"Built-in models","title":"FuzzifiED.SphereObs","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and the function (lm)Phi_lm.\n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in models","title":"FuzzifiED.SphereObs","text":"SphereObs(s2 :: Int64, l2m :: Int64, comps :: Dict{Tuple{Int64, Int64}, Terms}) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"StoreComps!(obs :: SphereObs)\nStoreComps(obs :: SphereObs)","category":"page"},{"location":"models/#FuzzifiED.StoreComps!-Tuple{SphereObs}","page":"Built-in models","title":"FuzzifiED.StoreComps!","text":"StoreComps!(obs :: SphereObs)\n\ncalculates and stores each component of the observable obs and replace the function in obs by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.StoreComps-Tuple{SphereObs}","page":"Built-in models","title":"FuzzifiED.StoreComps","text":"StoreComps(obs :: SphereObs) :: SphereObs\n\ncalculates and stores each component of the observable obs and return a new observable with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The multiplication, addition, conjugate and Laplacian operation of an observable is supported ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"*(fac :: Number, obs :: SphereObs) \n+(obs1 :: SphereObs, obs2 :: SphereObs) \nadjoint(obs :: SphereObs)\n*(obs1 :: SphereObs, obs2 :: SphereObs)\nLaplacian(obs :: SphereObs)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, SphereObs}","page":"Built-in models","title":"Base.:*","text":"*(fac :: Number, obs :: SphereObs) :: SphereObs\n*(obs :: SphereObs, fac :: Number) :: SphereObs\n/(obs :: SphereObs, fac :: Number) :: SphereObs\n-(obs :: SphereObs) :: SphereObs\n\nenables the multiplication of an observable with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{SphereObs, SphereObs}","page":"Built-in models","title":"Base.:+","text":"+(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n-(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the addition of two observables.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{SphereObs}","page":"Built-in models","title":"Base.adjoint","text":"adjoint(obs :: SphereObs) :: SphereObs\n\nenables the Hermitian conjugate of a spherical observable.\n\nbeginaligned\n    Φ^(Ω)=_lm(Φ_lm)^barY^(s)_lm(Ω)=_lm(Φ_lm)^(-1)^s+mY^(-s)_l-m(Ω)\n    (Φ^)_lm=(-1)^s-m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{SphereObs, SphereObs}","page":"Built-in models","title":"Base.:*","text":"*(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the multiplication of two observable by making use of the composition of two monopole harmonics into one. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.Laplacian-Tuple{SphereObs}","page":"Built-in models","title":"FuzzifiED.Laplacian","text":"Laplacian(obs :: SphereObs) :: SphereObs\n\nTakes the Laplacian of an observable\n\n    (^2Φ)_lm=-l(l+1)Φ_lm\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The observables can be evaluated either at an angular component or at a real-space point.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number)\nGetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64)","category":"page"},{"location":"models/#FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}","page":"Built-in models","title":"FuzzifiED.GetComponent","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number) :: Terms\n\nreturns an angular component Φ_lm of an observable in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}","page":"Built-in models","title":"FuzzifiED.GetPointValue","text":"GetPointValue(obs :: SphereObs, θ :: Float64, ϕ :: Float64) :: Terms\n\nevaluates an observable at one point Φ(θϕ) in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetElectronObs(nm :: Int64, nf :: Int64, f :: Int64)\nGetDensityObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetPairingObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})","category":"page"},{"location":"models/#FuzzifiED.GetElectronObs-Tuple{Int64, Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetElectronObs","text":"GetElectronObs(nm :: Int64, nf :: Int64, f :: Int64) :: SphereObs\n\nreturns the electron annihilation operator ψ_f.\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the flavour to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDensityObs-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetDensityObs","text":"GetDensityObs(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}]) :: SphereObs\n\nreturns the density operator n=_ffψ^_fM_ffψ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPairingObs-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetPairingObs","text":"GetPairingObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SphereObs\n\nreturns the pair operator Δ=_ffψ_fM_ffψ_f.\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\n\n\n\n\n\n","category":"method"},{"location":"models/#Angular-modes","page":"Built-in models","title":"Angular modes","text":"","category":"section"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"An angular modes object is similar to spherical observables except that it superposes in the rule of Clebsch-Gordan coefficients and does not have the notion of locality.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"AngModes","category":"page"},{"location":"models/#FuzzifiED.AngModes","page":"Built-in models","title":"FuzzifiED.AngModes","text":"AngModes\n\nThe mutable type AngModes stores angular momentum components of an operator on the sphere Φ_lm and superposes in the rule of Clebsch-Gordan coefficients. The usage is similar to the spherical observables, except that SphereObs superposes in the rule of spherical harmonics and has the notion of locality\n\nFields\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the modes object is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"AngModes(l2m :: Int64, get_comp :: Function)\nAngModes(l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, Terms})","category":"page"},{"location":"models/#FuzzifiED.AngModes-Tuple{Int64, Function}","page":"Built-in models","title":"FuzzifiED.AngModes","text":"AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2l_max and the function (lm)Phi_lm\n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.AngModes-Tuple{Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in models","title":"FuzzifiED.AngModes","text":"AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"StoreComps!(amd :: AngModes)\nStoreComps(amd :: AngModes)","category":"page"},{"location":"models/#FuzzifiED.StoreComps!-Tuple{AngModes}","page":"Built-in models","title":"FuzzifiED.StoreComps!","text":"StoreComps!(amd :: AngModes)\n\ncalculates and stores each component of the modes object amd and replace the function in amd by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.StoreComps-Tuple{AngModes}","page":"Built-in models","title":"FuzzifiED.StoreComps","text":"StoreComps(amd :: AngModes) :: AngModes\n\ncalculates and stores each component of the modes object amd and return a new modes object with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"The multiplication, addition and conjugate of an observable is supported ","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"*(fac :: Number, amd :: AngModes) \n+(obs1 :: AngModes, obs2 :: AngModes) \nadjoint(amd :: AngModes)\n*(obs1 :: AngModes, obs2 :: AngModes)","category":"page"},{"location":"models/#Base.:*-Tuple{Number, AngModes}","page":"Built-in models","title":"Base.:*","text":"*(fac :: Number, amd :: AngModes) :: AngModes\n*(amd :: AngModes, fac :: Number) :: AngModes\n/(amd :: AngModes, fac :: Number) :: AngModes\n-(amd :: AngModes) :: AngModes\n\nenables the multiplication of a mode with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{AngModes, AngModes}","page":"Built-in models","title":"Base.:+","text":"+(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n-(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n\nenables the addition of two modes.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{AngModes}","page":"Built-in models","title":"Base.adjoint","text":"adjoint(amd :: AngModes) :: AngModes\n\nenables the Hermitian conjugate of a spherical mode.\n\nbeginaligned\n    (Φ^)_lm=(-1)^l+m(Φ_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{AngModes, AngModes}","page":"Built-in models","title":"Base.:*","text":"*(obs1 :: AngModes, obs2 :: AngModes) :: AngModes\n\nenables the multiplication of two modes in the rule of CG coefficients. \n\n    Φ_lm=_l_1l_2m_1m_2δ_mm_1+m_2l_1m_1l_2m_2lmΦ_l_1m_1Φ_l_2m_2\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"One can take out either one or a set of components","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetComponent(amd :: AngModes, l :: Number, m :: Number)\nFilterL2(amd :: AngModes, l :: Number) \nFilterComponent(amd :: AngModes, flt) ","category":"page"},{"location":"models/#FuzzifiED.GetComponent-Tuple{AngModes, Number, Number}","page":"Built-in models","title":"FuzzifiED.GetComponent","text":"GetComponent(amd :: AngModes, l :: Number, m :: Number) :: Terms\n\nreturns an angular component Φ_lm of a modes object in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterL2-Tuple{AngModes, Number}","page":"Built-in models","title":"FuzzifiED.FilterL2","text":"FilterL2(amd :: AngModes, l :: Number) :: AngModes\n\nreturns an angular modes object with modes of a certain total angular momentum filtered out.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterComponent-Tuple{AngModes, Any}","page":"Built-in models","title":"FuzzifiED.FilterComponent","text":"FilterComponent(amd :: AngModes, flt) :: AngModes\n\nreturns an angular modes object with certain modes filtered out.\n\nArguments\n\namd :: AngModes is the original angular modes\nflt is the filter function whose input is the pair (lm) and output is a logical that indicates whether this mode is chosen. E.g., if one wants to filter out the modes with angular momentum l0, one should put (l, m) -> l == l0.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/","page":"Built-in models","title":"Built-in models","text":"GetElectronMod(nm :: Int64, nf :: Int64, f :: Int64)\nGetPairingMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})\nGetDensityMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number})","category":"page"},{"location":"models/#FuzzifiED.GetElectronMod-Tuple{Int64, Int64, Int64}","page":"Built-in models","title":"FuzzifiED.GetElectronMod","text":"GetElectronMod(nm :: Int64, nf :: Int64, f :: Int64) :: AngModes\n\nreturns the modes of electron annihilation operator c_m, with angular momentum s=(N_m-1)2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the flavour to be taken.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPairingMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetPairingMod","text":"GetPairingMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: AngModes\n\nreturns the modes of two electrons superposed in the rule of CG coefficients. \n\n    Δ_lm=_m_1m_2δ_mm_1+m_2sm_1sm_2lmc_am_1M_abc_bm_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDensityMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in models","title":"FuzzifiED.GetDensityMod","text":"GetDensityMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: AngModes\n\nreturns the modes of electron creation and annihilation superposed in the rule of CG coefficients. \n\n    n_lm=_m_1m_2δ_m-m_1+m_2(-1)^s+m_1s(-m_1)sm_2lmc^_m_1c_m_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix mathbbI by default.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Fuzzifino","page":"Fuzzifino","title":"Fuzzifino","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"Fuzzifino is a module for exact diagonalisation (ED) calculation on the fuzzy sphere for systems with both bosons and fermions. The usage is similar to FuzzifiED, with new types SQNDiag, SQNOffd, SConf, SBasis, STerm and SOperator defined. To use the module, include also at the start of your Julia script","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"using FuzzifiED.Fuzzifino","category":"page"},{"location":"fuzzifino/#Environment-parameter","page":"Fuzzifino","title":"Environment parameter","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"FuzzifiED.Fuzzifino.Libpathino","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.Libpathino","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.Libpathino","text":"FuzzifiED.Fuzzifino.Libpathino :: String = FuzzifiED_jll.LibpathFuzzifino\n\ndefine path of the Fortran library libfuzzifino.so. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"fuzzifino/#Quantum-numbers","page":"Fuzzifino","title":"Quantum numbers","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The diagonal and off-diagonal quantum numbers are implemented as","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SQNDiag\nSQNOffd","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNDiag","text":"SQNDiag\n\nThe mutable type SQNDiag records the information of a diagonal mathrmU(1) or ℤ_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_ofq_fon_fo+_o=1^N_obq_bon_bo\n\nor\n\nQ=_o=1^N_ofq_fon_fo+_o=1^N_obq_bon_bo mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of site, N_of and N_ob are the number of fermionic and bosonic sites, n_fo=f^_of_o, n_bo=b^_ob_o, and q_foq_bo are a set of symmetry charges that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number \nchargef :: Vector{Int64} is the symmetry charge q_fo of each site\nchargeb :: Vector{Int64} is the symmetry charge q_bo of each site\nmodul :: Vector{Int64} is the modulus p, set to 1 for mathrmU(1) SQNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nSQNDiag([name :: String, ]chargef :: Vector{Int64}, chargeb :: Vector{Int64}[, modul :: Int64]) :: SQNDiag\n\nThe arguments name and modul are facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNOffd","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNOffd","text":"SQNOffd\n\nThe mutable type SQNOffd records the information of an off-diagonal ℤ_p quantum number in the form of a discrete transformation\n\n𝒵 f_o α_fo^* f^(p_fo)_π_fo  f_o^α_fo c^(1-p_fo)_π_fo  b_o^α_bo b^_π_bo\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, π_foπ_bo are permutations of 1N_of or N_ob, α_foα_bo are coefficients, and p_fo specified whether or not particle-hole transformation is performed for the fermionic site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\npermf :: Vector{Int64} is a length-N_of vector that records the fermion permutation π_fo.\npermb :: Vector{Int64} is a length-N_ob vector that records the boson permutation π_bo.\nphf :: Vector{Int64} is a length-N_of vector that records p_fo to determine whether or not to perform a particle-hole transformation\nfacf :: Vector{ComplexF64} is a length-N_of vector that records the factor α_fo in the transformation.\nfacb :: Vector{ComplexF64} is a length-N_ob vector that records the factor α_bo in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nSQNOffd(permf :: Vector{Int64}, permb :: Vector{Int64}[, phf :: Vector{Int64}][, facf :: Vector{ComplexF64}, facb :: Vector{ComplexF64}][, cyc :: Int64]) :: SQNOffd\nSQNOffd(permf :: Vector{Int64}, permb :: Vector{Int64}, phf_q :: Bool[, fac :: Vector{ComplexF64}, facb :: Vector{ComplexF64}]) :: SQNOffd\n\nThe arguments phf, facf, facb and cyc are facultative. By default ph is set all 0, facf, facb is set to all 1 and cyc is set to 2. If phf_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#Configurations","page":"Fuzzifino","title":"Configurations","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SConfs","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SConfs","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SConfs","text":"SConfs\n\nThe mutable type SConfs stores all the configurations that respects the diagonal quantum numbers (SQNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nnof :: Int64 is the number of fermionic sites.\nnof :: Int64 is the number of bosonic sites.\nnebm :: Int64 is the maximal number of boson occupation.\nncf :: Int64 is the number of configurations.\nconff :: Vector{Int64} is an array of length ncf containing all the fermion configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \nconfb :: Vector{Int64} is an array of length ncf containing all the boson configurations. Each configuration is expressed in a binary number that has N_bo 1's and N_eb 0's and the number of 0's following each 1 records the number of bosons in that site. \nnorf :: Int64, nobf :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated from the QNDiags.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SConfs(nof :: Int64, nob :: Int64, nebm :: Int64, secd :: Vector{Int64}, qnd :: Vector{SQNDiag} ; num_th :: Int64 = NumThreads, disp_std :: Bool = !SilentStd)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SConfs-Tuple{Int64, Int64, Int64, Vector{Int64}, Vector{SQNDiag}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SConfs","text":"SConfs(nof :: Int64, nob :: Int64, nebm :: Int64, secd :: Vector{Int64}, qnd :: Vector{SQNDiag} ; , num_th :: Int64, disp_std :: Bool) :: Confs\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nnof :: Int64 is the number of fermionic sites N_of.\nnob :: Int64 is the number of bosonic sites N_ob.\nnebm :: Int64 is the maximal number of total bosons.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{SQNDiag} is the set of SQNDiags.\nnorf :: Int64 and norb :: Int64 are the number of less significant bits used to generate the Lin table. Facultative, N_of2 and N_ob2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: SConfs is a SConfs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the total number of particles (i.e., bosons plus fermions).\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Basis","page":"Fuzzifino","title":"Basis","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SBasis","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis\n\nThe mutable type SBasis stores the information of the SBasis that respects both diagonal and off-diagonal quantum numbers. The states in the SBasis is in the form \n\nI=λ_i_I1i_I1+λ_i_I2i_I2++λ_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i.e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: SConfs stores the configurations that respect the QNDiags.\ndim :: Int64 is the dimension of the SBasis.\nszz :: Int64 records the maximum size max m_g of groups.\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to.\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients λ_i of each configuration.\ngrel :: Matrix{Int64} is a szz*dim matrix that records the configurations in each group i_Ik (k = 1m_I)\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated by the following methods.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SBasis(cfs :: SConfs, secf :: Vector{<:Number}, qnf :: Vector{SQNOffd} ; num_th = NumThreads, disp_std = !SilentStd)\nSBasis(cfs :: SConfs)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis-Tuple{SConfs, Vector{<:Number}, Vector{SQNOffd}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis(cfs :: SConfs, secf :: Vector{ComplexF64}, qnf :: Vector{SQNOffd} ; num_th :: Int64, disp_std :: Bool)\n\ngenerates the SBasis that respects the off-diagonal ℤ_p quantum numbers (secfQNOffd)\n\nArguments\n\ncfs :: SConfs is the diagonal QN–preserving configurations.\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector.\nqnf :: Vector{SQNOffd} is a vector of off-diagonal quantum numbers.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: SBasis is the resulting SBasis object.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis-Tuple{SConfs}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis(cfs :: SConfs)\n\nGenerate a SBasis from the configurations without off-diagonal ℤ_n symmetries.\n\nArguments\n\ncfs :: SConfs is the diagonal QN–preserving configurations.\n\nOutput\n\nbs :: SBasis is the resulting SBasis object.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Term","page":"Fuzzifino","title":"Term","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"STerm\nSTerms","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STerm","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STerm","text":"STerm\n\nThe mutable type STerm records a STerm that looks like Ua^(p_1)_o_1a^(p_2)_o_2 a^(p_l)_o_l in an operator, where positive o denotes fermions and negative o denotes bosons\n\n    a^(0)_o=f_o a^(1)_o=f_o^ a^(0)_-o=b_o a^(1)_-o=b_o^\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string\n\nMethod\n\nIt can be generated by the function\n\nSTerm(coeff :: ComplexF64, cstr :: Vector{Int64}) :: ComplexF64\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STerms","text":"STerms is an alias for Vector{STerm} for convenience\n\nInitialisation\n\nSTerms(coeff :: Number, cstr :: Vector{Int64})\n\nGives a STerms with a single STerm.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"*(fac :: Number, tms :: STerms)\n+(tms1 :: STerms, tms2 :: STerms)\n*(tms1 :: STerms, tms2 :: STerms)\nadjoint(tms :: STerms)","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{Number, Vector{STerm}}","page":"Fuzzifino","title":"Base.:*","text":"*(fac :: Number, tms :: STerms) :: STerms\n-(tms :: STerms) :: STerms\n*(tms :: STerms, fac :: Number) :: STerms\n/(tms :: STerms, fac :: Number) :: STerms\n\nReturn the product of a collection of STerms with a number. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:+-Tuple{Vector{STerm}, Vector{STerm}}","page":"Fuzzifino","title":"Base.:+","text":"+(tms1 :: STerms, tms2 :: STerms) :: STerms\n-(tms1 :: STerms, tms2 :: STerms) :: STerms\n\nReturn the naive sum of two series of STerms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{Vector{STerm}, Vector{STerm}}","page":"Fuzzifino","title":"Base.:*","text":"*(tms1 :: STerms, tms2 :: STerms) :: STerms\n^(tms :: STerms, pow :: Int64) :: STerms\n\nReturn the naive product of two series of STerms or the power of one STerms. The number of STerms equals the product of the number of STerms in tms1 and tms2. For each STerm in tms1 Ua^(p_1)_o_1 and tms2 Ua^(p_1)_o_1, a new STerm is formed by taking UUa^(p_1)_o_1 a^(p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.adjoint-Tuple{Vector{STerm}}","page":"Fuzzifino","title":"Base.adjoint","text":"adjoint(tm :: STerm) :: STerm\nadjoint(tms :: STerms) :: STerms\n\nReturn the Hermitian conjugate of a series of STerms. For each STerm Ua^(p_1)_o_1a^(p_2)_o_2 a^(p_l)_o_l, the adjoint is barUa^(1-p_l)_o_l a^(1-p_2)_o_2a^(1-p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The terms can be simplified by ","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"NormalOrder(tm :: STerm)\nSimplifyTerms(tms :: STerms)","category":"page"},{"location":"fuzzifino/#FuzzifiED.NormalOrder-Tuple{STerm}","page":"Fuzzifino","title":"FuzzifiED.NormalOrder","text":"NormalOrder(tm :: STerm) :: STerms\n\nrearrange a STerm such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe site index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of STerms whose result is equal to the original STerm. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.SimplifyTerms-Tuple{Vector{STerm}}","page":"Fuzzifino","title":"FuzzifiED.SimplifyTerms","text":"SimplifyTerms(tms :: STerms ; cutoff :: Float64 = eps(Float64)) :: STerms\n\nsimplifies the sum of STerms such that \n\neach STerm is normal ordered,\nlike STerms are combined, and STerms with zero coefficients are removed.\n\nArgument\n\ncutoff :: Float64 is the cutoff such that STerms with smaller absolute value of coefficients will be neglected. Facultative, eps(Float64) by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Operator","page":"Fuzzifino","title":"Operator","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SOperator","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SOperator","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SOperator","text":"SOperator\n\nThe mutable type SOperator records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0.\nntm :: Int64 is the number of terms.\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated by the following methods.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"SOperator(bsd :: SBasis, bsf :: SBasis, terms :: STerms ; red_q :: Int64 = 0, sym_q :: Int64 = 0)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SOperator-Tuple{SBasis, SBasis, Vector{STerm}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SOperator","text":"SOperator(bsd :: SBasis[, bsf :: SBasis], terms :: STerms ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool) :: SOperator\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: STerms records the terms.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"*(op :: SOperator, st_d :: Vector{ComplexF64} ; num_th = NumThreads, disp_std = !SilentStd)\n*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: SOperator, st_d :: Vector{ComplexF64} ; num_th = NumThreads, disp_std = !SilentStd)","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{SOperator, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(op :: SOperator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\n*(op :: SOperator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, SOperator, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: SOperator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: SOperator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Sparse-matrix","page":"Fuzzifino","title":"Sparse matrix","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The OpMat can be generated from SOperator by the following methods.","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"OpMat(op :: SOperator)","category":"page"},{"location":"fuzzifino/#FuzzifiED.OpMat-Tuple{SOperator}","page":"Fuzzifino","title":"FuzzifiED.OpMat","text":"OpMat[{type}](op :: SOperator ; num_th :: Int64, disp_std :: Bool) :: OpMat{type}\n\nGenerates the sparse matrix from the operator. The parameter type is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: SOperator is the operator.\ntype :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"After the generation of sparse matrix, the diagonalisation can be condicted with FuzzifiED. ","category":"page"},{"location":"fuzzifino/#Entanglement","page":"Fuzzifino","title":"Entanglement","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"StateDecompMat(st::Vector{<:Number}, bs0::SBasis, bsa::SBasis, bsb::SBasis, amp_ofa::Vector{<:Number}, amp_oba::Vector{<:Number}, amp_ofb::Vector{<:Number}, amp_obb::Vector{<:Number})\nGetEntSpec(st::Vector{<:Number}, bs0::SBasis, secd_lst::Vector{Vector{Vector{Int64}}}, secf_lst::Union{Vector{Vector{Vector{ComplexF64}}}, Vector{Vector{Vector{Float64}}}, Vector{Vector{Vector{Int64}}}}; qnd_a, qnd_b, qnf_a, qnf_b, amp_ofa, amp_oba, amp_ofb, amp_obb, disp_std)","category":"page"},{"location":"fuzzifino/#FuzzifiED.StateDecompMat-Tuple{Vector{<:Number}, SBasis, SBasis, SBasis, Vector{<:Number}, Vector{<:Number}, Vector{<:Number}, Vector{<:Number}}","page":"Fuzzifino","title":"FuzzifiED.StateDecompMat","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: SBasis, bsa :: SBasis, bsb :: SBasis, amp_ofa :: Vector{<:Number}, amp_oba :: Vector{<:Number}, amp_ofb :: Vector{<:Number}, amp_obb :: Vector{<:Number}) :: Matrix{ComplexF64}\n\nDecompose a state ψ=v_II into a direct-product basis of two subsystems ψ=M_JII_AJ_B\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: SBasis is the total basis. \nbsa :: SBasis is the basis for the subsystem A.\nbsb :: SBasis is the basis for the subsystem B. \namp_ofa :: Vector{ComplexF64} is a complex list of length no that specifies the fermionic amplitute of each orbital in the subsystem A. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \namp_oba :: Vector{ComplexF64} is a complex list of length no that specifies the bosonic amplitute of each orbital in the subsystem A. \namp_ofb :: Vector{ComplexF64} is a complex list of length no that specifies the fermionic amplitute of each orbital in the subsystem B. \namp_obb :: Vector{ComplexF64} is a complex list of length no that specifies the bosonic amplitute of each orbital in the subsystem B. \n\nOutput\n\nA complex matrix of dimension bsb.dim * bsa.dim that corresponds to the state in the decomposed basis ψ=M_JII_AJ_B. This is equivalent to R_μν^Ap in PRB 85, 125308 (2012). After calculating all the sectors, the reduced density matrix will be ρ_B=mathbfMmathbfM^.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, SBasis, Vector{Vector{Vector{Int64}}}, Union{Vector{Vector{Vector{ComplexF64}}}, Vector{Vector{Vector{Float64}}}, Vector{Vector{Vector{Int64}}}}}","page":"Fuzzifino","title":"FuzzifiED.GetEntSpec","text":"GetEntSpec(st :: Vector{<:Number}, bs0 :: SBasis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{SQNDiag}, qnd_b :: Vector{SQNDiag} = qnd_a, qnf_a :: Vector{SQNOffd}, qnf_b :: Vector{SQNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{secd_a, secf_a, secd_b, secf_b}, Vector{Float64}}\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: SBasis is the total basis. \nsecd_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNDiag sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nsecf_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNOffd sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nqnd_a :: Vector{SQNDiag}, qnd_b :: Vector{SQNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} specifies the diagonal and off-diagonal quantum numbers of the subsystems A and B. qnd_b and qnf_b are facultative and the same as qnd_a and qnf_a by default. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to ℱ_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries secd_a, secf_a, secd_b, secf_b and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Transformation","page":"Fuzzifino","title":"Transformation","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"STransf\nSTransf(bsd :: SBasis, bsf :: SBasis, qnf :: SQNOffd)\n*(trs :: STransf, st_d :: Vector{ComplexF64} ; num_th = NumThreads)","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STransf","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STransf","text":"STransf\n\nThe mutable type STransf records a transformation in the same form as a SQNOffd\n\n𝒵 c_o α_o^* c^(p_o)_π_o  c_o^ α_o c^(1-p_o)_π_o\n\ntogether with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state.\npermf :: Vector{Int64}, permb :: Vector{Int64},phf :: Vector{Int64}andfacf :: Vector{ComplexF64},facb :: Vector{ComplexF64}` records the transformation in the same form as a SQNOffd.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STransf-Tuple{SBasis, SBasis, SQNOffd}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STransf","text":"STransf(bsd :: SBasis, bsf :: SBasis, qnf :: SQNOffd)\n\ngenerates a transformation object from a SQNOffd. \n\nArguments\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state. Facultative, the same as bsd by default. \nqnf :: SQNOffd records the transformation ; \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{STransf, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(trs :: STransf, st_d :: Vector{ComplexF64} ; num_th = NumThreads) :: Vector{ComplexF64}\n*(trs :: STransf, st_d :: Vector{Float64} ; num_th = NumThreads) :: Vector{Float64}\n\nAct a transformation on a state. st_d must be of length trs.bsd.dim. Returns a vector of length trs.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Related-examples","page":"Fuzzifino","title":"Related examples","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"test_boson.jl tests the nearest-neighbour tight-binding model H=sum_i(b^dagger_ib_i+1+f^dagger_if_i+1+mathrmhc). The example diagonalises the sector with the number of bosons and fermions both N_o2, and even under the reflection with respect to a bond center imapsto N_o+1-i, and measures the total particle number squared leftsum_i(b_i^dagger b_i+f^dagger_if_i)right^2.\nising_frac_boson.jl calculates the spectrum of 3d Ising model on fuzzy sphere for bosons at fractional filling ν = 12. This example reproduces Figure 12a,b in Voinea 2024.","category":"page"},{"location":"extension/#Other-extensions","page":"Other extensions","title":"Other extensions","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"Apart from ITensor extension, FuzzifiED also provides other extensions, viz. HDF5 extension, KrylovKit extension, CUDA extension and SparseArrays extension. ","category":"page"},{"location":"extension/#HDF5-extension","page":"Other extensions","title":"HDF5 extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The HDF5 extension supports writing the types Confs, Basis, Terms, Operator, OpMat{ComplexF64} and OpMat{Float64} into HDF5 files and reading them from groups and subgroups in HDF5 format. This extension requires the packages HDF5. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using HDF5","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"A typical file operation process looks like","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"h5open(file_name, \"cw\")\n# include the file name as a string \n# Modes : \"cw\" for write and \"r\" for read\n...\nclose(f)","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"To write, include in the middle ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"write(f, group_name :: String, cfs :: Confs)\nwrite(f, group_name :: String, bs  :: Basis)\nwrite(f, group_name :: String, tms :: Terms)\nwrite(f, group_name :: String, op  :: Operator)\nwrite(f, group_name :: String, mat :: OpMat{ComplexF64})\nwrite(f, group_name :: String, mat :: OpMat{Float64})","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"To read, include in the middle ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"cfs = read(f, group_name :: String, Confs)\nbs  = read(f, group_name :: String, Basis)\ntms = read(f, group_name :: String, Terms)\nop  = read(f, group_name :: String, Operator)\nmat = read(f, group_name :: String, OpMat{ComplexF64})\nmat = read(f, group_name :: String, OpMat{Float64})","category":"page"},{"location":"extension/#SparseArrays-extension","page":"Other extensions","title":"SparseArrays extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The SparseArrays extension supports the conversion between OpMat in FuzzifiED and the SparseMatrixCSC and Matrix format. This extension requires the packages SparseArrays. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using SparseArrays","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"SparseMatrixCSC(mat :: OpMat)\nMatrix(mat :: OpMat)\nOpMat(matcsc :: SparseMatrixCSC)","category":"page"},{"location":"extension/#SparseArrays.SparseMatrixCSC-Tuple{OpMat}","page":"Other extensions","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC(mat :: OpMat{ComplexF64}) :: SparseMatrixCSC{Int64,ComplexF64}\nSparseMatrixCSC(mat :: OpMat{Float64}) :: SparseMatrixCSC{Int64,Float64}\n\nconverts the OpMat objects to a SparseMatrixCSC object in the SparseArrays package.\n\n\n\n\n\n","category":"method"},{"location":"extension/#Base.Matrix-Tuple{OpMat}","page":"Other extensions","title":"Base.Matrix","text":"Matrix(mat :: OpMat{ComplexF64}) :: Matrix{ComplexF64}\nMatrix(mat :: OpMat{Float64}) :: Matrix{Float64}\n\nconverts the OpMat objects to a full matrix.\n\n\n\n\n\n","category":"method"},{"location":"extension/#FuzzifiED.OpMat-Tuple{SparseMatrixCSC}","page":"Other extensions","title":"FuzzifiED.OpMat","text":"OpMat(matcsc :: SparseMatrixCSC{Int64,ComplexF64}) :: OpMat{ComplexF64}\nOpMat(matcsc :: SparseMatrixCSC{Int64,Float64}) :: OpMat{Float64}\n\nconverts the SparseMatrixCSC object in the SparseArrays package to an OpMat objects.\n\n\n\n\n\n","category":"method"},{"location":"extension/#KrylovKit-extension","page":"Other extensions","title":"KrylovKit extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The KrylovKit extension supports an interface diagonalising the sparse matrix using the KrylovKit pakage in Julia. This extension requires the packages KrylovKit. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using KrylovKit","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"Besides Arpack in Fortran, we also provide an interface calling KrylovKit in Julia.","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"GetEigensystemKrylov(mat :: OpMat{ComplexF64}, nst :: Int64)","category":"page"},{"location":"extension/#FuzzifiED.GetEigensystemKrylov-Tuple{OpMat{ComplexF64}, Int64}","page":"Other extensions","title":"FuzzifiED.GetEigensystemKrylov","text":"GetEigensystemKrylov(mat :: OpMat{ComplexF64}, nst :: Int64 ; initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nGetEigensystemKrylov(mat :: OpMat{Float64}, nst :: Int64 ; initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\nThis method calls the eigsolve from Julia KrylovKit.jl package instead of Arpack from Fortran to calculate the lowest eigenstates of sparse matrix. The performance should be similar. For an example, refer to ising_spectrum_krylov.jl.\n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix.\nnst :: Int64 is the number of eigenstates to be calculated.\ntol :: Float64 is the tolerence for the KrylovKit process. The default value is 1E-8.\nncv :: Int64 is the maximum dimension of the Krylov subspace. The default value is max(2 * nst, nst + 10). If krylovdim is also given, ncv will not be used.\ninitvec :: Vector{ComplexF64} or initvec :: Vector{Float64} is the initial vector. Facultative, a random initialisation by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default.\nkwargs... is the options that will directly sent into eigsolve, see its documentation for detail.\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"extension/#CUDA-extension","page":"Other extensions","title":"CUDA extension","text":"","category":"section"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"The CUDA extension supports the conversion between OpMat in FuzzifiED and the CuSparseMatrixCSC in CUDA.CUSPARSE as well as the acceleration of diagonalisation on GPU. This extension requires the packages CUDA, KrylovKit and SparseArrays. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"using CUDA, KrylovKit, SparseArrays","category":"page"},{"location":"extension/","page":"Other extensions","title":"Other extensions","text":"CUSPARSE.CuSparseMatrixCSC(mat :: OpMat{ComplexF64})\nGetEigensystemCuda(mat :: OpMat{ComplexF64}, nst :: Int64)","category":"page"},{"location":"extension/#CUDA.CUSPARSE.CuSparseMatrixCSC-Tuple{OpMat{ComplexF64}}","page":"Other extensions","title":"CUDA.CUSPARSE.CuSparseMatrixCSC","text":"CUSPARSE.CuSparseMatrixCSC(mat :: OpMat{ComplexF64})\nCUSPARSE.CuSparseMatrixCSC(mat :: OpMat{Float64})\n\nconverts the OpMat objects to a CuSparseMatrixCSC object in the CUDA.CUSPARSE package.\n\n\n\n\n\n","category":"method"},{"location":"extension/#FuzzifiED.GetEigensystemCuda-Tuple{OpMat{ComplexF64}, Int64}","page":"Other extensions","title":"FuzzifiED.GetEigensystemCuda","text":"GetEigensystemCuda(mat :: OpMat{ComplexF64}, nst :: Int64 ; initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{ComplexF64}, CuArray{ComplexF64, 2, CUDA.DeviceMemory}}\nGetEigensystemCuda(mat :: OpMat{Float64}, nst :: Int64 ; initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{Float64}, CuArray{Float64, 2, CUDA.DeviceMemory}}\n\nThis method uses Julia KrylovKit package to calculate the lowest eigenstates of sparse matrix. The sparse matrix multiplication is realised by CUDA.CUSPARSE. For an example, refer to ising_spectrum_cuda.jl.\n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix.\nnst :: Int64 is the number of eigenstates to be calculated.\ntol :: Float64 is the tolerence for the KrylovKit process. The default value is 1E-8.\nncv :: Int64 is the maximum dimension of the Krylov subspace. The default value is max(2 * nst, nst + 10). If krylovdim is also given, ncv will not be used.\ninitvec is the initial vector. Facultative, a random initialisation CUDA.rand(T, mat.dimd) by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \nkwargs... is the options that will directly sent into eigsolve, see its documentation for detail.\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimd*nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"releases/#Release-notes","page":"Releases","title":"Release notes","text":"","category":"section"},{"location":"releases/#Version-0.x","page":"Releases","title":"Version 0.x","text":"","category":"section"},{"location":"releases/#Version-0.10","page":"Releases","title":"Version 0.10","text":"","category":"section"},{"location":"releases/#Version-0.10.7-(9-December,-2024)","page":"Releases","title":"Version 0.10.7 (9 December, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add implementation of transformations.","category":"page"},{"location":"releases/#Version-0.10.6-(6-December,-2024)","page":"Releases","title":"Version 0.10.6 (6 December, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add entanglement calculations in Fuzzifino. ","category":"page"},{"location":"releases/#Version-0.10.5-(4-December,-2024)","page":"Releases","title":"Version 0.10.5 (4 December, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Fix the dependency in FuzzifiED_jll\nMove KrylovKit and SparseArrays to extensions. \nFix minor bugs. ","category":"page"},{"location":"releases/#Version-0.10.4-(30-November,-2024)","page":"Releases","title":"Version 0.10.4 (30 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Split ITensorsExt and EasySweepExt.\nDefine a new SiteType \"FuzzyFermion\" for ITensors to avoid overwriting \"Fermion\" in ITensorsExt.\nChange the names of Density and Electron to avoid conflict with other packages.\nCreate the alias Terms and STerms.\nFix bugs in converting OpSum to Terms.\nImprove the interface for ITensor extension.","category":"page"},{"location":"releases/#Version-0.10.3-(28-November,-2024)","page":"Releases","title":"Version 0.10.3 (28 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add options for DMRG. \nOptimise the implementation of confs in Fuzzifino.\nAdd the examples of fractional filling.","category":"page"},{"location":"releases/#Version-0.10.1-(25-November,-2024)","page":"Releases","title":"Version 0.10.1 (25 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add CUDA extension. \nAdd interface with KrylovKit.","category":"page"},{"location":"releases/#Version-0.10.0-(24-November,-2024)","page":"Releases","title":"Version 0.10.0 (24 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add module Fuzzifino for boson-fermion systems.","category":"page"},{"location":"releases/#Version-0.9","page":"Releases","title":"Version 0.9","text":"","category":"section"},{"location":"releases/#Version-0.9.3-(23-November,-2024)","page":"Releases","title":"Version 0.9.3 (23 November, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Move HDF5 and ITensor to extensions\nModify ITensor extension interfaces in alignment with the update of ITensor.","category":"page"},{"location":"releases/#Version-0.9.2-(16-September,-2024)","page":"Releases","title":"Version 0.9.2 (16 September, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the example of Ising generators and Sp(3) CFT.","category":"page"},{"location":"releases/#Version-0.9.1-(13-September,-2024)","page":"Releases","title":"Version 0.9.1 (13 September, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Allow input of initial vectors for diagonalisation. (We acknowledge Andrew Fitzpatrick for the suggestion.)","category":"page"},{"location":"releases/#Version-0.9.0-(11-September,-2024)","page":"Releases","title":"Version 0.9.0 (11 September, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add feature of angular modes observables.\nFix typos and bugs.","category":"page"},{"location":"releases/#Version-0.8","page":"Releases","title":"Version 0.8","text":"","category":"section"},{"location":"releases/#Version-0.8.2-(28-July,-2024)","page":"Releases","title":"Version 0.8.2 (28 July, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Fix bugs in GetDenIntTerms and multiplication in SphereObs. ","category":"page"},{"location":"releases/#Version-0.8.0-(26-July,-2024)","page":"Releases","title":"Version 0.8.0 (26 July, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Improve the performance of SimplifyTerms. \nAdd file operation. ","category":"page"},{"location":"releases/#Version-0.7","page":"Releases","title":"Version 0.7","text":"","category":"section"},{"location":"releases/#Version-0.7.2-(24-July,-2024)","page":"Releases","title":"Version 0.7.2 (24 July, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add example and support for surface CFTs. \nAdd example of Ising cusp.","category":"page"},{"location":"releases/#Version-0.7.1-(11-June,-2024)","page":"Releases","title":"Version 0.7.1 (11 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add some new interfaces for built-in operators. \nAdd new examples. \nFix bugs","category":"page"},{"location":"releases/#Version-0.7.0-(9-June,-2024)","page":"Releases","title":"Version 0.7.0 (9 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Revise the implementation of diagonal and off-diagonal quantum number. ","category":"page"},{"location":"releases/#Version-0.6","page":"Releases","title":"Version 0.6","text":"","category":"section"},{"location":"releases/#Version-0.6.3-(8-June,-2024)","page":"Releases","title":"Version 0.6.3 (8 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for calculating entanglement spectrum. \nAdd global parameters to control the number of threads, the output and the path of the dynamic library. \nFix bugs. ","category":"page"},{"location":"releases/#Version-0.6.0-(5-June,-2024)","page":"Releases","title":"Version 0.6.0 (5 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for full diagonalisation. \nFix bugs and typos.\nReady for formal release !","category":"page"},{"location":"releases/#Version-0.5","page":"Releases","title":"Version 0.5","text":"","category":"section"},{"location":"releases/#Version-0.5.8-(3-June,-2024)","page":"Releases","title":"Version 0.5.8 (3 June, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Change the binary dependence to Julia Binary Builder. ","category":"page"},{"location":"releases/#Version-0.5.0-(30-May,-2024)","page":"Releases","title":"Version 0.5.0 (30 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Enable simplification of terms.\nAdd general observables and built-in electrons and density operators. \nReorganise the realisations of built-in models.\nCancel ITensorMPOConstruction dependence. ","category":"page"},{"location":"releases/#Version-0.4","page":"Releases","title":"Version 0.4","text":"","category":"section"},{"location":"releases/#Version-0.4.3-(29-May,-2024)","page":"Releases","title":"Version 0.4.3 (29 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add QNU truncation for ITensor use.\nChange the Fortran code to be robust against QNU breaking terms\nAdd built-in density-density interaction. \nAdd built-in 3-state Potts model.\nAdd built-in Ising model with magnetic line defect. ","category":"page"},{"location":"releases/#Version-0.4.0-(28-May,-2024)","page":"Releases","title":"Version 0.4.0 (28 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for DMRG.\nAdd convertion from diagonal QNs to sites. \nAdd the support of mathbbZ_n diagonal quantum numbers in Confs.\nMerge the submodules to the main package. \nAdd Ising model in X basis.  \nAdd functions in built-in models to export diagonal QNs. ","category":"page"},{"location":"releases/#Version-0.3","page":"Releases","title":"Version 0.3","text":"","category":"section"},{"location":"releases/#Version-0.3.0-(27-May,-2024)","page":"Releases","title":"Version 0.3.0 (27 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the support for Hamiltonians with real elements. \nAdd conversion with SparseMatrixCSC. \nAdd the conversion from terms to OpSum.\nAdd the look-up of configurations. \nFor the built-in Ising model, add density operator.\nAdd built-in mathrmSp(N) model. ","category":"page"},{"location":"releases/#Version-0.2","page":"Releases","title":"Version 0.2","text":"","category":"section"},{"location":"releases/#Version-0.2.0-(26-May,-2024)","page":"Releases","title":"Version 0.2.0 (26 May, 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add operations of terms.\nAdd built-in Ising model. ","category":"page"},{"location":"#FuzzifiED.jl","page":"Home","title":"FuzzifiED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Since its proposal, the fuzzy sphere regularisation has made significant contribution to the study of 3d CFTs. This Julia package FuzzifiED is aimed at simplifying the numerical calculations on the fuzzy sphere. It facilitates the exact diagonalisation (ED) calculations as well as the density matrix renormalisation group (DMRG) with the help of ITensor. It can also be used for generic fermionic and bosonic models. This package features the following characteristics : ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Versatality : FuzzifiED can help reproduce almost all the ED and DMRG results in fuzzy sphere works, and it is easy and flexible for the adaption to new models. \nUsability : Julia interfaces make the code intuitive and short. To help the users get started, we have also provided a collection of examples.\nEfficiency : FuzzifiED can produce results on reasonable system sizes within minutes.\nOpen source : The code for FuzzifiED is fully open source. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"A PDF version of the documentation is provided at this link. If you have any questions, please contact Zheng Zhou (周正) at physics@zhengzhou.page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, run the following command in the Julia REPL (read-eval-print loop) (To enter Julia REPL, simply type julia in the command line) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg ; Pkg.add(\"FuzzifiED\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, include at the start of the Julia script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FuzzifiED","category":"page"},{"location":"","page":"Home","title":"Home","text":"To obtain the documentation for an interface, type ? followed by the keyword in the Julia REPL, e.g., ?Confs.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If this package is helpful in your research, we would appreciate it if you mention in the acknowledgement. We have also provided a BibTeX file that includes all the works on the fuzzy sphere works at this link.","category":"page"},{"location":"#Useful-information","page":"Home","title":"Useful information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia at this link. \nWe have registered FuzzifiED at Julia General Registry. The package regisitry may have some delay, to bring up to date, use Pkg.Registry.update(), or install from the github repositories ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/FuzzifiED/FuzzifiED_jll.jl\")\nPkg.add(url=\"https://github.com/FuzzifiED/FuzzifiED.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Jupyter Notebook is highly recommended as it allows you to run Julia (and Python) just like running a Mathematica notebook.\nThe package is under active development, so certain interfaces may get changed, superceded or obsolete. We are sorry for any possible inconvenience. \nThe supporting Fortran code for ED is stored at the GitHub Repo at FuzzifiED/FuzzifiED_Fortran.","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"intro.md\",\n    \"example.md\",\n    \"core.md\",\n    \"models.md\",\n    \"itensors.md\",\n    \"extension.md\",\n    \"fuzzifino.md\",\n    \"releases.md\"\n]\nDepth = 2","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[Zhu 2022] Uncovering conformal symmetry in the 3d Ising transition : state-operator correspondence from a quantum fuzzy sphere regularisation, Wei Zhu, Chao Han, Emilie Huffman, Johannes S. Hofmann, and Yin-Chen He, arXiv:2210.13482, Phys. Rev. X 13, 021009 (2023).\n[Hu 2023Mar] Operator product expansion coefficients of the 3d Ising criticality via quantum fuzzy sphere, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2303.08844, Phys. Rev. Lett 131, 031601 (2023).\n[Han 2023Jun] Conformal four-point correlators of the 3d Ising transition via the quantum fuzzy sphere, Chao Han, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.04681, Phys. Rev. B 108, 235123 (2023).\n[Zhou 2023] The mathrmSO(5) deconfined phase transition under the fuzzy sphere microscope: approximate conformal symmetry, pseudo-criticality, and operator spectrum, Zheng Zhou, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.16435, Phys. Rev. X 14, 021044 (2024).\n[Lao 2023] 3d Ising CFT and exact diagonalisation on icosahedron : the power of conformal perturbation theory, Bing-Xin Lao, and Slava Rychkov arXiv:2307.02540, SciPost Phys. 15, 243 (2023).\n[Hu 2023Aug] Solving conformal defects in 3d conformal field theory using fuzzy sphere regularisation, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2308.01903, Nat. Commun. 15, 3659 (2024).\n[Hofmann 2024] Quantum Monte Carlo simulation of the 3d Ising transition on the fuzzy sphere, Johannes S. Hofmann, Florian Goth, Wei Zhu, Yin-Chen He, and Emilie Huffman, arXiv:2310.19880, SciPost Phys. Core 7, 028 (2024).\n[Han 2023Dec] Conformal operator content of the Wilson-Fisher transition on fuzzy sphere bilayers, Chao Han, Liangdong Hu, and Wei Zhu, arXiv:2312.04047, Phys. Rev. B 110, 115113 (2024).\n[Zhou 2024Jan] The g-function and defect changing operators from wavefunction overlap on a fuzzy sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, Yijian Zou, arXiv:2401.00039, SciPost Phys. 17, 021 (2024).\n[Hu 2024] Entropic F-function of 3d Ising conformal field theory via the fuzzy sphere regularisation, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2401.17362.\n[Cuomo 2024] Impurities with a cusp : general theory and 3d Ising, Gabriel Cuomo, Yin-Chen He, Zohar Komargodski, arXiv:2406.10186. \n[Zhou 2024Jul] Studying the 3d Ising surface CFTs on the fuzzy sphere, Zheng Zhou, and Yijian Zou, arXiv:2407.15914.\n[Dedushenko 2024] Ising BCFTs from the fuzzy hemisphere, Mykola Dedushenko, arXiv:2407.15948.\n[Fardelli 2024] Constructing the infrared conformal generators on the fuzzy sphere, Giulia Fardelli, A. Liam Fitzpatrick, and Emanuel Katz, arXiv:2409.02998.\n[Fan 2024] Note on explicit construction of conformal generators on the fuzzy sphere, Ruihua Fan, arXiv:2409.08257.\n[Zhou 2024Oct] A new series of 3d CFTs with mathrmSp(N) global symmetry on fuzzy sphere, Zheng Zhou, and Yin-Chen He, arXiv:2410.00087.\n[Voinea 2024] Regularising 3d conformal field theories via anyons on the fuzzy sphere, arXiv:2411.15299.\n[Han 2025] Quantum phase transitions on the noncommutative circle, Chao Han, and Wei Zhu, Phys. Rev. B 111, 085113 (2025)\n[Yang 2025] Microscopic study of 3d Potts phase transition via fuzzy sphere regularisation, Shuai Yang, Yan-Guang Yue, Yin Tang, Chao Han, Wei Zhu, and Yan Chen, arXiv:2501.14320","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"core.md\",\n    \"models.md\",\n    \"itensors.md\",\n    \"extension.md\",\n    \"fuzzifino.md\"\n]","category":"page"},{"location":"tutorial/#FuzzifiED-explained-in-a-tutorial","page":"Tutorial","title":"FuzzifiED explained in a tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To demonstrate the usage of FuzzifiED interfaces for ED and DMRG, in this section, we use a tutorial that calculates the eigenstates for the Ising model on fuzzy sphere. Specifically, it","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculates the lowest eigenstates in the symmetry sector L^z=0 and (mathcalPmathcalZmathcalR)=(+++),\nmeasures their total angular momenta, and \ncalcultes the OPE coefficient f_sigmasigmaepsilon=langle sigman^z_00epsilonranglelangle sigman^z_000rangle.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Four versions of the tutorial code are provided : ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tutorial_ising.jl – the ED code that uses the built-in models.\ntutorial_ising_primitive.jl – The ED code that uses only the core functions.\ntutorial_ising_dmrg.jl – the DMRG code that converts the format into ITensor.\ntutorial_ising_dmrg_easysweep.jl – the DMRG code that uses the EasySweep extension.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The examples can be found in the directory examples. We also append in the end a list of given examples at the end of the page. ","category":"page"},{"location":"tutorial/#Exact-diagonalisation-(ED)-with-FuzzifiED","page":"Tutorial","title":"Exact diagonalisation (ED) with FuzzifiED","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this section, we briefly describe the procedure for exact diagonalisation (ED) calculation and give an instruction for using FuzzifiED for ED. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Practically, the ED calculation can be divided into 4 steps.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Construct a many-body basis that respect a given set of quantum numbers. Specifically, in FuzzifiED we support quantum numbers of commuting mathrmU(1) or discrete mathbbZ_p symmetries.\nConstruct the sparse matrix corresponding to the Hamiltonian in the basis above. \nFind the lowest eigenstates and their corresponding eigenenergies of the sparse matrix.\nMaking measurements on the eigenstates. This including the total angular momentum, density operators, entanglement, etc.","category":"page"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before starting the calculation, we need to input the setup for the system, including the number of flavours N_f, orbitals N_m and sites N_o ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A 'flavour' is labelled by f. The number of flavours is N_f.\nAn 'orbital' is specified by the magnetic quantum number labelled by m. The number of orbitals is N_m=2s+1.\nA 'site' is specific by both the flavour and the orbital index o=(fm). The number of sites is N_o=N_mN_f. In practice, we label the sites with an integer from 1 to N_o. We store the sites in an ascending order of first m and then f~: o=(m+s)N_f+f.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model with s=55,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nm = 12\nnf = 2\nno = nm * nf","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FuzzifiED also provides several environment parameters that defines how FuzzifiED works, viz. FuzzifiED.ElementType, FuzzifiED.NumThreads and FuzzifiED.SilentStd.","category":"page"},{"location":"tutorial/#Constructing-the-configurations","page":"Tutorial","title":"Constructing the configurations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step for the ED calculation is to construct the basis tha respects the symmetries of the Hamiltonian. This is divided into two steps : (1) generate the 'configurations' that carry the diagonal quantum numbers, and (2) generate the 'basis' that also carry the off-diagonal quantum numbers (under discrete transformations). The 'configurations' are the collection of states that can be written as direct product of occupied 1rangle or empty 0rangle on each site and carries certain diagonal quantum numbers (QNDiag). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The QNDiags supported by FuzzifiED are the charges of mathrmU(1) or mathbbZ_p symmetry in the form of ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n    Q=sum_oq_on_omathrmU(1)textrm symmetry\n    Q=sum_oq_on_omod pmathbbZ_ptextrm symmetry\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where n_o=c^dagger_oc_o is the particle number on each site, and q_o is the charge that each orbital carries. FuzzifiED restricts q_o to be integer-valued. In FuzzifiED, the QNDiags are recorded in the mutable type QNDiag. Several useful QNDiags are built-in. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The collection of configurations is generated from the QNDiags. It is recorded in the mutable type Confs  and can be constructed by the method ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where qnd is the array of QNDiags, and secd is the array of charges Q of each QNDiag. Here each configuration is stored as a binary number with N_o bits. If the o-th site in the configuration is occupied, the (o-1)-th bit of the configuration is 1; if the site is empty, then the bit is 0. Besides the storation of the configuration, we also need a reverse look-up process that returns the index from the binary string. This is realised by a Lin table.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, there are two QNDiags, viz. the particle number and the angular momentum. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\nQ_1=N_e q_1msigma=1\nQ_2=2L_zq_2msigma=2m\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The full code to generating the configurations in the L_z=0 sector is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nm = 12\nnf = 2\nno = nm * nf\nqnd = [ \n    QNDiag(fill(1, no)), \n    QNDiag([ 2 * m - nm - 1 for m = 1 : nm for f = 1 : nf ])\n]\ncfs = Confs(no, [nm, 0], qnd)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in models, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nm = 12\nnf = 2\nno = nm * nf\nqnd = [ \n    GetNeQNDiag(no), \n    GetLz2QNDiag(nm, nf) \n]\ncfs = Confs(no, [nm, 0], qnd)","category":"page"},{"location":"tutorial/#Constructing-the-basis","page":"Tutorial","title":"Constructing the basis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having constructed the configurations, we now construct the basis of the Hilbert space. The `basis' is the collection of states that are linear combinations of the configuration carrying certain diagonal and mathbbZ_p off-diagonal quantum numbers (QNOffd). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The QNOffds supported by FuzzifiED are the mathbbZ_p symmetry that are in the form of ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    mathcalZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where we use a notation c^(1)=c^dagger and c^(0)=c for convenience, pi_o is a permutation of the sites 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. In FuzzifiED, the QNOffds are recorded in the mutable type QNOffd. Several useful QNOffds are built-in.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After implementing the QNOffds, a state in the new basis should look like ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    Irangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where the irangle's are configurations, and Irangle is a linear combination of them. This process can be regarded as organising the configurations into groups of size m_I. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the basis Irangle is recorded in the mutable type Basis. It can be constructed by the methods ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd})\nBasis(cfs :: Confs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where secf records the eigenvalue of each transformation, typically in the form e^i2pi qp where p is the cycle and q is the mathbbZ_p charge. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, There are three mathbbZ_2 symmetries, viz. the particle-hole transformation mathcalP, the pi-rotation along the y-axis mathcalR_y, and the flavour (Ising) symmetry mathcalZ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n    mathscrPc^dagger_sigma mtosigma c_-sigmam\n    mathscrZc^dagger_sigma mto c^dagger_-sigmam\n    mathscrR_yc^dagger_sigma mto c^dagger_sigma-m\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The code to generate the basis in the all-positive sector is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnf = [\n    # Parity (Particle-hole)\n    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no], true, ComplexF64[ isodd(o) ? -1 : 1 for o = 1 : no]),\n    # Flavour symmetry\n    QNOffd([ isodd(o) ? o + 1 : o - 1 for o = 1 : no]),\n    # Y-axis pi-rotation\n    QNOffd([ isodd(o) ? no - o : no + 2 - o for o = 1 : no], ComplexF64(-1) .^ (collect(0 : nm * nf - 1) .÷ nf))\n]\nbs = Basis(cfs, [1, 1, 1], qnf) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnf = [ \n    GetParityQNOffd(nm, 2, [2, 1], [-1, 1]), \n    GetFlavPermQNOffd(nm, 2, [2, 1]), \n    GetRotyQNOffd(nm, 2) \n]\nbs = Basis(cfs, [1, 1, 1], qnf)\n# The second argument gives the eigenvalues under the transformations, for Z_2 put 1,-1 ; for Z_n put exp(2im*pi*q/p)","category":"page"},{"location":"tutorial/#Recording-the-many-body-operator-terms","page":"Tutorial","title":"Recording the many-body operator terms","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having constructed the basis, we now construct the many-body operators. A general many-body operator can be written as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    mathscrO=sum_t=1^N_tU_tc^(p_t1)_o_t1c^(p_t2)_o_t2dots c^(p_tl_t)_o_tl_t","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where c^(0)=c and c^(1)=c^dagger. In FuzzifiED, this is recorded as an array of Term, and each Term records the building block Uc^(p_1)_o_1c^(p_2)_o_2dots c^(p_l)_o_l. It can be initialised by the method ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Term(coeff :: ComplexF64, cstr :: Vector{Int64})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The addition and multiplication of terms are supported, and the terms can be simplified by the method SimplifyTerms","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(tms :: Vector{Term})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, several useful operator terms are built-in.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, the full code that records the Hamiltonian is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\ntms_hmt = Term[]\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m\nm = zeros(Int64, 4)\nfor m[1] = 0 : nm - 1, m[2] = 0 : nm - 1, m[3] = 0 : nm - 1\n    m[4] = m[1] + m[2] - m[3]\n    (m[4] < 0 || m[4] >= nm) && continue\n    f = [0, 1, 1, 0]\n    o = m .* nf .+ f .+ 1\n    mr = m .- s\n    \n    # Calculate the matrix element val from pseudopotentials\n    val = ComplexF64(0)\n    for l in eachindex(ps_pot)\n        (abs(mr[1] + mr[2]) > nm - l || abs(mr[3] + mr[4]) > nm - l) && break \n        val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, mr[1], mr[2], -mr[1] - mr[2]) * wigner3j(s, s, nm - l, mr[4], mr[3], -mr[3] - mr[4])\n    end \n    # Record the interaction term val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n    tms_hmt += Terms(val, [1, o[1], 1, o[2], 0, o[3], 0, o[4]])\nend \nfor m = 0 : nm - 1\n    o = m * nf .+ [1, 2]\n    # Record the transverse field term\n    tms_hmt += Terms(-h, [1, o[1], 0, o[2]])\n    tms_hmt += Terms(-h, [1, o[2], 0, o[1]])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sg1 = [ 1 0 ; 0 0 ]\nsg2 = [ 0 0 ; 0 1 ]\nsgx = [ 0 1 ; 1 0 ]\nsgz = [ 1 0 ; 0 -1]\nps_pot = [ 4.75, 1.0 ] * 2.0\nfld_h = 3.16\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot, sg1, sg2)\n    - fld_h * GetPolTerms(nm, 2, sgx) \n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We also need to construct the total angular momentum. It is defined as ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    L^2=L^+L^-+(L^z)^2-L^z","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"as c_m carries the mathrmSO(3) spin-s representation, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    L^z=sum_mfmc_m^dagger c_mquad L^pm=sum_mfsqrt(smp m)(spm m+1)c^dagger_mpm 1c_m","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we can first construt its building blocks and use the addition and multiplication of the terms","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_lz = \n    [ begin m = div(o - 1, nf)\n        Term(m - s, [1, o, 0, o])\n    end for o = 1 : no ]\ntms_lp = \n    [ begin m = div(o - 1, nf)\n        Term(sqrt(m * (nm - m)), [1, o, 0, o - nf])\n    end for o = nf + 1 : no ]\ntms_lm = tms_lp' \ntms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in functions,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, nf)","category":"page"},{"location":"tutorial/#Generating-sparse-matrix","page":"Tutorial","title":"Generating sparse matrix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having gotten the terms in the many-body operator, we now need to generate the matrix elements given the initial and final basis and find its eigenstates. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the mutable type Operator records the terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.  be initialised with the method ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operator(bsd :: Basis[, bsf :: Basis], terms :: Vector{Term} ; red_q :: Int64, sym_q :: Int64)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the sparse matrix is stored in the mutable type OpMat{T} where T is the type of the elements (ComplexF64 or Float64). It can be generated from the method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"OpMat[{T}](op :: Operator)","category":"page"},{"location":"tutorial/#Finding-the-eigenstates","page":"Tutorial","title":"Finding the eigenstates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After generating the sparse matrix, the method GetEigensystem uses the Fortran Arpack package to calculate its lowest eigenstates. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, the full code to calculate the lowest N_mathrmst=10 eigenstates from the basis and the terms is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nst = 10\nhmt = Operator(bs, tms_hmt)\nhmt_mat = OpMat(hmt)\nenrg, st = GetEigensystem(hmt_mat, nst)","category":"page"},{"location":"tutorial/#Write-the-sparse-matrix-into-HDF5-file","page":"Tutorial","title":"Write the sparse matrix into HDF5 file","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is sometimes needed to write the sparse matrix into file to avoid extra effort to generate it again in another calculation. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using HDF5 \nf = h5open(\"data.h5\", \"cw\")\nwrite(f, \"hmt_mat\", hmt_mat)\nclose(f)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To read from the file","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f = h5open(\"data.h5\", \"r\") \nhmt_mat = read(f, \"hmt_mat\", OpMat{ComplexF64})\nclose(f)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Apart from OpMat, the supported types for writing include Confs, Basis, Terms, Operator, OpMat{ComplexF64} and OpMat{Float64}. ","category":"page"},{"location":"tutorial/#Inner-product-of-states,-operators-and-transformations","page":"Tutorial","title":"Inner product of states, operators and transformations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having obtained the eigenstates, we need to make measurements on it. The simplest kind of measurements is the inner product of a many body operator with two states langle jmathcalOirangle. FuzzifiED supports the inner product and vector product of Operator and OpMat{T} with vectors that represent the state","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(op :: Operator) * (st_d :: Vector{T}) :: Vector{T}\n(mat :: OpMat{T}) * (st_d :: Vector{T}) :: Vector{T}\n(st_f :: Vector{T}) * (op :: Operator) * (st_d :: Vector{T}) :: T\n(st_f :: Vector{T}) * (mat :: OpMat{T}) * (st_d :: Vector{T}) :: T","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, the code to measure the angular momenta of each state is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = Operator(bs, tms_l2)\nl2_mat = OpMat(l2)\nl2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]","category":"page"},{"location":"tutorial/#Go-through-all-the-sectors","page":"Tutorial","title":"Go through all the sectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can repeat the calculation for all the sectors and records the results","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"result = []\nfor P in [1, -1], Z in [1, -1], R in [1, -1]\n    bs = Basis(cfs, [P, Z, R], qnf)\n    hmt = Operator(bs, tms_hmt)\n    hmt_mat = OpMat(hmt)\n    enrg, st = GetEigensystem(hmt_mat, 10)\n\n    l2 = Operator(bs, tms_l2)\n    l2_mat = OpMat(l2)\n    l2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]\n\n    for i in eachindex(enrg)\n        push!(result, round.([enrg[i], l2_val[i], P, Z], digits = 6))\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We then sort the eigenstates, find the energy of ground state and stress tensor, and calibrate the scaling dimensions. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sort!(result, by = st -> real(st[1]))\nenrg_0 = result[1][1]\nenrg_T = filter(st -> st[2] ≊ 6 && st[3] ≊ 1 && st[4] ≊ 1, result)[1][1]\nresult_dim = [ [ 3 * (st[1] - enrg_0) / (enrg_T - enrg_0) ; st] for st in result ]\nfor P in (1, -1), Z in (1, -1)\n    display(permutedims(hcat(\n        filter(st -> st[4] ≊ P && st[5] ≊ Z, result_dim)...\n    )))\nend","category":"page"},{"location":"tutorial/#Measuring-local-observables","page":"Tutorial","title":"Measuring local observables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Local observables are a kind of particularly useful operators on fuzzy sphere. Their value at a point on the sphere can be decomposed into spherical components, and the multiplication of the components follows the triple integral formula of monopole spherical harmonics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n    mathcalO(hatmathbfn)=sum_lmY^(s)_lm(hatmathbfn)mathcalO_lm\n    (mathcalO_1mathcalO_2)_lm=sum_l_1l_2m_1m_2(mathcalO_1)_l_1m_1(mathcalO_2)_l_2m_2\n    qquadqquadtimes(-1)^s+msqrtfrac(2l_1+1)(2l_2+1)(2l_3+1)4pibeginpmatrixl_1l_2lm_1m_2-mendpmatrixbeginpmatrixl_1l_2l-s_1-s_2sendpmatrix\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, they are stored in the type SphereObs and can be initialised from either a function or a dictionary that specifies the components","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)\nSphereObs(s2 :: Int64, l2m :: Int64, comps :: Dict)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Their adjoint, addition, multiplication and Laplacian are supported. The related functions are StoreComps that stores all the components, GetComponent and GetPointValue that evaluate a spherical component mathcalO_lm or value at one point mathcalO(hatmathbfn). Several important types of spherical observables are built-in in FuzzifiED, viz., electron, density operator and pairing operator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, to calculate the OPE coefficient f_sigmasigmaepsilon=langle sigman^z_00epsilonranglelangle sigman^z_000rangle, one need to first calculate the eigenstates in the mathbbZ_2-odd sector","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bs1 = Basis(cfs, [1, -1, 1], qnf)\nhmt1 = Operator(bs1, bs1, tms_hmt ; red_q = 1, sym_q = 1) \nhmt_mat1 = OpMat(hmt1)\nenrg1, st1 = GetEigensystem(hmt_mat1, 10)\nstI = st[:, 1] \nste = st[:, 2] \nsts = st1[:, 1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and then construct the density operator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obs_nz = GetDensityObs(nm, 2, sgz)\ntms_nz00 = SimplifyTerms(GetComponent(obs_nz, 0.0, 0.0))\nnz00 = Operator(bs, bs1, tms_nz00 ; red_q = 1) \nf_sse = abs((sts' * nz00 * ste) / (sts' * nz00 * stI))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Besides the spherical observable, we also provide a type AngModes that superposes under the rule of angular momentum superposition instead of spherical harmonics triple integral","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    (mathscrA_1mathscrA_2)_lm=sum_l_1m_1l_2m_2(mathcalA_1)_l_1m_1(mathcalA_2)_l_2m_2langle l_1m_1l_2m_2lmrangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interfaces are similar.","category":"page"},{"location":"tutorial/#Measuring-the-entanglement","page":"Tutorial","title":"Measuring the entanglement","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A non-local quantity that bears particular significance is the entanglement. To calculate the entanglement, we divide the sphere into two parts A and B. The reduced density matrix of part A is obtained by tracing the density matrix over the part B","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    rho_A(Psi)=operatornametr_BPsiranglelanglePsi","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The entanglement entropy is S=-operatornametrrho_Alogrho_A and the entanglement spectrum is the collection of eigenvalues of rho_A taken negative logarithm. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The detail of the calculation is given in PRB 85, 125308 (2012). Here we only sketch the process. The creation operator in each orbital is divided into the creation on A part and the creation on B part. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    c^dagger_o=alpha_oc^dagger_oA+beta_mc^dagger_oB","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where alpha_o^2+beta_o^2=1. For the cut in orbital space m_c,  \\begin{equation}     \\alpha{mf}=\\Theta(mc-m) \\end{equation} where Theta is the Heaviside function ; for the cut in real space along latitude circle theta_c, \\begin{equation}     \\alpha{mf}=\\Beta{\\cos^2\\theta_c/2}(s-m+1,s+m+1)^{1/2} \\end{equation} where Beta is the incomplete beta function. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To calculate the reduced density matrix, we decompose the state into the direct-product basis of two subsystems","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    Psirangle=sum_K_0v_K_0K_0rangle=sum_I_AJ_BM_I_AJ_BI_ArangleJ_Brangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where the indices K_0inmathcalHI_AinmathscrH_AJ_BinmathscrH_B are in the overall Hilbert space and the Hilbert space of subsystem A and B. The density matrix is then ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    rho_A=mathbfMmathbfM^dagger","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the entanglement spectrum can be obtained from the SVD decomposition of the mathbfM matrix. Like the Hamiltonian, the mathbfM matrix is block diagonal, and each block carries different quantum numbers of the Hilbert spaces of A and B subsystem~\\footnote{The M_IJ and alpha_o in our convention is equivalent to mathcalF_mA and R_munu^A in the convension of Ref.~\\cite{Sterdyniak2011Entanglement}, the conversions are alpha_mf=sqrtmathscrF_mA and M_IJ=R_munu^Asqrtp.}. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the decomposition of states into matrix M_I_AJ_B is done by the funciton StateDecompMat, and the calculation of entanglement spectrum is done by the funciton GetEntSpec","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, to calculate the entanglement entropy cut from the equator, we first need to specify the quantum numbers of the subsystems : the conservation of N_e, L_z and the mathbbZ_2 symmetry.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnd_a = [ GetNeQNDiag(no), GetLz2QNDiag(nm, nf) ]\nqnf_a = [ GetFlavPermQNOffd(nm, nf, [2, 1]) ]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we then specify the sectors to calculate : The number of electrons in subsystem A run from 0 to N_m~; the angular momenta in subsystem A can take all permitted values~; for subsystem B, N_eB=N_m-N_eA, L_zB=-L_zA~; the mathbbZ_2 sectors of the two subsystems are the same. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"secd_lst = Vector{Vector{Int64}}[]\nfor nea = 0 : nm \n    neb = nm - nea \n    for lza = -min(nea, neb) * (nm - 1) : 2 : min(nea, neb) * (nm - 1)\n        lzb = -lza \n        push!(secd_lst, [[nea, lza], [neb, lzb]])\n    end\nend\nsecf_lst = [ [[1], [1]], [[-1], [-1]] ]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we specify the list of amplitute alpha_m.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"amp_oa = [ sqrt(beta_inc(m, nm - m + 1, 0.5)) for f = 1 : 2 for m = 1 : nm]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To calculate the entanglement spectrum, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ent_spec = GetEntSpec(st_g, bs, secd_lst, secf_lst ; qnd_a, qnf_a, amp_oa)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The entanglement entropy can be calculated by collecting all the eigenvalues of the density matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"eig_rho = vcat(values(ent_spec)...)\nent_entropy = -sum(eig_rho .* log.(eig_rho))","category":"page"},{"location":"tutorial/#DMRG-calculations-with-FuzzifiED","page":"Tutorial","title":"DMRG calculations with FuzzifiED","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having introduced ED, we now turn to density matrix renormalisation group (DMRG) that deals with larger systems. We briefly describe its procedure  and give an instruction for using FuzzifiED for DMRG. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Practically, the dmrg function in ITensor package automatically uses DMRG to optimise a matrix product state (MPS) to be the lowest eigenstate of a Hermitian Hamiltonian represented as a matrix product operator (MPO). To generate the input of the function, one needs to ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"construct a set of sites that carries a certain set of QNDiags,\nconstruct a MPO representing the Hamiltonian on the sites from a set of terms (or OpSum in ITensor), and \nconstruct an initial MPS on the sites in the desired symmetry sector.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, a new SiteType \"FuzzyFermion\" is defined that behaves similar to the built-in \"Fermion\" type and the set of sites can be generated by the function GetSites","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, for convenience we exchange the Pauli matrices sigma^x and sigma^z so that the two flavours carry mathbbZ_2-charge 0 and 1. The sites can be constructed by ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nm = 12\nnf = 2\nno = nm * nf\nsites = GetSites([\n    GetNeQNDiag(nm * nf), \n    GetLz2QNDiag(nm, nf),\n    GetZnfChargeQNDiag(nm, nf)\n])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In ITensor, the MPO is generated from an OpSum and the sites. The OpSum can be directly converted from the array of terms. In the example of Ising model, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sgx = [  0  1 ;  1  0 ]\nsgz = [  1  0 ;  0 -1 ]\nps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, sgx) - \n    3.16 * GetPolTerms(nm, nf, sgz)\n)\nos_hmt = OpSum(tms_hmt)\nhmt = MPO(os_hmt, sites)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To calculate the mathbbZ_2-even L^z=0 sector, the initial state can be taken as the all the mathbbZ_2-even sites being filled and all the mathbbZ_2-odd sites being empty. (Note that ITensor takes the string \"1\" instead of the number 1 as occupied and \"0\" instead of 0 as filled.) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having these ingrediants ready, we can call the dmrg function. To ensure performance, the maximal bond dimension should be increased gradually and the noise decreased gradually to 0. An example that deals with maximal bond dimension 500 is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EI, stI = dmrg(hmt, st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate a mathbbZ_2-odd initial state, we can simply flip the spin on the first orbital","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cf1 = cf0 \ncf1[1] = 0\ncf1[2] = 1\nst1 = MPS(sites, string.(cf1))\nEs, sts = dmrg(hmt, st1 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first excited mathbbZ_2-even state can be generated by adding a projector w0ranglelangle0 to the MPO ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ee, ste = dmrg(hmt, [stI], st0 ; nsweeps = 10, maxdim = [10,20,50,100,200,500], noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], cutoff = [1E-8], weight = 100)`","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The inner product can be measured by the ITensor function inner. For example, to measure the angular momentum L^2 of the ground state,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = MPO(OpSum(tms_l2))\nval_l2I = inner(stI', l2, stI)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To measure the OPE coefficient f_sigmasigmaepsilon=langle sigman^x_00epsilonranglelangle sigman^x_000rangle. (Note that the indices x and z have already been exchanged here.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obs_nx = GetDensityObs(nm, 2, sgx)\ntms_nx00 = SimplifyTerms(GetComponent(obs_nx, 0.0, 0.0))\nnx00 = MPO(OpSum(tms_nx00))\nf_sse = abs(inner(sts', nx00, ste) / inner(sts', nx00, stI))","category":"page"},{"location":"tutorial/#The-EasySweep-extension","page":"Tutorial","title":"The EasySweep extension","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The extension EasySweep facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. This extension contains the following functions : GetMPOSites, GetMPO, SweepOne, EasySweep.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To use the this extension, one need to use the packages ITensors, ItensorMPS and HDF5. A path need to be created a priori to store the result HDF5 files. We recommend using the package ITensorMPOConstruction to generate the MPO, which can be installed through ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg ; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\"); ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FuzzifiED\nusing ITensors, ITensorMPS, HDF5\nusing ITensorMPOConstruction\nconst sgx = [  0  1 ;  1  0 ]\nconst sgz = [  1  0 ;  0 -1 ]\n\nfunction MyMPO(os, sites)\n    operatorNames = [ \"I\", \"C\", \"Cdag\", \"N\" ]\n    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]\n    return MPO_new(os, sites ; basis_op_cache_vec = opCacheVec)\nend\n\nnm = 12\nnf = 2\nno = nm * nf\n\npath = \"nm_$(nm)_tmp/\"\nmkpath(path)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Like the previous section, we first put in the terms for Hamiltonian and the QNDiags ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, sgx) - \n    3.16 * GetPolTerms(nm, 2, sgz)\n)\nqnd = [ \n    GetNeQNDiag(no), \n    GetLz2QNDiag(nm, nf), \n    GetZnfChargeQNDiag(nm, nf) \n]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Sites and Hamiltonian MPO can be generated with the function GetMPOSites. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hmt, sites = GetMPOSites(\"hmt\", tms_hmt, qnd ; path, mpo_method = MyMPO)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate the initial MPS that respects the mathbbZ_2 symmetry, we can use a direct product state. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cf0 = [ isodd(o) ? 1 : 0 for o = 1 : no ]\nst0 = MPS(sites, string.(cf0))\ncf1 = cf0\ncf1[1] = 0\ncf1[2] = 1\nst1 = MPS(sites, string.(cf1))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lowest eigenenergies and the eigenstate MPSs 0ranglesigmarangleepsilonrangle can be easily generated by the function EasySweep.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"EI, stI = EasySweep(\"g\", hmt, st0 ; path)\nEe, ste = EasySweep(\"e\", hmt, st0 ; path, proj = [\"g\"])\nEs, sts = EasySweep(\"s\", hmt, st1 ; path)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To measure the angular momentum L^2 of the ground state, we generate the MPO for L^2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = GetMPO(\"l2\", tms_l2, sites ; path, mpo_method = MyMPO)\nval_l2I = inner(stI', l2, stI)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, to measure the OPE coefficient f_sigmasigmaepsilon=langle sigman^x_00epsilonranglelangle sigman^x_000rangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obs_nx = GetDensityObs(nm, 2, sgx)\ntms_nx00 = SimplifyTerms(GetComponent(obs_nx, 0.0, 0.0))\nnx00 = GetMPO(\"nx00\", tms_nx00, sites ; path, mpo_method = MyMPO)\nf_sse = abs(inner(sts', nx00, ste) / inner(sts', nx00, stI))","category":"page"},{"location":"tutorial/#List-of-examples","page":"Tutorial","title":"List of examples","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We offer a series of other examples that reproduces various achievements of fuzzy sphere. For a more detailed summary of the background, see the Review of existing work. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ising_spectrum.jl calculates the spectrum of 3d Ising model on fuzzy sphere at N_m = 12. For each (PZR) sector, 20 states are calculated. This example reproduces Table I and Figure 4 in Zhu 2022.\nising_phase_diagram.jl calculates the phase diagram of fuzzy sphere Ising modelby calculating the order parameter langle M^2rangle. This example reproduces Figure 3 in Zhu 2022.\nising_ope.jl calculates various OPE coefficients at N_m = 12 by taking overlaps between CFT states and density operators and composite. This example reproduces Figure 2 and Table I in Hu 2023Mar.\nising_correlator.jl calculates the σσ two-point function on sphere and the σσσσ four-point function on sphere, 0 and . This example reproduces Figures 1c and 2a in Han 2023Jun.\nising_optimisation.jl defines a cost function as the square sum of the deviations of descendants and stress tensor to evaluate the conformal symmetry for Ising model and minimises this cost function to find the best parameter.\nising_full_spectrum.jl calculates the full spectrum of 3d Ising model on fuzzy sphere at N_m = 10 for sector (PZR) = (111).\nising_space_entangle.jl calculates the entanglement entropy of the Ising ground state along the real space cut of θ = 0500π and 0499π respectively, and use these two data to extract finite size F-function without sustracting the IQHE contribution. This example reproduces Figures 3 in Hu 2024.\nising_orbital_entangle.jl calculates the entanglement entropy of the Ising ground state along the orbital space cut at m = 0, and also the entanglement spectrum in the half-filled l_z = 0 1 and  both mathbbZ_2 sectors.\nising_generator.jl examines the quality of conformal symmetry at N_m = 12 by examining the matrix elements of conformal generators P^z + K^z and compare the states (P^z + K^z)Φ with the CFT expectations. This example reproduces Figure 7 in Fardelli 2024.\ndefect_spectrum.jl calculates the spectrum of magnetic line defect in 3d Ising model in l_z = 0 P = 1 and l_z = 1 sectors, calibrated by bulk T. This example reproduces Table I in Hu 2023Aug.\ndefect_correlator.jl calculates the 1-pt function σ and 2-pt function σhatϕ of magnetic line defect in 3d Ising model. The normalisation of the correlators require extra bulk data. This example reproduces Figure 4 in Hu 2023Aug.\ndefect_changing.jl calculates the spectrum of the defect creation and changing operators of the magnetic line defect in 3d Ising model. This example reproduces Table 2 and Figure 5 in Zhou 2024Jan.\ndefect_overlap.jl calculates the g-function of magnetic line defect in 3d Ising model using the ovelaps between the bulk, defect ground state and the lowest defect-creation state. This example reproduces Figure 6 in Zhou 2024Jan.\ncusp_dim.jl calculates the scaling dimension of the cusp of the magnetic line defect in 3d Ising model as a function of the angle θ. This example reproduces Table 2, upper panel in Cuomo 2024.\nsurface_ordinary_spectrum.jl calculates the spectrum of ordinary surface CFT in 3d Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figures 3 and 4 in Zhou 2024Jul.\nsurface_normal_spectrum.jl calculates the spectrum of normal surface CFT in 3d Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figure 5 in Zhou 2024Jul.\no3_wf_spectrum.jl calculates the spectrum of mathrmO(3) Wilson-Fisher CFT using the bilayer Heisenberg model. This example reproduces Table I and Figure 2 in Han 2023Dec.\nso5_spectrum.jl calculates the spectrum of SO(5) DQCP on fuzzy sphere. This example reproduces Table II in Zhou 2023.\nsp3_spectrum.jl calculates the spectrum of Sp(3) CFT on fuzzy sphere. This example reproduces Table I in Zhou 2024Oct.\nising_frac_fermion.jl calculates the spectrum of 3d Ising model on fuzzy sphere for fermions at fractional filling ν = 13. This example reproduces Figure 10 in Voinea 2024.\nising_frac_boson.jl calculates the spectrum of 3d Ising model on fuzzy sphere for bosons at fractional filling ν = 12 with the module Fuzzifino. This example reproduces Figure 12a,b in Voinea 2024.\nising_spectrum_krylov.jl calculates the spectrum of 3d Ising model on fuzzy sphere by calling the eigsolve function in KrylovKit.jl instead of Arpack.\nising_spectrum_cuda.jl calculates the spectrum of 3d Ising model on fuzzy sphere for one sector by performing the sparse matrix multiplication on CUDA.","category":"page"}]
}
