var documenterSearchIndex = {"docs":
[{"location":"itensors/#ITensor-Extension","page":"ITensor Extension","title":"ITensor Extension","text":"","category":"section"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"FuzzifiED also supports an ITensor extension, including convertion with the Site and OpSum objects from ITensor library and management of DMRG sweeping process. To use the extension, make sure the packages ITensors, ITensorMPS are properly installed, and include","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"using ITensors, ITensorMPS","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"at the heading of the Julia script. Also note that the ITensor package supports Julia at 1.10 the best.","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"During intialisation, the optimal configuration for parallelisation is already automatically set.","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"BLAS.set_num_threads(1);\nNDTensors.Strided.disable_threads();\nITensors.enable_threaded_blocksparse();","category":"page"},{"location":"itensors/#Format-Conversion","page":"ITensor Extension","title":"Format Conversion","text":"","category":"section"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"FuzzyfiED defines a new SityType \"FuzzyFermion\" that can be initialised from QNDiags to avoid overwriting the original \"Fermion\" type.","category":"page"},{"location":"itensors/#ITensors.space-Tuple{SiteType{FuzzyFermion}}","page":"ITensor Extension","title":"ITensors.space","text":"ITensors.space( :: SiteType\"FuzzyFermion\" ; o :: Int, qnd :: Vector{QNDiag})\n\nDefine a new site type \"FuzzyFermion\" which inherits all the features of ITensor type \"Fermion\". It can be initialised by a set of QNDiag's and the site index o.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"The Sites objects in ITensor can be converted to a QNDiags and Confs with the QNs extracted. ","category":"page"},{"location":"itensors/#FuzzifiED.GetQNDiags-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}}","page":"ITensor Extension","title":"FuzzifiED.GetQNDiags","text":"GetQNDiags(sites :: Vector{<:Index})\n\nConverts a Sites object in the ITensors package to a set of QNDiags. \n\nArguments\n\nsites :: Vector{<:Index} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.Confs-Tuple{Vector{Index{Vector{Pair{QN, Int64}}}}, QN}","page":"ITensor Extension","title":"FuzzifiED.Confs","text":"Confs(sites :: Vector{<:Index}, sec_qn :: QN)\nConfs(sites :: Vector{<:Index}, cf_ref :: Vector{Int64})\n\nConverts a Sites object in the ITensors package to the Confs object\n\nArguments\n\nsites :: Vector{<:Index} is a Sites object. Only Fermion site type is supported, and the quantum numbers of the 0 state must be all zero. Note that this will subject to the limitation in ITensors that the number of conserved quantities must be less than 4. \nsec_qn :: QN is a QN object that specifies the the quantum number of the selected configuration. Alternatively, cf_ref :: Vector{Int64} is a reference configuration composed of 0 and 1.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"Conversely, the  Sites objects in ITensors can also be generated from a set of diagonal quantum numbers ","category":"page"},{"location":"itensors/#FuzzifiED.GetSites-Tuple{Vector{QNDiag}}","page":"ITensor Extension","title":"FuzzifiED.GetSites","text":"GetSites(qnd :: Vector{QNDiag}) :: Vector{<:Index}\n\nreturns the ITensors Sites of type \"FuzzyFermion\" from a set of QNDiags.\n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"If the number of quantum numbers are too many, it can be truncated by ","category":"page"},{"location":"itensors/#FuzzifiED.TruncateQNDiag-Tuple{Vector{QNDiag}}","page":"ITensor Extension","title":"FuzzifiED.TruncateQNDiag","text":"TruncateQNDiag(qnd :: Vector{QNDiag} ; trunc_lth :: Int64, trunc_wt :: Vector{Int64}) :: Vector{QNDiag}\n\ntruncates the list of N_U QNDiags from to a number N_U acceptable by ITensors. The new quantum numbers are \n\nbeginaligned\n    Q_1=Q_1 Q_2=Q_2  Q_N_U-1=Q_N_U-1\n    Q_N_U=Î»_N_UQ_N_U+Î»_N_U+1Q_N_U+1++Î»_N_UQ_N_U\nendaligned\n\nArguments\n\nqnd :: Vector{QNDiag} stores the set of QNDiags. \ntrunc_lth :: Int64 stores the truncated numbers of QNDiags. Facultative, 3 by default. \ntrunc_wt :: Vecotr{Int64} stores the N_U-N_U+1 coefficients Î». Facultative, 1101001000 by default. \n\n\n\n\n\n","category":"method"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"The OpSum objects in ITensor can be converted with the collection of Term's","category":"page"},{"location":"itensors/#FuzzifiED.Terms-Tuple{Sum{Scaled{ComplexF64, Prod{Op}}}}","page":"ITensor Extension","title":"FuzzifiED.Terms","text":"Terms(opsum :: OpSum)\n\nConverts a OpSum object in ITensors to a series of terms. Note that the only operators supported are \"C\", \"Cdag\" \"N\" and \"I\".\n\n\n\n\n\n","category":"method"},{"location":"itensors/#ITensors.Ops.OpSum-Tuple{Vector{Term}}","page":"ITensor Extension","title":"ITensors.Ops.OpSum","text":"OpSum(tms :: Terms)\n\nConverts a series of terms to OpSum object in ITensors.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Easy-Sweep","page":"ITensor Extension","title":"Easy-Sweep","text":"","category":"section"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"This tool kit facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. This extension required the packages HDF5. We also recommand using the package ITensorMPOConstruction for the generation of Hamiltonian MPO, which can be installed by ","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"using Pkg ; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/#FuzzifiED.EasySweep-Tuple{String, MPO, MPS}","page":"ITensor Extension","title":"FuzzifiED.EasySweep","text":"EasySweep(id :: String, hmt :: MPO, st00 :: MPS ; path :: String, dim_list :: Vector{Int64}, proj :: Vector{String}, e_tol1 :: Float64, e_tol :: Float64, cutoff :: Vector{Float64}, maxdim0 :: Vector{Float64}, noise0 :: Vector{Float64}, noise :: Vector{Int64}, nsweeps :: Int64, weight :: Float64, observer :: AbstractObserver) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function automatically performs several rounds of DMRG sweeps with increasing bond dimensions. It first checks the file st_$(id).h5 in a specified repository. If the key st_fin exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process. For each round, it will try to access the results from the key st_d$(dim_i) in st_$(id).h5, where dim_i is either 0 representing the initial round, or an element of array dim_list. If the key exist, it will read the result ; otherwise it will perform the sweeps using SweepOne. For the initial round, it will take the initial state from st00, the maximal bond dimensions from maxdim0, noise from noise0 and record the results in the key E_d0 and st_d0 in st_$(id).h5. For each of the following round, it will take the result from the previous round as the initial state and perform nsweeps sweeps with the bond dimension dim_list[i]. Each round will be stopped if the energy difference is less than e_tol1. The entire process will be stopped if the energy difference between two rounds is less than e_tol or the bond dimension of the result is less than 0.9 times the maximal bond dimension. The projected states will be accessed from the files specified by proj. It will try to access first the states with the same bond dimension as the projected states. If such states do not exist, it will then access the final state. The resulting energy will be written into the key E_fin in the file st_$(id).h5, and the MPS written into st_fin. The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst00 :: MPS is an MPS specifying the initial state. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ndim_list :: Vector{Int64} is a list that specifies the maximal bond dimensions of each round of sweeps starting from the second round. Facultative, [1000,2000,3000,4000,5000,6000] by default\nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol1 :: Float64 specifies the energy tolerence as a criteria to end the round of sweeps for each round of sweeps. Facultative, 1E-6 by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the entire process. Facultative, 1E-7 by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim0 :: Vector{Int64} specifies the maximal bond dimensions of the first round of sweeps. Facultative, [10,20,50,100,200,500] by default. \nnoise0 :: Vector{Float64} specifies the noise of each sweep in the initial round and will be sent into DMRG. Facultative, [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7] by default. \nnoise :: Vector{Float64} specifies the noise of each sweep from the second round and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nnsweeps :: Int64 specifies the number of sweeps in each round from the second rounds. Facultative, 10 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep starting from the second round. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \ndmrg_options :: Dict specifies other options to be sent into DMRG. E.g., to specify write_when_maxdim_exceeds = 1000 and write_path = \"./tmp/\", one can put dmrg_options = Dict(:write_when_maxdim_exceeds => 1000, :write_path => \"./tmp/\").\nclear_previous :: Bool. If set true, the file st_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}","page":"ITensor Extension","title":"FuzzifiED.SweepOne","text":"SweepOne(id :: String, hmt :: MPO, st0 :: MPS, dim1 :: Int64 ; path :: String, cutoff :: Vector{Float64}, maxdim :: Vector{Int64}, nsweeps :: Int64, noise :: Vector{Float64}, proj :: Vector{String}, e_tol :: Float64, weight :: Float64, observer :: AbstractObserver, dmrg_options :: Dict, dmrg_options :: Dict) :: Tuple{Float64, MPS}\n\nFunction\n\nThis function performs one round of nsweeps sweeps. It first checks the file st_$(id).h5 in a specified repository. If the key st_d$(dim1) exists, it reads the energy and MPS from the file and return the energy and MPS, otherwise it will perform the DMRG process with the maximal bond dimension specified by maxdim if it exists, or dim1. The projected states will be read from the key st_d$(dim1) if it exists or st_fin in the file st_$(fi).h5 in the same repository for each string fi in the array proj. The sweeps will be ended if the energy difference is less than etol or whatever criteria is given in observer. The resulting energy will be written into the key E_d$(dim1) in the file st_$(id).h5, and the MPS written into st_d$(dim1). The function returns a tuple of energy and the final MPS. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\nhmt :: MPO is an MPO specifying the Hamiltonian.\nst0 :: MPS is an MPS specifying the initial state. \ndim1 :: Int64 is a bond dimension that will be used to identify the result. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \ncutoff :: Vector{Float64} is the cutoff that will be sent into DMRG. Facultative, [1.E-9] by default. \nmaxdim :: Vector{Int64} specifies the maximal bond dimension of each sweep. Facultative, [dim1] by default. \nnsweeps :: Int64 specifies the number of sweeps in the round. Facultative, 10 by default. \nnoise :: Vector{Float64} specifies the noise of each sweep and will be sent into DMRG. Facultative, [1E-6,1E-7,0] by default. \nproj :: Vector{String} specifies the name of the states that will be projected. Facultative, empty by default. \ne_tol :: Float64 specifies the energy tolerence as a criteria to end the sweeps. Facultative, 1E-6 by default. \nweight :: Float64 specifies the weight of projected states and will be sent into DMRG. Facultative, 100.0 by default.\nobserver :: AbstractObserver specifies the measurement and cutoff condition for each sweep. Facultative, by default the observer will print the energy and cutoff once the energy difference is less than e_tol at each sweep. \ndmrg_options :: Dict specifies other options to be sent into DMRG. E.g., to specify write_when_maxdim_exceeds = 1000 and write_path = \"./tmp/\", one can put dmrg_options = Dict(:write_when_maxdim_exceeds => 1000, :write_path => \"./tmp/\").\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{QNDiag}}","page":"ITensor Extension","title":"FuzzifiED.GetMPOSites","text":"GetMPOSites(id :: String, tms, qnd :: Vector{QNDiag} ; path :: String, qnu_o :: Vector{Vector{Int64}}, qnu_name :: Vector{String}, modul :: Vector{Int64}, mpo_method :: Function) :: Tuple{MPO, Vector{<:Index}}\n\nFunction\n\nThis function returns the MPO and sites for a given operator and a Hilbert space with given quantum numbers. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and sites and return the MPO and Sites. Otherwise it will first generates the sites with the quantum numbers given in qnd. Then it will generate the MPO with the terms of the operator given in tms. The MPO and sites will be written into the file op_$(id).h5 in the fields mpo and sites. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Terms or tms :: OpSum is either an array of terms or a OpSum objects that specifies the expression of the operator. \nqnd :: Vector{QNDiag} is a list of diagonal quantum numbers. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. N.b., MPO_new only applies to the cases that the operator do not carry charge under any of the quantum numbers.\nclear_previous :: Bool. If set true, the file op_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#FuzzifiED.GetMPO-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{<:Index}}","page":"ITensor Extension","title":"FuzzifiED.GetMPO","text":"GetMPO(id :: String, tms :: Union{Terms, OpSum}, sites :: Vector{<:Index} ; path :: String, mpo_method :: Function) :: MPO\n\nFunction\n\nThis function returns the MPO for a given operator and a given set of sites. It first checks the file op_$(id).h5 in a specified repository. If the file exists, it will try to read the fields mpo and return the MPO it has read. Otherwise it will generate the MPO with the terms of the operator given in tms. The MPO and Sites will be written into the file op_$(id).h5 in the fields mpo. \n\nArguments\n\nid :: String is a string identifying the file to which the results will be accessed and written.\ntms :: Terms or tms :: OpSum is either an array of terms or a OpSum objects that specifies the expression of the operator. \nsites :: Vector{<:Index} specifies the sites that the operator is acting on. \npath :: String identifies the path where the results will be accessed and stored. Facultative, ./ by default. \nmpo_method :: Function is a function mpo_method(os :: OpSum, sites :: Sites) :: MPO that generates the MPO from OpSum and Sites. Facultative, MPO by default. We suggest using MPO_new in ITensorMPOConstruction package. See example_ising_dmrg_easysweep.jl for example. N.b., MPO_new only applies to the cases that the operator do not carry charge under any of the quantum numbers.\nclear_previous :: Bool. If set true, the file op_$(id).h5 will be removed and the calculation will start from scratch. Facultative, false by default.\n\n\n\n\n\n","category":"method"},{"location":"itensors/#Modified-Version-of-ITensor","page":"ITensor Extension","title":"Modified Version of ITensor","text":"","category":"section"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"We have forked ITensors and made some modifications to better suit our need. To install the modified packages, please use ","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"using Pkg \nPkg.add(url=\"https://github.com/FuzzifiED/ITensors.jl.git\")\nPkg.add(url=\"https://github.com/FuzzifiED/ITensorMPS.jl.git\")\nPkg.add(url=\"https://github.com/FuzzifiED/ITensorMPOConstruction.jl.git\")","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"The modifications made include","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"Modify ITensors to allow up to 10 quantum numbers ; \nModify ITensorMPS to allow write_when_maxdim_exceeds in DMRG in the presence of projection matrices ;\nModify ITensorMPOConstruction to allow building MPOs that has symmetry flux ;\nModify ITensorMPOConstruction to allow compatibility with the newest version of ITensors.","category":"page"},{"location":"itensors/","page":"ITensor Extension","title":"ITensor Extension","text":"Please be warned that the robustness and the backward compatibility of these modifications are not warranted. ","category":"page"},{"location":"core/#Core-Functions","page":"Core Functions","title":"Core Functions","text":"","category":"section"},{"location":"core/#Environment-Parameters","page":"Core Functions","title":"Environment Parameters","text":"","category":"section"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The following environment parameters defines how FuzzifiED works, viz. whether it outputs logs, how many threads it uses and where it reads its libraries. In general, you can keep it at default. ","category":"page"},{"location":"core/#FuzzifiED.SilentStd","page":"Core Functions","title":"FuzzifiED.SilentStd","text":"FuzzifiED.SilentStd :: Bool = false\n\na flag to determine whether logs of the FuzzifiED functions should be turned off. False by default. If you want to evaluate without log, put FuzzifiED.SilentStd = true. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.NumThreads","page":"Core Functions","title":"FuzzifiED.NumThreads","text":"FuzzifiED.NumThreads :: Int = Threads.nthreads()\n\nan integer to define how many threads OpenMP uses. By default, it is the same as the number of threads in Julia. If you use Jupyter notebooks, which by default uses one core only, you may need to define this by hand, e. g., FuzzifiED.NumThreads = 8. This parameter can be defined for each process separately. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.Libpath","page":"Core Functions","title":"FuzzifiED.Libpath","text":"FuzzifiED.Libpath :: String = FuzzifiED_jll.LibpathFuzzifiED\n\ndefine path of the Fortran library libfuzzified.so. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"core/#FuzzifiED.ElementType","page":"Core Functions","title":"FuzzifiED.ElementType","text":"FuzzifiED.ElementType :: DataType = ComplexF64\n\nset the default type of the operator elements, either ComplexF64 or Float64. ComplexF64 by default. \n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.OpenHelp!-Tuple{}","page":"Core Functions","title":"FuzzifiED.OpenHelp!","text":"FuzzifiED.OpenHelp!()\n\nA shortcut to open the link for documentation docs.fuzzified.world in the system browser. \n\n\n\n\n\n","category":"method"},{"location":"core/#Quantum-Numbers","page":"Core Functions","title":"Quantum Numbers","text":"","category":"section"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"FuzzifiED implements diagonal and off-diagonal quantum numbers. They are defined as","category":"page"},{"location":"core/#FuzzifiED.QNDiag","page":"Core Functions","title":"FuzzifiED.QNDiag","text":"QNDiag\n\nThe mutable type QNDiag records the information of a diagonal mathrmU(1) or â„¤_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_oq_on_o\n\nor\n\nQ=_o=1^N_oq_on_o mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of site, n_o=c^_oc_o, and q_o is a set of coefficients that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number.\ncharge :: Vector{Int64} is the symmetry charge q_o of each site.\nmodul :: Int64 is the modulus p, set to 1 for mathrmU(1) QNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNDiag([name :: String, ]charge :: Vector{Int64}[, modul :: Int64])\n\nThe arguments name and modul are facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.QNOffd","page":"Core Functions","title":"FuzzifiED.QNOffd","text":"QNOffd\n\nThe mutable type QNOffd records the information of an off-diagonal â„¤_p quantum number in the form of a discrete transformation\n\nð’µ c_o Î±_o^* c^(p_o)_Ï€_oâ€ƒ c_o^ Î±_o c^(1-p_o)_Ï€_o\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, Ï€_o is a permutation of 1N_o, Î±_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\nperm :: Vector{Int64} is a length-N_o vector that records the permutation Ï€_o.\nph :: Vector{Int64} is a length-N_o vector that records p_o to determine whether or not to perform a particle-hole transformation.\nfac :: Vector{ComplexF64} is a length-N_o vector that records the factor Î±_o in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nQNOffd(perm :: Vector{Int64}[, ph :: Vector{Int64}][, fac :: Vector{ComplexF64}][, cyc :: Int64])\nQNOffd(perm :: Vector{Int64}, ph_q :: Bool[, fac :: Vector{ComplexF64}])\n\nThe arguments ph, fac and cyc are facultative. By default ph is set all 0, fac is set to all 1 and cyc is set to 2. If ph_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The QNDiag can be added or multiplied by a number ","category":"page"},{"location":"core/#Base.:+-Tuple{QNDiag, QNDiag}","page":"Core Functions","title":"Base.:+","text":"+(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag \n-(qnd1 :: QNDiag, qnd2 :: QNDiag) :: QNDiag\n\nreturns the sum or substraction of two QNDiags, whose name is the samea as qnd1, charge is the same as qnd1 Â± qnd2, and modulus is the GCD of qnd1 and qnd2. If qnd1 and qnd2 are both â„¤_p quantum numbers and their modulus are coprime, a trivial QNDiag will be returned. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Int64, QNDiag}","page":"Core Functions","title":"Base.:*","text":"*(fac :: Int64, qnd :: QNDiag) :: QNDiag \n*(qnd :: QNDiag, fac :: Int64) :: QNDiag \nÃ·(qnd :: QNDiag, fac :: Int64) :: QNDiag \n-(qnd :: QNDiag) :: QNDiag\n\nreturns the QNDiag multiplied or divided by an integer factor, where the charge is multiplied or integer-divided by the factor. For â„¤_p quantum numbers, their modulus will be multiplied or integer-divided by the absolute value. If qnd.modul Ã· abs(fac) â‰¤ 1, a trivial QNDiag will be returned.  \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The QNOffd can be composed","category":"page"},{"location":"core/#Base.:*-Tuple{QNOffd, QNOffd}","page":"Core Functions","title":"Base.:*","text":"*(qnf1 :: QNOffd, qnf2 :: QNOffd) :: QNOffd\n\nreturns the composition of two QNOffd transformations. The cycle is set to be the LCM of two QNOffds.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"Empty orbitals can be added to the left or right for QNDiag and QNOffd","category":"page"},{"location":"core/#FuzzifiED.PadQNDiag","page":"Core Functions","title":"FuzzifiED.PadQNDiag","text":"PadQNDiag(qnd :: QNDiag, nol :: Int64, nor :: Int64)\n\nadds nol empty orbitals to the left and nor empty orbitals to the right, implemented as \n\nQNDiag(qnd.name, [ fill(0, nol) ; qnd.charge ; fill(0, nor) ], qnd.modul)\n\n\n\n\n\n","category":"function"},{"location":"core/#FuzzifiED.PadQNOffd","page":"Core Functions","title":"FuzzifiED.PadQNOffd","text":"PadQNOffd(qnf :: QNOffd, nol :: Int64, nor :: Int64)\n\nadds nol empty orbitals to the left and nor empty orbitals to the right, implemented as \n\nQNOffd(\n    [ collect(1 : nol) ; qnf.perm .+ nol ; collect(1 : nor) .+ (nol + length(qnf.perm)) ], \n    [ fill(0, nol) ; qnf.ph ; fill(0, nor) ], \n    [ fill(ComplexF64(1), nol) ; qnf.fac ; fill(ComplexF64(1), nor) ], qnf.cyc)\n\n\n\n\n\n","category":"function"},{"location":"core/#Configurations","page":"Core Functions","title":"Configurations","text":"","category":"section"},{"location":"core/#FuzzifiED.Confs","page":"Core Functions","title":"FuzzifiED.Confs","text":"Confs\n\nThe mutable type Confs stores all the configurations that respects the diagonal quantum numbers (QNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nno :: Int64 is the number of sites.\nncf :: Int64 is the number of configurations.\nconf :: Vector{Int64} is an array of length ncf containing all the configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \nnor :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"It can be generated from the QNDiags.","category":"page"},{"location":"core/#FuzzifiED.Confs-Tuple{Int64, Vector{Int64}, Vector{QNDiag}}","page":"Core Functions","title":"FuzzifiED.Confs","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag} ; nor :: Int64 = div(no, 2), num_th :: Int64, disp_std :: Bool)\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nno :: Int64 is the number of sites N_o.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{QNDiag} is the set of QNDiags.\nnor :: Int64 is the number of less significant bits used to generate the Lin table. Facultative, N_o2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: Confs is a Confs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the number of electrons.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The inverse look-back for a configuration can be done by ","category":"page"},{"location":"core/#FuzzifiED.GetConfId-Tuple{Confs, Int64}","page":"Core Functions","title":"FuzzifiED.GetConfId","text":"GetConfId(cfs :: Confs, cf :: Int64) :: Int64\n\ninversely look up the index from the configuration\n\nArguments\n\ncfs :: Confs stores the configurations.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \n\nOutput\n\nid :: Int64 is the id of the configuration such that cfs.conf[id] == cf.\n\n\n\n\n\n","category":"method"},{"location":"core/#Basis","page":"Core Functions","title":"Basis","text":"","category":"section"},{"location":"core/#FuzzifiED.Basis","page":"Core Functions","title":"FuzzifiED.Basis","text":"Basis\n\nThe mutable type Basis stores the information of the basis that respects both diagonal and off-diagonal quantum numbers. The states in the basis is in the form \n\nI=Î»_i_I1i_I1+Î»_i_I2i_I2++Î»_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i. e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: Confs stores the configurations that respect the QNDiags.\ndim :: Int64 is the dimension of the basis.\nszz :: Int64 records the maximum size max m_I of groups.\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to.\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients Î»_i of each configuration.\ngrel :: Matrix{Int64} is a szzÃ—dim matrix that records the configurations in each group i_Ik (k = 1m_I).\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/#FuzzifiED.Basis-Tuple{Confs, Vector{ComplexF64}, Vector{QNOffd}}","page":"Core Functions","title":"FuzzifiED.Basis","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd} ; num_th :: Int64, disp_std :: Bool)\n\ngenerates the basis that respects the off-diagonal â„¤_p quantum numbers (QNOffd)\n\nArguments\n\ncfs :: Confs is the diagonal QNâ€“preserving configurations.\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector.\nqnf :: Vector{QNOffd} is a vector of off-diagonal quantum numbers.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: Basis is the resulting Basis object.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.Basis-Tuple{Confs}","page":"Core Functions","title":"FuzzifiED.Basis","text":"Basis(cfs :: Confs)\n\nGenerate a basis from the configurations without off-diagonal â„¤_n symmetries.\n\nArguments\n\ncfs :: Confs is the diagonal QNâ€“preserving configurations.\n\nOutput\n\nbs :: Basis is the resulting Basis object.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The look-back of the weight of a configuration in a state can be done by ","category":"page"},{"location":"core/#FuzzifiED.GetConfWeight-Tuple{Basis, Union{Vector{ComplexF64}, Vector{Float64}}, Int64}","page":"Core Functions","title":"FuzzifiED.GetConfWeight","text":"GetConfWeight(bs :: Basis, st :: Vector{<:Number}, cf :: Int64) :: ComplexF64\n\nlooks up a the weight of a configuration in a state. \n\nArguments\n\nbs :: Basis is the basis of the state.\nst :: Vector{ComplexF64} or st :: Vector{Float64} is a vector of length bs.dim that stores the state.\ncf :: Int64 stores the configuration to be looked-up expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \n\nOutput\n\nThe weight of the configuration in the state.\n\n\n\n\n\n","category":"method"},{"location":"core/#Term","page":"Core Functions","title":"Term","text":"","category":"section"},{"location":"core/#FuzzifiED.Term","page":"Core Functions","title":"FuzzifiED.Term","text":"Term\n\nThe mutable type Term records a term that looks like Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l in an operator\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U.\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string.\n\nInitialisation\n\nIt can be generated by the function\n\nTerm(coeff :: Number, cstr :: Vector{Int64})\n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.Terms","page":"Core Functions","title":"FuzzifiED.Terms","text":"Terms\n\nTerms is an alias for Vector{Term} for convenience\n\nInitialisation\n\nTerms(coeff :: Number, cstr :: Vector{Int64})\n\nGives a Terms with a single Term.\n\nSpecial elements\n\nThe zero and identity terms are defined.\n\nzero(Terms) = Term[]\none(Terms) = Terms(1, [-1, -1])\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"core/#Base.:*-Tuple{Number, Vector{Term}}","page":"Core Functions","title":"Base.:*","text":"*(fac :: Number, tms :: Terms) :: Terms\n-(tms :: Terms) :: Terms\n*(tms :: Terms, fac :: Number) :: Terms\n/(tms :: Terms, fac :: Number) :: Terms\n\nReturn the product of a collection of terms with a number. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:+-Tuple{Vector{Term}, Vector{Term}}","page":"Core Functions","title":"Base.:+","text":"+(tms1 :: Terms, tms2 :: Terms) :: Terms\n-(tms1 :: Terms, tms2 :: Terms) :: Terms\n\nReturn the naive sum of two series of terms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Vector{Term}, Vector{Term}}","page":"Core Functions","title":"Base.:*","text":"*(tms1 :: Terms, tms2 :: Terms) :: Terms\n^(tms :: Terms, pow :: Int64) :: Terms\n\nReturn the naive product of two series of terms or the power of one terms. The number of terms equals the product of the number of terms in tms1 and tms2. For each term in tms1 Uc^(p_1)_o_1 and tms2 Uc^(p_1)_o_1, a new term is formed by taking UUc^(p_1)_o_1 c^(p_1)_o_1.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.adjoint-Tuple{Vector{Term}}","page":"Core Functions","title":"Base.adjoint","text":"adjoint(tm :: Term) :: Term\nadjoint(tms :: Terms) :: Terms\n\nReturn the Hermitian conjugate of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the adjoint is barUc^(1-p_l)_o_l c^(1-p_2)_o_2c^(1-p_1)_o_1.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.ParticleHole-Tuple{Vector{Term}}","page":"Core Functions","title":"FuzzifiED.ParticleHole","text":"ParticleHole(tm :: Term) :: Term\nParticleHole(tms :: Terms) :: Terms\n\nReturn the particle-hole transformation of a series of terms. For each term Uc^(p_1)_o_1c^(p_2)_o_2 c^(p_l)_o_l, the transformation results in Uc^(1-p_1)_o_1c^(1-p_2)_o_2c^(1-p_l)_o_l.\n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The terms can be simplified by ","category":"page"},{"location":"core/#FuzzifiED.NormalOrder-Tuple{Term}","page":"Core Functions","title":"FuzzifiED.NormalOrder","text":"NormalOrder(tm :: Term) :: Terms\n\nrearrange a term such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe site index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of terms whose result is equal to the original term. \n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}","page":"Core Functions","title":"FuzzifiED.SimplifyTerms","text":"SimplifyTerms(tms :: Terms ; cutoff :: Float64 = eps(Float64)) :: Terms\n\nsimplifies the sum of terms such that \n\neach term is normal ordered,\nlike terms are combined, and terms with zero coefficients are removed.\n\nArgument\n\ncutoff :: Float64 is the cutoff such that terms with smaller absolute value of coefficients will be neglected. Facultative, eps(Float64) by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"We allow the removal or relabelling of orbitals by ","category":"page"},{"location":"core/#FuzzifiED.RemoveOrbs-Tuple{Vector{Term}, Vector{Int64}}","page":"Core Functions","title":"FuzzifiED.RemoveOrbs","text":"RemoveOrbs(tms :: Terms, o_rm :: Vector{Int64}) :: Terms\n\nremove all the terms that has creation or annihilation operators of sites in the set o_rm.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.RelabelOrbs-Tuple{Vector{Term}, Dict{Int64, Int64}}","page":"Core Functions","title":"FuzzifiED.RelabelOrbs","text":"RelabelOrbs(tms :: Terms, dict_o :: Dict{Int64, Int64})\n\nRelabel all the orbitals. Terms that has operators on the sites that are not in the keys of dict_o are removed. \n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.PadTerms","page":"Core Functions","title":"FuzzifiED.PadTerms","text":"PadTerms(tms :: Terms, nol :: Int64)\n\nadds nol empty orbitals to the left by shifting each orbital index.\n\n\n\n\n\n","category":"function"},{"location":"core/#Operator","page":"Core Functions","title":"Operator","text":"","category":"section"},{"location":"core/#FuzzifiED.Operator","page":"Core Functions","title":"FuzzifiED.Operator","text":"Operator\n\nThe mutable type Operator records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0.\nntm :: Int64 is the number of terms.\nnc :: Int64 is the maximum number of operators in an operator string.\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/#FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}","page":"Core Functions","title":"FuzzifiED.Operator","text":"Operator(bsd :: Basis[, bsf :: Basis], terms :: Terms ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool)\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: Terms records the terms.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/#Base.:*-Tuple{Operator, Vector{ComplexF64}}","page":"Core Functions","title":"Base.:*","text":"*(op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\n*(op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, Operator, Vector{ComplexF64}}","page":"Core Functions","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: Operator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: Operator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Sparse-Matrix","page":"Core Functions","title":"Sparse Matrix","text":"","category":"section"},{"location":"core/#FuzzifiED.OpMat","page":"Core Functions","title":"FuzzifiED.OpMat","text":"OpMat{ComplexF64}\nOpMat{Float64}\n\nThe mutable type OpMat{T} where the element type T can be Float64 and ComplexF64 stores a sparse matrix in the same form as SparseMatrixCSC in SparseArrays. If the matrix is Hermitian or symmetric, only the lower triangle is stored. \n\nFields\n\ndimd :: Int64 and dimf :: Int64 are the number of columns and rows of the matrix.\nsymq :: Int64 records whether or not the matrix is Hermitian or symmetric.\nnel :: Int64 records the number of elements.\ncolptr :: Vector{Int64}, rowid :: Vector{Int64} and elval :: Vector{ComplexF64} records the elements of the sparse matrix as in the SparseMatrixCSC elements of Julia. \n\n\n\n\n\n","category":"type"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"It can be generated by the following methods.","category":"page"},{"location":"core/#FuzzifiED.OpMat-Tuple{Operator}","page":"Core Functions","title":"FuzzifiED.OpMat","text":"OpMat[{T}](op :: Operator ; num_th :: Int64, disp_std :: Bool)\n\nGenerates the sparse matrix from the operator. The parametric type T is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: Operator is the operator.\nT :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The lowest eigenstates of the sparse matrix can be calculated by ","category":"page"},{"location":"core/#FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}","page":"Core Functions","title":"FuzzifiED.GetEigensystem","text":"GetEigensystem(mat :: OpMat{ComplexF64}, nst :: Int64 ; tol :: Float64, ncv :: Int64, initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nGetEigensystem(mat :: OpMat{Float64}, nst :: Int64 ; tol :: Float64, ncv :: Int64, initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\ncalls the Arpack package to calculate the lowest eigenstates of sparse matrix. \n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix.\nnst :: Int64 is the number of eigenstates to be calculated.\ntol :: Float64 is the tolerence for the Arpack process. The default value is 1E-8.\nncv :: Int64 is an auxiliary parameter needed in the Arpack process. The default value is max(2 * nst, nst + 10).\ninitvec :: Vector{ComplexF64} or initvec :: Vector{Float64} is the initial vector. If empty, a random initialisation shall be used. Facultative, empty by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimdÃ—nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"core/#Base.:*-Tuple{OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core Functions","title":"Base.:*","text":"*(mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: Vector{ComplexF64}\n*(mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Vector{Float64}\n\nMeasure the action of a sparse matrix on a state. st_d must be of length mat.dimd. Returns a vector of length mat.dimf that represents the final state. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, OpMat{ComplexF64}, Vector{ComplexF64}}","page":"Core Functions","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, mat :: OpMat{ComplexF64}, st_d :: Vector{ComplexF64} ; num_th :: Int64) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, mat :: OpMat{Float64}, st_d :: Vector{Float64} ; num_th :: Int64) :: Float64\n\nMeasuring the inner product between two states and a sparse matrix. st_d must be of length mat.dimd and st_fp must be of length mat.dimf, and st_fp must be an adjoint. \n\nFacultative argument\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"Note that sometimes it is needed to transform a state from one basis to another. This can be done by constructing an identity operator. ","category":"page"},{"location":"core/","page":"Core Functions","title":"Core Functions","text":"stf = Operator(bsd, bsf, one(Terms)) * std","category":"page"},{"location":"core/#Transformation","page":"Core Functions","title":"Transformation","text":"","category":"section"},{"location":"core/#FuzzifiED.Transf","page":"Core Functions","title":"FuzzifiED.Transf","text":"Transf\n\nThe mutable type Transf records a transformation in the same form as a QNOffd\n\nð’µ c_o Î±_o^* c^(p_o)_Ï€_oâ€ƒ c_o^ Î±_o c^(1-p_o)_Ï€_o\n\ntogether with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state.\nperm :: Vector{Int64}, ph :: Vector{Int64} and fac :: Vector{ComplexF64} records the transformation in the same form as a QNOffd.\n\n\n\n\n\n","category":"type"},{"location":"core/#FuzzifiED.Transf-Tuple{Basis, Basis, QNOffd}","page":"Core Functions","title":"FuzzifiED.Transf","text":"Transf(bsd :: Basis[, bsf :: Basis], qnf :: QNOffd)\n\ngenerates a transformation object from a QNOffd. \n\nArguments\n\nbsd :: Basis is the basis of the initial state.\nbsf :: Basis is the basis of the final state. Facultative, the same as bsd by default.\nqnf :: QNOffd records the transformation.\n\n\n\n\n\n","category":"method"},{"location":"core/#Base.:*-Tuple{Transf, Vector{ComplexF64}}","page":"Core Functions","title":"Base.:*","text":"*(trs :: Transf, st_d :: Vector{ComplexF64} ; num_th = NumThreads) :: Vector{ComplexF64}\n*(trs :: Transf, st_d :: Vector{Float64} ; num_th = NumThreads) :: Vector{Float64}\n\nAct a transformation on a state. st_d must be of length trs.bsd.dim. Returns a vector of length trs.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"core/#Entanglement","page":"Core Functions","title":"Entanglement","text":"","category":"section"},{"location":"core/#FuzzifiED.StateDecompMat-Tuple{Vector{<:Number}, Basis, Basis, Basis, Vector{<:Number}, Vector{<:Number}}","page":"Core Functions","title":"FuzzifiED.StateDecompMat","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: Basis, bsa :: Basis, bsb :: Basis, amp_oa :: Vector{ComplexF64}, amp_ob :: Vector{ComplexF64}) :: Matrix{ComplexF64}\n\nDecompose a state Ïˆ=v_II into a direct-product basis of two subsystems Ïˆ=M_JII_AJ_B\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nbsa :: Basis is the basis for the subsystem A.\nbsb :: Basis is the basis for the subsystem B. \namp_oa :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem A. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to â„±_mA in PRB 85, 125308 (2012) with an extra phase factor. \namp_ob :: Vector{ComplexF64} is a complex list of length no that specifies the amplitute of each orbital in the subsystem B. \n\nOutput\n\nA complex matrix of dimension bsb.dim * bsa.dim that corresponds to the state in the decomposed basis Ïˆ=M_JII_AJ_B. This is equivalent to R_Î¼Î½^Ap in PRB 85, 125308 (2012). After calculating all the sectors, the reduced density matrix will be Ï_B=ðŒðŒ^.\n\n\n\n\n\n","category":"method"},{"location":"core/#FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, Basis, Vector{Vector{Vector{Int64}}}, Vector{Vector{Vector{Int64}}}}","page":"Core Functions","title":"FuzzifiED.GetEntSpec","text":"GetEntSpec(st :: Vector{<:Number}, bs0 :: Basis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{secd_a, secf_a, secd_b, secf_b}, Vector{Float64}}\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: Basis is the total basis. \nsecd_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNDiag sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nsecf_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNOffd sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nqnd_a :: Vector{QNDiag}, qnd_b :: Vector{QNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} specifies the diagonal and off-diagonal quantum numbers of the subsystems A and B. qnd_b and qnf_b are facultative and the same as qnd_a and qnf_a by default. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to â„±_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries secd_a, secf_a, secd_b, secf_b and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"intro/#An-Introduction-to-the-Fuzzy-Sphere","page":"Introduction","title":"An Introduction to the Fuzzy Sphere","text":"","category":"section"},{"location":"intro/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"intro/#Conformal-Field-Theory","page":"Introduction","title":"Conformal Field Theory","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conformal field theory (CFT) is one of the central topics of modern physics. It refers to a field theory that is invariant under conformal transformations that preserve the angles between vectors. In spacetime dimension d2, the global conformal symmetry transformations form a group mathrmSO(d+11), generated by translation, mathrmSO(d) rotation (Here we work in Euclidean signature. In Lorentzian signature it is the Lorentz transformation mathrmSO(1d-1)), dilatation (scale transformation), and special conformal transformation (SCT) Each CFT operator must transform under irreducible representations of rotation and dilatation. The representations are labelled by the mathrmSO(d) spin l and scaling dimension Delta, respectively. A special kind of operators that are invariant under SCT, called â€œprimaries,â€ deserve particular attention. By acting spatial derivatives on the primaries, their â€œdescendantsâ€ are obtained. Each operator in CFT is a linear combination of primaries and descendants. The conformal symmetry is the maximal spacetime symmetry (except supersymmetry) that a field theory can have. It gives powerful constraints on the property of the field theory. In particular, conformal symmetry uniquely determines the form of two-point (2-pt) and three-point (3-pt) correlation functions. The 3-pt correlator of three primary operators Phi_iPhi_jPhi_k contains a universal coefficient called the OPE coefficient f_Phi_iPhi_jPhi_k. The collection of scaling dimensions and the OPE coefficients of primaries Delta_Phi_if_Phi_iPhi_jPhi_k is called the conformal data. Theoretically, with full knowledge of the CFT data, an arbitrary correlation function of a CFT can be obtained. (The full knowledge is not often possible in practice, as the number of primaries is often infinite.)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CFT has provided important insights into various aspects of theoretical physics. In condensed matter physics, it has produced useful predictions about the critical phenomena. Many classical and quantum phase transitions are conjectured to have emergent conformal symmetry in the infrared (IR), i. e. at long wavelength or low energy. The universal critical exponents are directly determined by the scaling dimensions of the primary operators. E. g., in the 3D Ising transition that spontaneously breaks mathbbZ_2 symmetry, most critical exponents are given by the scaling dimensions of the lowest mathbbZ_2-odd operator sigma and mathbbZ_2-even operator epsilon, such as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    eta=2Delta_sigma-1qquadnu=frac13-Delta_epsilon","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"CFT is also closely related to string theory and quantum gravity in high-energy physics. In the string theory, CFT describes the 2D worldsheet ; in quantum gravity, there is a conjectured duality between the gravity theory in (d+1)-dimensional anti-de Sitter (AdS) space in the bulk and a d-dimensional CFT on the boundary. Moreover, CFT plays an important role in our understanding of quantum field theories. It describes many fixed points in the RG flow, and many QFTs can be seen as CFTs with perturbations. It also helps us understand how physics changes under a change of scale and reveals some fundamental structures of the RG flow.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In 2D CFTs, besides the global conformal symmetry mathrmSO(31), there also exists an infinite-dimensional local conformal symmetry. Altogether, they form the Virasoro algebra. The infinite-dimensional conformal algebra has made many theories exactly solvable, especially the rational theories such as the minimal models and, more generally, the Wess-Zumino-Witten (WZW) theories. However, going to the higher dimensions, the CFTs are much less well-studied due to a much smaller conformal group. The existing methods include numerical conformal bootstrap and Monte Carlo lattice simulations. Numerical bootstrap bounds the conformal data by making use of consistency conditions such as reflection positivity and crossing symmetry, together with some information of the CFT such as the global symmetry and a certain amount of assumptions. It has achieved great success in 3D Ising, mathrmO(N) Wilson-Fisher, Gross-Neveu-Yukawa CFTs, etc. On the other hand, one can study a CFT by constructing a lattice model that goes through a phase transition in the corresponding universality class, and study the phase transition by Monte Carlo simulation. This method has achieved success in many phase transitions assuming conformal symmetry, e. g. the 3D Ising model. However, the extraction of universal data usually involves complicated and expensive finite-size scaling, and only the lowest few CFT operators can be accessed.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Among these higher dimensional CFTs, we mainly focus on d=3, as many Lagrangians in dge 4 flow to free theories.","category":"page"},{"location":"intro/#Fuzzy-Sphere","page":"Introduction","title":"Fuzzy Sphere","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In addition to these existing approaches, the â€œfuzzy sphere regularisationâ€ has recently emerged as a new powerful method to study 3D CFTs. It involves studying interacting electrons moving on a sphere under the influence of a magnetic monopole at its centre.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The idea begins with putting an interacting quantum Hamiltonian on a 2-sphere S^2. This geometry preserves the full rotation symmetry (on the contrary, lattice models often only preserve a discrete subgroup). Moreover, when the system is tuned to a critical point or critical phase, combined with the time evolution direction, the system is described by a quantum field theory living on a generalised cylinder S^2timesmathbbR, a manifold that is conformally equivalent to flat spacetime through the Weyl transformation","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    (mathbfrtau)in S^2timesmathbbR longmapsto e^tauRhatmathbfninmathbbR^3","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where R is the radius of the sphere and hatmathbfn is the unit vector corresponding to mathbfr. This conformal transformation maps each time slice of the cylinder to a concentric sphere in the flat spacetime.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Thanks to the conformal flatness that is not owned by other manifolds (e. g., a lattice model with periodic boundary condition lives on the torus T^2, which is not conformally flat), we can make use of some nice properties of conformal field theories. The most important one is the state-operator correspondance. Specifically, there is a one-to-one correspondence between the eigenstates of the critical Hamiltonian on the sphere and the CFT operators. One can colloquially understand the state Phirangle as the insertion of the corresponding operator Phi(0) at the origin point into the vacuum 0rangle : Phirangle=hatPhi(0)0rangle. The state and its corresponding operator have the same mathrmSO(3) spin and representation under global symmetry. More importantly, as the Weyl transformation maps the Hamiltonian H that generates the time translation on the cylinder to the dilatation D on the flat spacetime, the excitation energy of a state Phirangle is proportional to the scaling dimension of the corresponding operator Delta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_Phi-E_0=fracvRDelta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where E_0 is the ground state energy, R is the radius of the sphere, and v is the speed of light that is dependent on the microscopic model and is the same for every state. With this property, one can calculate the scaling dimensions simply by solving the energy spectrum of the quantum Hamiltonian without doing complicated finite-size scalings, and one can obtain the OPE coefficients simply by taking the inner product of a local operator.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Although the quantum Hamiltonians on a sphere enjoy the full rotation symmetry and the property of state-operator correspondence, it is difficult to put a lattice on the sphere due to the curvature (in particular the non-zero Euler characteristic), especially to recover an mathrmSO(3)-symmetric thermodynamic limit. An alternative way is to fuzzify the sphere. We consider charged free particles moving on a sphere with a magnetic monopole with a flux 4pi s (sinmathbbZ2) placed at its centre. The monopole exerts a uniform magnetic field on the sphere, which modifies the single-particle Hamiltonian and the single-particle eigenstates. Now, the single particle eigenstates form highly degenerate spherical Landau levels. The lowest Landau level has a degeneracy (2s+1). By setting the single-particle gap to be the leading energy scale, and projecting onto the lowest Landau level, we obtain a finite Hilbert space. For the purpose of numerical simulation, the system is analogous to a length-(2s+1) chain with long-range interaction, where different Landau level orbitals behave like the lattice sites. The difference is that the (2s+1) orbital forms a spin-s representation of the mathrmSO(3) rotation group, and in this way, the continuous rotation symmetry is preserved. By putting multiple flavours on an orbital and adding interactions, various 3D CFTs can be realised. The interaction Hamiltonians are designed through matching the global symmetry and phase diagram. The word â€œfuzzyâ€ means the non-commutativity, in our case, due to the presence of magnetic field. The non-commutativity provides a natural length scale which serves as a UV regulator of the quantum field theory. The radius of the sphere scales as Rsimsqrt s. The thermodynamic limit can be taken as stoinfty, and we then recover a regular sphere without non-commutativity.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The power of this approach has been first demonstrated in the context of the 3D Ising transition, where the presence of emergent conformal symmetry has been convincingly established, and a wealth of conformal data has been accurately computed. The study has then been extended to accessing various conformal data such as the OPE coefficients, correlation functions, entropic F-function, conformal generators and the cross-cap coefficients, developing techniques to improve the numerical precision, such as quantum Monte Carlo, conformal perturbation and the finite-size scaling of the ground-state energy, realising various 3D CFTs such as the free scalar, Wilson-Fisher CFTs, the mathrmSO(5) and mathrmO(4) deconfined criticality, mathrmSp(N)-symmetric CFTs, multi-flavour mathrmSU(2) QCD, 3-state Potts model and Yang-Lee non-unitary CFT, exploring fractional quantum Hall transitions, such as the Ising CFT on the FQHE states, the confinement transition of the nu=12 bosonic Laughlin state, the free Marjorana fermion theory, and the transition between bosonic Pfaffian and the Halperin 220 state, studying conformal defects and boundaries such as the magnetic line defect, various conformal boundaries in the 3D Ising CFT, and lower-dimensional CFTs like 2D Ising on the fuzzy circle. In the following sections, we shall review the existing works, technical details and numerical methods. ","category":"page"},{"location":"intro/#Review-of-Existing-Works","page":"Introduction","title":"Review of Existing Works","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this section, we review the existing works related to the fuzzy sphere.","category":"page"},{"location":"intro/#Zhu2022","page":"Introduction","title":"The pioneering work","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhu 2022] Uncovering conformal symmetry in the 3d Ising transition : state-operator correspondence from a quantum fuzzy sphere regularisation, Wei Zhu, Chao Han, Emilie Huffman, Johannes S. Hofmann, and Yin-Chen He, arXiv:2210.13482, Phys. Rev. X 13, 021009 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work first proposes the idea of the fuzzy sphere and applies it to a pedagogical example of the 3D Ising CFT. Zhu et al. construct a model with two flavours of fermions that resemble the spin-up and spin-down in the lattice transverse-field Ising model. At half-filling, one can colloquially think that a spin degree of freedom lives on each orbital. The Hamiltonian contains a density-density interaction (here the density operator refers to a local fermion bilinear) that resembles the Ising ferromagnetic interaction and a polarising term that resembles the transverse field. By tuning the ratio between the two terms, a transition between quantum Hall ferromagnet (a two-fold degenerate state where either of the two flavours is completely occupied) and paramagnet (a one-fold degenerate state where the superposition of the two flavours at each orbital is occupied) occurs. This transition spontaneously breaks a mathbbZ_2 symmetry and falls into the Ising criticality. They then make use of a unique feature of spherical models described by CFT â€” state-operator correspondence â€” at the critical point to extract the scaling dimensions of the scaling local operators. They find evidence for the conformal symmetry, including that (1) there exists a conserved stress tensor with Delta=3 (which is used as the calibrator), and (2) all the levels can be classified into conformal multiplet where the spacings between operators' scaling dimensions are very close to integer. This is one of the first numerical evidence that the 3D Ising transition has emergent conformal symmetry. More remarkably, the scaling dimensions of primaries such as sigmaepsilonepsilon are already very close to the most accurate known value by numerical bootstrap with an error within 12 at a small system size with the number of orbitals N_m=16, for which the computational cost is comparable to a 4times4 lattice system. The structure of the Ising CFT operator spectrum already starts to show up at an even smaller system size N_m=4. All these clues point towards a curious observation that the fuzzy sphere suffers from a remarkably small finite-size effect. The detail for the construction of models is presented in the Sections â€œDensity-Density Interactionâ€ and â€œInteraction in Terms of Pseudo-Potentialsâ€, and the detail for the analysis of the spectrum is presented in Section â€œOperator Spectrum and Search for Conformal Pointâ€.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This seminal work opens a new avenue for studying 3D conformal field theories. After that, most of the research on the fuzzy sphere can roughly be categorised into the following directions :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Accessing various conformal data,\nDeveloping techniques to improve the numerical precision,\nRealising various 3D CFTs, \nExploring fractional quantum Hall transitions and\nStudying conformal defects and boundaries.","category":"page"},{"location":"intro/#Accessing-Various-Conformal-Data","page":"Introduction","title":"Accessing Various Conformal Data","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first direction is to develop methods to calculate various universal data of 3D CFTs on the fuzzy sphere. Typically, these methods are tested with the simplest example of the 3D Ising CFT. For many of those CFT data, the fuzzy sphere is the first non-perturbative method to access them ; for the others, the fuzzy sphere has achieved great consistency with previous methods such as quantum Monte Carlo and conformal bootstrap. So far, the accessible CFT data include operator spectrum, OPE coefficients, correlation functions, entropic F-function, conformal generators, the cross-cap coefficients. ","category":"page"},{"location":"intro/#Hu2023Mar","page":"Introduction","title":"OPE coefficients","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hu 2023Mar] Operator product expansion coefficients of the 3d Ising criticality via quantum fuzzy sphere, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2303.08844, Phys. Rev. Lett 131, 031601 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from the operator spectrum, a wealth of CFT data can be obtained from the local operators. This work studies the local observables on the fuzzy sphere, including the density operators and certain four-fermion operators. These observables can be expressed as the linear combination of local scaling operators in the CFT. After a finite-size scaling with the data from different system sizes, the subleading contribution can be subtracted, and only the leading contribution is left. In this way, the lowest primaries in Ising CFT in each symmetry sector, viz. the mathbbZ_2-odd sigma and the mathbbZ_2-even epsilon, can be realised. The OPE coefficients are then evaluated by taking the inner product of a fuzzy sphere local observable with two CFT states langlePhi_1Phi_2(mathbfr)Phi_3rangle. Hu et al. compute 17 OPE coefficients of low-lying CFT primary fields with high accuracy, including four that have not been reported before. The rest are consistent with numerical bootstrap results. It is also worth noting that this work starts to apply DMRG to the fuzzy sphere. The maximal system size is increased from N_m=18 by ED to N_m=48 by DMRG. The detail for calculating the OPE coefficient is presented in Section â€œLocal Observablesâ€.","category":"page"},{"location":"intro/#Han2023Jun","page":"Introduction","title":"Correlation functions","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Han 2023Jun] Conformal four-point correlators of the 3d Ising transition via the quantum fuzzy sphere, Chao Han, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.04681, Phys. Rev. B 108, 235123 (2023).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In addition to the OPE coefficients, the local observables can also be used to calculate correlation functions. By taking the inner product of two local observables (density operators) at a time displacement langlePhi_1Phi_2(mathbfr_0)Phi_3(mathbfrtau)Phi_4rangle with two CFT states, a general 4-pt function can be calculated. In practice, this piece of CFT data cannot be derived from the scaling dimensions and the OPEs due to the existence of infinitely many primaries. Han et al. calculate the 4-pt functions in the 3D Ising CFT with DMRG. A non-trivial check of conformality, the crossing symmetry, is verified for the correlator langlesigmasigmasigmasigmarangle. The special case â€” 2-pt functions by taking Phi_1=Phi_4=mathbbI â€” is also studied and compared with the expected results by conformal symmetry. The detail for calculating the correlation functions is presented in the Section â€œLocal Observablesâ€.","category":"page"},{"location":"intro/#Hu2024","page":"Introduction","title":"Entropic F-function","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hu 2024] Entropic F-function of 3d Ising conformal field theory via the fuzzy sphere regularisation, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2401.17362, Phys. Rev. B 111, 155151 (2025).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Beyond the correlators of local operators, a wealth of information can be learnt from the entanglement entropy and entanglement spectrum. A remarkable quantity is called the F-function, which is defined through the scaling behaviour of the entanglement entropy. Specifically, consider a quantum system that lives on mathbbR^2. A circle with radius R_d divides the system into inner part A and outer part B. The entanglement entropy is defined and expected to scale with R_d as ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    S_A(R_d)=-operatornametr_Arhologrho=alpha R_ddelta-F","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where delta is a UV-regulator. The constant piece is known as the F-function of a 3D CFT. The F-function is proved to be RG-monotonic, i. e., along a renormalisation group flow from UV to IR, the value of F-function is non-increasing, analogous to the central charge in 2D CFTs. Despite its importance, it has never been calculated before through non-perturbative approaches in interacting 3D CFTs. This work has performed the first non-perturbative computation of F function for the 3D Ising CFT on the fuzzy sphere. The sphere is cut in the real space into two crowns along a latitude circle theta, and the entanglement entropy S_A(theta) as a function of theta is calculated. The F-function is extracted from the S_A(theta) in the vicinity of the equator, and the result yields F=00612(5) after a finite-size scaling.","category":"page"},{"location":"intro/#Fardelli2024","page":"Introduction","title":"Conformal generators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Fardelli 2024] Constructing the infrared conformal generators on the fuzzy sphere, Giulia Fardelli, A. Liam Fitzpatrick, and Emanuel Katz, arXiv:2409.02998, SciPost Phys. 18, 086 (2025).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Fan 2024] Note on explicit construction of conformal generators on the fuzzy sphere, Ruihua Fan, arXiv:2409.08257.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Within the generators of conformal symmetry, the mathrmSO(3) rotation and the dilatation are manifest and act as rotation and time translation on the fuzzy sphere. The rest two, viz. translation P^mu and special conformal transformation (SCT) K^mu, need to be emergent in the IR at the conformal point. It is worthwhile to construct these IR generators by the UV operators on the fuzzy sphere. These works investigate such construction with the help of stress tensor T^munu. The time component T^tautau of stress tensor equals the Hamiltonian density mathscrH and it integrates into the generator Lambda^mu=P^mu+K^mu=intmathrmd^2mathbfr2n^mumathscrH. The action of this generator sends a scaling operator to other operators in the same multiplet, with the number of spatial derivatives increased or decreased by one. Fardelli et al. and Fan calculate the matrix elements of the generators Lambda^mu and find good agreement with the theoretical values in the CFT, which is another non-trivial verification of conformal symmetry. Furthermore, the separate generators P^mu and K^mu can be obtained by considering the commutator HLambda^mu, which is useful in determining the primaries. The detail for constructing the conformal generators is presented in Section â€œConformal Generatorsâ€.","category":"page"},{"location":"intro/#Dong2025","page":"Introduction","title":"The crosscap coefficients","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Dong 2025] Numerical extraction of crosscap coefficients in microscopic models for (2+1)D conformal field theory, Jia-Ming Dong, Yueshui Zhang, Kai-Wen Huang, Hong-Hao Tu, and Ying-Hai Wu, arXiv:2507.20005.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work focuses on the 3D CFTs on the space-time manifold of the the real projective space mathbbRmathrmP^3 obtained by identifying antipodal points on S^2. On mathbbRmathrmP^3, one-point functions of scalar primary fields are generally non-vanishing and encodes the â€œcross-cap coefficients.â€ Dong et al. extracts the cross-cap coefficients of the 3D Ising CFT through simulating microscopic models on the lattice models on polyhedrons and continuum models in Landau levels and entangle the degrees of freedom at anti-podal points in Bell-type states.","category":"page"},{"location":"intro/#Developing-Techniques-to-Improve-the-Numerical-Precision","page":"Introduction","title":"Developing Techniques to Improve the Numerical Precision","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"There has also been techniques to improve the precision through accessing larger system size and detailed analysis of finite-size data, such as quantum Monte Carlo simulation, conformal perturbation, and finite-size scaling the ground-state energy.","category":"page"},{"location":"intro/#Hofmann2024","page":"Introduction","title":"Quantum Monte Carlo on the fuzzy sphere","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hofmann 2024] Quantum Monte Carlo simulation of the 3d Ising transition on the fuzzy sphere, Johannes S. Hofmann, Florian Goth, Wei Zhu, Yin-Chen He, and Emilie Huffman, arXiv:2310.19880, SciPost Phys. Core 7, 028 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Until this work, the numerical methods that have been applied to the fuzzy sphere include exact diagonalisation (ED) and density matrix renormalisation group (DMRG). Hofmann et al. further present the numerical studies of the fuzzy sphere with quantum Monte Carlo (QMC) simulation, which is known for its potential for studying criticalities in (2+1) dimensions at larger system size. Specifically, they make use of the determinant quantum Monte Carlo (DQMC) method that converts the simulation of fermions into the simulation of bosonic auxiliary fields. To overcome the sign problem, they consider two copies of the original model and construct the Ising CFT on a 4-flavour model. They determine the lowest energy spectra within each symmetry sector by calculating the time-displaced correlation functions. They also calculate the equal-time correlation functions and compare them with the 2-pt functions of CFT.","category":"page"},{"location":"intro/#Laeuchli2025","page":"Introduction","title":"Conformal perturbation","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[LÃ¤uchli 2025] Exact diagonalization, matrix product states and conformal perturbation theory study of a 3d Ising fuzzy sphere model, Andreas M. LÃ¤uchli, LoÃ¯c Herviou, Patrick H. Wilhelm, and Slava Rychkov, SciPost Phys. 19, 076 (2025), arXiv:2504.00842.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The energy spectrum calculated numerically at a finite size does not coincide with that of the CFT. Part of the finite-size correction comes from the higher irrelevant operators that are not precisely tuned to zero (e. g., in the Ising CFT, the irrelevant operators include epsilon C_munurhosigma T_munu, etc., and the lowest singlets epsilon and epsilon are tuned away through the two parameters). These irrelevant operators exert perturbations on the states and their energies. This work captures this kind of correction using the conformal perturbation theory. By making use of the fact that the corrections from an irrelevant operator on the energy of the primary and its descendants are not independent, the coefficients of the irrelevant operators can be fitted and their corrections can be removed.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The conformal perturbation theory is first studied on the 2D CFTs and the icosahedron and then applied to the fuzzy sphere. This work opens up a new route to improving the precision of scaling dimensions on the fuzzy sphere by making better use of the existing data. The method to partly remove the finite-size correction through conformal perturbation theory is widely used by the following works.","category":"page"},{"location":"intro/#Wiese2025","page":"Introduction","title":"Finite-size scaling of the ground-state energy","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Wiese 2025] Locating the Ising CFT via the ground-state energy on the fuzzy sphere, Kay Joerg Wiese, arXiv:2510.09482.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work proposes a new approach to locate the phase-transition line from a finite-size scaling analysis of its ground-state energy with the example of the 3D Ising CFT. Wiese performs a finite-size scaling with the ansatz E_textGS=E_0 R^2+E_1+E_32R^-1 and identify the minima of E_32E_0 as the critical curve and the â€œsweet spot.â€","category":"page"},{"location":"intro/#Realising-Various-3D-CFTs","page":"Introduction","title":"Realising Various 3D CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The third direction is to study various other CFTs beyond 3D Ising. The fuzzy sphere has revealed lots of new information about these theories ; the previously known results are also consistent with the fuzzy sphere. the accessible CFTs include the 3-state Potts model, the Yang-Lee non-unitary CFT and three widely studied classes :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"the free-scalar and Wilson-Fisher CFTs realised as Heisenberg bilinear and truncated quantum rotor model, \nCFTs with mathrmSp(N) global symmetry related to the non-linear sigma models (NLSM) with a Wess-Zumino-Witten topological term, including mathrmSO(5) deconfined criticality and mathrmO(4) deconfined criticality through a symmetry-breaking perturbation, and a series of new theories with mathrmSp(N) symmetry, and the multi-flavour mathrmSU(2) QCD. While the CFTs above are all built from quantum Hall ferromagnets at integer filling, another class is \nfractional quantum Hall transitions, which will be discussed in more detail in the next section.","category":"page"},{"location":"intro/#Yang2025Jan","page":"Introduction","title":"The 3-state Potts model","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Yang 2025Jan] Microscopic study of 3d Potts phase transition via fuzzy sphere regularisation, Shuai Yang, Yan-Guang Yue, Yin Tang, Chao Han, Wei Zhu, and Yan Chen, arXiv:2501.14320","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The Potts models describe transitions that spontaneously break S_Q symmetries where QinmathbbZ is known as the number of states. In 2D, the transitions with Qleq Q_c=4 are continuous and captured by CFTs, while QQ_c are first order. Specifically, 2D 5-state Potts transition is pseudo-critical and described by a pair of complex CFTs in its vicinity in a similar manner with the conjectured mathrmSO(5) DQCP. In 3D, the 3-state Potts model is found to be first-order. This work constructs a 3-flavour model on the fuzzy sphere with S_3 permutation symmetry among flavours. The interacting Hamiltonian resembles the Ising model. Interestingly, Yang et al. find out that the transition point of the 3D 3-state Potts model, despite being probably first-order, exhibits approximate conformal symmetry, indicating that there might be an underlying CFT describing it. However, it is difficult to determine the nature of the transition from the operator spectrum (specifically, from the relevance of the second singlet epsilon) due to the complicated finite-size effect.","category":"page"},{"location":"intro/#Fan2025","page":"Introduction","title":"Yang-Lee non-unitary CFT","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Fan 2025] Simulating the non-unitary Yang-Lee conformal field theory on the fuzzy sphere, Ruihua Fan, Junkai Dong, and Ashvin Vishwanath arXiv:2505.06342.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Arguello Cruz 2025] Yang-Lee quantum criticality in various dimensions, Erick Arguello Cruz, Igor R. Klebanov, Grigory Tarnopolsky, and Yuan Xin, arXiv:2505.06369.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Elias Miro 2025] Flowing from the Ising model on the fuzzy sphere to the 3d Lee-Yang CFT, Joan Elias Miro, Olivier Delouche, JHEP 10 (2025) 037, arXiv:2505.07655.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The Yang-Lee singularity is one of the simplest non-unitary CFTs. It is a natural extension of the Ising CFT triggered by the isigma deformation, and plays an important role in understanding order-disorder transformation. While the 2D Yang-Lee theory is described by M(25) minimal model and 3D Yang-Lee CFT can be solved perturbatively up to five-loops, Fan et al., Arguello Cruz et al., and Elias Miro et al. present the non-perturbative results of the Yang-Lee CFT on the fuzzy sphere. They have studied the operator spectrum, the OPE coefficients, and the RG flow from the Ising CFT to the Yang-Lee CFT. They have also shown how the finite-size effects can be controlled by finite-size scaling and conformal perturbation.","category":"page"},{"location":"intro/#Free-Scalar-and-Wilson-Fisher-CFTs","page":"Introduction","title":"Free-Scalar and Wilson-Fisher CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The mathrmO(N) vector model is arguably the most well studied theory that describes the critical behaviours. It can be formulated as a quantum field theory (QFT) of N interacting scalar fields. This QFT has an ultra-violet fixed point of N free scalars. A quartic interaction term induces a RG flow to the infra-red fixed point described by the Wilson-Fisher (WF) CFT It describes a transition between an ordered phase with mathrmO(N) spontaneous symmetry breaking and an mathrmO(N)-symmetric disordered phase. This theory has been extensively studied using perturbative calculations, quantum Monte Carlo and conformal bootstrap. The mathrmO(2) WF has been experimentally measured with high precision in the normal-superfluid transition of Helium-4. Its fuzzy-sphere realisation paves the way for studying operators with certain quantum numbers, multi-scalar CFTs, defects and boundaries, etc.","category":"page"},{"location":"intro/#He2025Jun","page":"Introduction","title":"The free real scalar theory","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[He 2025Jun] Free real scalar CFT on fuzzy sphere : Spectrum, algebra and wavefunction ansatz, arXiv:2506.14904.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Taylor 2025] Conformal scalar field theory from Ising tricriticality on the fuzzy sphere, Joseph Taylor, Cristian Voinea, Zlatko PapiÄ‡, Ruihua Fan, arXiv:2506.22539.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work introduces a simple model to realise the free real scalar CFT on the fuzzy sphere that is structurally similar to the 3D Ising CFT. A weakly-broken mathrmU(1) symmetry in the fuzzy sphere model realises the mathbbR-shift symmetry of the free scalar in the thermodynamic limit, so that the fix point can be accessed with only a single tuning parameter. He numerically demonstrates that our model correctly reproduces the operator spectrum, correlation functions, and, crucially, the harmonic oscillator algebra of the real scalar CFT. He generalises the Girvin-MacDonald-Platzman algebra to the fuzzy sphere algebra of the density operators, which is potentially useful for defining quantum field theories on non-commutative geometries. He proposes a wave-function ansatz for the ground states which exhibit remarkable agreement with the CFT ground state wave-functions of the fuzzy sphere model.","category":"page"},{"location":"intro/#Han2023Dec","page":"Introduction","title":"The bilayer Heisenberg transition","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Han 2023Dec] Conformal operator content of the Wilson-Fisher transition on fuzzy sphere bilayers, Chao Han, Liangdong Hu, and Wei Zhu, arXiv:2312.04047, Phys. Rev. B 110, 115113 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work studies the mathrmO(3) WF CFT on the set-up of a bilayer Heisenberg model. The construction involves two copies of mathrmSU(2) ferromagnet with altogether four flavours. Briefly speaking, the model contains two competing terms : (1) a mathrmSU(2) ferromagnetic interaction which favours a Heisenberg ferromagnetic phase where each of the two copies is half-filled and the symmetry-breaking order parameter lives on a S^2 manifold, (2) a polarising term which favours one of the two copies being completely filled, corresponding to a Heisenberg paramagnet. The transition between these two phases falls into the mathrmO(3) Wilson-Fisher universality. Through the energy spectrum at the transition, Han et al. provide evidence that mathrmO(3) Wilson-Fisher fixed point exhibits conformal symmetry, as well as revealing a wealth of information about the CFT, e. g. the instability to cubic anisotropy. They also calculate several OPE coefficients.","category":"page"},{"location":"intro/#Guo2025","page":"Introduction","title":"The general model for mathrmO(N) free-scalar and Wilson-Fisher CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work proposes a general model that realises the mathrmO(N) free-scalar and Wilson-Fisher CFTs. The set-up contains altogether (N+1) flavours with total filling nu=1, where one flavour c_0 is mathrmO(N) singlet and the rest N flavours c_i transform as mathrmO(N) vector. The scalar field is realised as the bilinear phi_i=c_i^dagger c_0+c_0^dagger c_i, and the Hamiltonian for the WF CFT contains (1) a particle density interaction, (2) a phi density interaction, and (3) a relative chemical potential of the singlet flavour. Tuning the chemical potential realises a phase transition between a paramagnetic phase with c_0 fully filled and an mathrmO(N) symmetry-breaking phase where electrons are in a superposed state between a vector flavour and the singlet flavour. Turning to the mathrmO(N) free-scalar theory, it corresponds to a pseudo-Goldstone phase of a mathrmPO(N) SSB.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Guo et al. provide numrical evidence for N=234 such as the operator spectra and two-point conformal correlators. They discuss several quantities that may not have a direct CFT interpretation, but imply that the CFTs become to some extent semi-classical once regularised on the fuzzy sphere. ","category":"page"},{"location":"intro/#Dey2025","page":"Introduction","title":"The detailed study of the mathrmO(3) Wilson-Fisher CFT","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Dey 2025] Conformal data for the mathrmO(3) Wilson-Fisher CFT from fuzzy sphere realization of quantum rotor model, Arjun Dey, Loic Herviou, Christopher Mudry, Andreas Martin LÃ¤uchli, arXiv:2510.09755.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work focuses on the mathrmO(3) WF and fomulate the four-flavour model as a truncated rotor model. Dey et al. study the N=3 instance using ED and DMRG. They locate the critical point through a careful conformal perturbation analysis. They obtain scaling dimensions from finite-size spectra and operator product expansion coefficients through conformal perturbation. The results are benchmarked with conformal bootstrap and perturbative calculations.","category":"page"},{"location":"intro/#NLSM-WZW-with-Symplectic-Symmetry","page":"Introduction","title":"NLSM-WZW with Symplectic Symmetry","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"One route to realise many CFTs is through the non-linear sigma model (NLSM) with a Wess-Zumino-Witten (WZW) term. The NLSM on a Grassmannian ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    fracmathrmG(N)mathrmG(M)timesmathrmG(N-M)qquadmathrmG(N)=mathrmSp(tfracN2)mathrmO(N)mathrmU(N)dots","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"captures a symmetry breaking pattern of fully fill M out of N flavours of fermions with a global symmetry mathrmG(N). The NLSM often allows a topological WZW term with a quantised level. On the Landau level, a WZW term naturally appear. While the 3D NLSM in its renormalisable region can only flow to the SSB phase, the symmetry and anomaly of the NLSM-WZW can be matched with critical gauge theories with critical scalars or fermions coupled to a dynamic gauge field. These gauge theories can either serve as the UV completion of the NLSM, or has the same UV completion with the NLSM. The simplest one to construct on the fuzzy sphere are the NLSM on the symplectic Grassmannian (i. e. with mathrmG(N)=mathrmSp(tfracN2)) with a level-1 WZW term. (The construction for mathrmU or mathrmO faces the difficulty that their centres mathrmU(1) or mathbbZ_2, as the electric charge conservation or its subgroup, must be decoupled ; the construction for mathrmSU or mathrmSO faces the difficulty in realising the topological mathrmU(1) or mathbbZ_2 symmetry.) They can be constructed by considering N flavours of fermions and break the flavour symmetry to mathrmSp(tfracN2). This construction can be used to realise various 3D QCDs. ","category":"page"},{"location":"intro/#Zhou2023","page":"Introduction","title":"The mathrmSO(5) deconfined criticality","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2023] The mathrmSO(5) deconfined phase transition under the fuzzy sphere microscope: approximate conformal symmetry, pseudo-criticality, and operator spectrum, Zheng Zhou, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.16435, Phys. Rev. X 14, 021044 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Deconfined quantum critical point (DQCP) is one of the pioneering examples of phase transitions beyond Landau paradigm. It has led to numerous theoretical surprises, including the emergent mathrmSO(5) symmetry and the duality between interacting theories. Despite extensive studies over the past two decades, its nature remains controversial. Numerical simulations have shown no signal of discontinuity, but abnormal scaling behaviours have been observed. A plausible proposal to reconcile the tension is that DQCP is pseudo-critical, i. e. a weakly first-order phase transition that has approximate critical behaviour, and is controlled by a pair of complex fixed points very close to the pseudo-critical region.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The DQCP can be conveniently studied on the fuzzy sphere by constructing a NLSM on S^4 with WZW level-1, which serves as a dual description of the DQCP with an exact mathrmSO(5) symmetry. The idea is to construct a 4-flavour model with symmetry mathrmSp(2)mathbbZ_2=mathrmSO(5) (mathbbZ_2 means to gauge the pseudoreal representations). At half-filling, it can be described by a NLSM on the Grassmannian tfracmathrmSp(2)mathrmSp(1)timesmathrmSp(1)cong S^4 and the WZW level can be matched. This work provides evidence that the DQCP exhibits approximate conformal symmetry. Zhou et al. have identified 19 conformal primaries and their 82 descendants. Furthermore, by examining the renormalisation group flow of the lowest symmetry singlet, they demonstrate that the DQCP is more likely pseudo-critical, with the approximate conformal symmetry plausibly emerging from nearby complex fixed points. Several works appear later to follow up.","category":"page"},{"location":"intro/#Yang2025Jul","page":"Introduction","title":"The mathrmO(4) deconfined criticality","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Yang 2025Jul] Conformal Operator Flows of the Deconfined Quantum Criticality from mathrmSO(5) to mathrmO(4), Shuai Yang, Liang-Dong Hu, Chao Han, Wei Zhu, Yan Chen, arXiv:2507.01322.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from the mathrmSO(5) deconfined criticality, one can reach the mathrmO(4), or easy-plane DQCP by adding a perturbation in the mathrmSO(5) symmetric tensor representation that breaks the global symmetry to mathrmO(4). The mathrmO(4) DQCP appears in several lattice models and has several gauge theory descriptions, e. g. QED with two flavours of Dirac fermions. This work studies the renormalisation group flow from the mathrmSO(5) to the mathrmO(4) DQCP and traces the mathrmO(4) operators back to the mathrmSO(5) operators.","category":"page"},{"location":"intro/#Zhou2024Oct","page":"Introduction","title":"A series of new mathrmSp(N)-symmetric CFTs","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2024Oct] A new series of 3d CFTs with mathrmSp(N) global symmetry on fuzzy sphere, Zheng Zhou, and Yin-Chen He, arXiv:2410.00087, Phys. Rev. Lett. 135, 026504 (2025).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The quest to discover new 3D CFTs has been intriguing for physicists. A virgin land on this quest is the parity-breaking CFTs. In 3D, the Chern-Simons-matter theories stand out as the most well-known and possibly the only known type of parity-breaking CFTs. The fuzzy sphere is a promising platform for studying these theories. This work makes a concrete construction by generalising the DQCP to the WZW-NLSM on the target space of a general symplectic Grassmannian","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    fracmathrmSp(N)mathrmSp(M)timesmathrmSp(N-M)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Several candidate Chern-Simons-matter theories are known to exist on its phase diagram with N flavour of gapless bosons or fermions coupled to a non-Abelian (viz. mathrmSp(1), mathrmSp(2), etc.) Chern-Simons gauge field. On the fuzzy sphere, this WZW-NLSM can be realised by a 2N layer model with mathrmSp(N) flavour symmetry, and 2M out of the 2N layers are filled. Zhou et al. numerically verify the emergent conformal symmetry by observing the integer-spaced conformal multiplets and studying the finite-size scaling of the conformality.","category":"page"},{"location":"intro/#Huffman2025","page":"Introduction","title":"Multi-flavour mathrmSU(2) QCD","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The conformal window is an outstanding problem for 3D gauge theories. For a given gauge field, when the number of flavours coupled to it exceeds some critical value NN_c, the field theory flows to a conformal fixed point ; otherwise the gauge field is confined and the field theory flows to SSB. The conformal windows of 3D QED and mathrmSU(2) QCD are directly related to the nature of deconfined criticality and the Dirac spin liquid. However, results beyond perturbative calculations for certain gauge groups are still hard to access.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"On the fuzzy sphere, the mathrmSU(2) QCD with N flavours of fermions can be realised with the mathrmSp(N) model at half-filling M=N2. The model is free of sign problem and thus accessible through quantum Monte Carlo. Notably, N is treated as a parameter instead of the number of fermions simulated, so the calculation can reach arbitrarily large number of flavours. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work finds that the phase diagram at Ngeq 4 has a stable conformal fixed point corresponding to the QCD through examining the RG flow. Huffmann et al. extracts the various scaling dimensions from the equal-time and imaginary-time two-point correlation functions and finds agreement with conformal symmetry and large-N expansion result.","category":"page"},{"location":"intro/#Exploring-Fractional-Quantum-Hall-Transitions","page":"Introduction","title":"Exploring Fractional Quantum Hall Transitions","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The models above are all built from quantum Hall ferromagnets at integer filling. Specifically, in the absence of the interaction, an integer number of the lowest Landau levels are fully occupied. The lowest Landau level at fractional filling realises various topological orders (TO) with long-range entanglement and anyon excitations. E. g., the Laughlin states with filling nu=1k realise the Abelian topological orders captured by Chern-Simons theories mathrmU(1)_-k, the Jain sequence with nu=p(mp+1) realises the Abelian topological orders with composite fermion descriptions, and the Read-Rezayi sequence with nu=p(mp+2), as a natural extension of the Moore-Read states, realises in general a series of non-Abelian topological orders. These states have finite charge gaps as well that guarantees that the gapless spin degree of freedom can decouple from the strongly non-commutative charge degree of freedom.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The fuzzy sphere provides a suitable platforms to study the transitions between or out of these fractional quantum Hall (FQH) states. Theoretically, these transitions are often described by Chern-Simons theories coupled to matter, many of which are conjectured to be conformal with enhanced symmetries and field theory dualities. Experimentally, the Moir\\'e materials provide an exciting opportunity to study these transitions. The critical points can be conveniently reached by tuning many knobs like potential amplitude.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The exploration starts at realising the Ising CFT on the background of a FQHE state, for which the topological order stays the same across the transition. The transition between nu=12 bosonic Laughlin state and a nu=2 fermionic Laughlin state, realising the confinement transition of nu=12 bosonic Laughlin state, is the first fractional quantum Hall transition on the fuzzy sphere. Using similar strategy, the phase diagram between fermionic integer quantum Hall and bosonic Laughlin state realising two transitions of free Majorana fermion and gauged Ising CFT, and the transition between bosonic Pfaffian and Halperin 220 state, are also studied.","category":"page"},{"location":"intro/#Voinea2024","page":"Introduction","title":"Ising CFT from FQHE state","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Voinea 2024] Regularising 3d conformal field theories via anyons on the fuzzy sphere, arXiv:2411.15299, Phys. Rev. X 15, 031007 (2025).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Voinea et al. explore the possibility of constructing CFTs on the Haldane-Laughlin states that capture the fractional quantum Hall effect (FQHE). Specifically, they study the fermionic LLL at fillings of nu=13 and 15. The model Hamiltonian contains (1) a dominant projection term that puts the ground state on the Haldane-Laughlin state, and (2) an interaction term as a perturbation that drives the Ising-type phase transition. They show that the energy spectra at the critical point exhibit conformal symmetry. Notably, they also make the construction with respect to the bosonic LLL at a filling of nu=12.","category":"page"},{"location":"intro/#Zhou2025Jul","page":"Introduction","title":"The confinement transition of nu=12 bosonic Laughlin state","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2025Jul] Chern-Simons-matter conformal field theory on fuzzy sphere: Confinement transition of Kalmeyer-Laughlin chiral spin liquid, Zheng Zhou, Chong Wang, Yin-Chen He, arXiv:2507.19580.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work studies one of the simplest instances of Chern-Simons-matter theories : one complex critical scalar coupled to a mathrmU(1)_2 Chern-Simons gauge field and its three other dual Lagrangian descriptions. They describe the transition between a nu=12 bosonic Laughlin state and a trivially gapped phase. This transition appears in various contexts in condensed-matter physics, viz. Kalmeyer-Laughlin chiral spin liquid, anyon superconductivity, Feshbach resonance, etc.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Zhou et al. realise this theory on a set-up with fermion-boson mixture containing two flavours of fermion and one flavour of bosons carrying electric charge Q_b=2Q_f. Tuning the relative chemical potential induces a transition between a nu_f=2 fermionic integer quantum Hall state and a nu_b=12 bosonic fractional quantum Hall state. They show that the transition is continuous and has emergent conformal symmetry. The operator spectrum has exactly one relevant singlet with scaling dimension Delta_S=152(18), signature of a critical point. This work opens up the possiblity of using the fuzzy sphere to study transitions between distinct topological order. ","category":"page"},{"location":"intro/#Zhou2025Sep","page":"Introduction","title":"The free Majorana fermion theory","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2025Sep] Free Majorana fermion meets gauged Ising conformal field theory on the fuzzy sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, arXiv:2509.08038.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The CFTs realised on the fuzzy sphere until this work contains only bosonic CFT operators. The microscopic fermions on the fuzzy sphere have strong non-commutativity, transform under projective representations of the sphere rotation symmetry, and thus cannot flow to CFT operators. This work overcomes this challenge by constructing a boson-fermion mixed setup with both microscopic bosons b and fermions f with the same electric charge and let their angular momenta differ by 12. Their bilinears b^dagger f or f^dagger b can be used to realise fermionic local operators in a CFTs.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Zhou et al. allow conversion between two bosons and two fermions and set the total filling nu=1. On the phase diagram, there are three gapped phases, viz. a fermionic integer quantum Hall phase, an f-wave chiral topological superconductor, and a bosonic Pfaffian phase. They are separated by two continuous transitions described respectively by a massless free Majorana fermion and a gauged Ising CFT. Notably, the Hamiltonian that realises the free Majorana fermion is analogous with the field theory Hamiltonian in addition to a density-density interaction.","category":"page"},{"location":"intro/#Voinea2025","page":"Introduction","title":"The transition between bosonic Pfaffian and Halperin 220","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Voinea 2025] Critical Majorana fermion at a topological quantum Hall bilayer transition, Cristian Voinea, Wei Zhu, Nicolas Regnault, Zlatko PapiÄ‡, arXiv:2509.08036.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The fuzzy sphere can be used to answer long-standing questions on fractional quantum Hall transitions. An example is the transition between the bosonic Moore-Read Pfaffian and the Halperin 220 state on a bilayer bosonic system, which has been predicted to be described by a massless free Majorana fermion with the fermion parity mathbbZ_2 symmetry gauged, but lacks simulations. This work identifies the low-energy spectrum with the gauged Majorana fermion. ","category":"page"},{"location":"intro/#Studying-Conformal-Defects-and-Boundaries","page":"Introduction","title":"Studying Conformal Defects and Boundaries","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from the bulk CFTs, the fuzzy sphere can also be used to study their conformal defects and boundaries. Deforming a CFT with interactions living on a sub-dimensional defect may trigger a RG flow towards a non-trivial interacting IR fixed point. A defect IR theory with a smaller conformal symmetry is called a defect CFT. The dCFTs have rich physical structures, such as defect operators and bulk-to-defect correlation functions. Moreover, a bulk CFT can flow to several different dCFTs. Similarly, deformation on the boundary may trigger a flow towards a boundary CFT (bCFT). So far, the accessible defects/boundaries include the magnetic line defect of the 3D Ising CFT, in particular, its defect operator spectrum, correlators, g-function, defect-changing operators, its cusp, and the conformal boundaries of the 3D Ising CFT. Besides the defects and boundaries of 3D CFTs, one can also studying lower dimensional bulk CFTs on a (2+1)D set-up, like the on a fuzzy thin torus.","category":"page"},{"location":"intro/#Hu2023Aug","page":"Introduction","title":"Conformal magnetic line defect","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Hu 2023Aug] Solving conformal defects in 3d conformal field theory using fuzzy sphere regularisation, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2308.01903, Nat. Commun. 15, 3659 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This is the first work that studies conformal defects with the fuzzy sphere. The simplest example of conformal defect is the magnetic line defect of the 3D Ising CFT, where the defect line is completely polarised and the mathbbZ_2 symmetry is explicitly broken. A defect line along z-direction that passes the origin point, after the radial quantisation, corresponds to the north and south poles of the sphere being polarised. Hence, to realise the magnetic line defect on the fuzzy sphere, one only needs to apply a pinning magnetic field to the north and south poles (Since only the m=+s orbital has non-zero amplitude at the north pole and m=-s at the south pole due to the locality, one only need to pin the m=pm s orbitals).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work demonstrates that the defect IR fixed point has emergent conformal symmetry mathrmSO(21)timesmathrmO(2) : in the operator spectrum, there exists a displacement operator as the non-conservation of stress tensor at exactly Delta_mathrmd=2, and the defect primaries and descendants have integer spacing ; the bulk-to-defect 1-pt and 2-pt correlation functions follow a power law. Hu et al. have identified six low-lying defect primary operators, extracted their scaling dimensions, and computed the 1-pt function of bulk primaries and 2-pt bulk-to-defect correlators.","category":"page"},{"location":"intro/#Zhou2024Jan","page":"Introduction","title":"The g-function and defect changing operators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2024Jan] The g-function and defect changing operators from wavefunction overlap on a fuzzy sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, Yijian Zou, arXiv:2401.00039, SciPost Phys. 17, 021 (2024).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"This work studies the g-function of conformal defects and the defect-creation and changing operators. Similar to the central charge and the F-function in bulk CFTs, there exists a RG-monotonic quantity called the g-function for the line defects that is non-increasing along the flow. It is defined as the ratio between the partition functions of the defect CFT and the bulk CFT. On a different note, consider two semi-infinite magnetic line defects pinned towards opposite directions joint at one point, a defect-changing operator lives at the joining point. Similarly, a defect-creation operator lives at the endpoint of a semi-infinite line defect. The relevance of the defect-changing operator is related to the stability of spontaneous symmetry breaking (SSB) on the line defect.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Zhou et al. realise the defect-creation and changing operators for the Ising magnetic line defect by acting a pinning field at the north pole, and opposite pinning fields at the north and south poles, respectively. The scaling dimensions are calculated through state-operator correspondence Delta_textrmcreation=0108(5)Delta_textrmchanging=084(5), indicating the instability of SSB on the Ising magnetic line. Moreover, they show that the g-function and many other CFT data can be calculated by taking the overlaps between the eigenstates of different defect configurations. Notably, this work has given the first non-perturbative result for the g-function g=0602(2).","category":"page"},{"location":"intro/#Cuomo2024","page":"Introduction","title":"Cusp","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Cuomo 2024] Impurities with a cusp : general theory and 3d Ising, Gabriel Cuomo, Yin-Chen He, Zohar Komargodski, arXiv:2406.10186, JHEP 11 (2024) 061. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A cusp is two semi-infinite defect lines joined at one point at an angle. This can be realised on the fuzzy sphere through pinning fields at two points at an angle. Cuomo et al. study the cusps through various theoretical and numerical approaches. In particular, on the fuzzy sphere, they calculate the cusp anomalous dimension as a function of the angle for the Ising magnetic line defect, and verify its relation with the Zamolodchikov norm of the displacement operator.","category":"page"},{"location":"intro/#Zhou2024Jul","page":"Introduction","title":"Conformal boundaries of 3D Ising CFT","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Zhou 2024Jul] Studying the 3d Ising surface CFTs on the fuzzy sphere, Zheng Zhou, and Yijian Zou, arXiv:2407.15914, SciPost Phys. 18, 031 (2025).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Dedushenko 2024] Ising BCFTs from the fuzzy hemisphere, Mykola Dedushenko, arXiv:2407.15948.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Apart from line defects, boundaries are also important extended objects in CFT. For the Ising CFT, there exist several conformal boundaries : normal bCFT with explicitly broken mathbbZ_2 symmetry, ordinary bCFT that is stable and has preserved mathbbZ_2 symmetry, extraordinary bCFT with spontaneously broken mathbbZ_2 symmetry, and special bCFT as the transition between ordinary and extraordinary bCFTs. These works focus on the normal and ordinary bCFTs and show that they can be realised by acting a polarising field on a hemisphere. By noting that the LLL orbitals are localised along latitude circles, the bCFTs can equivalently be realised by pinning the orbitals with m0. By studying the operator spectrum, Zhou et al. and Dedushenko et al. show numerical evidence for conformal symmetry and estimate the scaling dimensions of the conformal primaries. They also calculate the bulk-to-boundary 1-pt and 2-pt functions and extract the corresponding OPE coefficients. Interestingly, Zhou et al. notice a certain correspondence between the boundary energy spectrum and bulk entanglement spectrum through the orbital cut.","category":"page"},{"location":"intro/#Han2025","page":"Introduction","title":"Fuzzy circle","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"[Han 2025] Quantum phase transitions on the noncommutative circle, Chao Han, and Wei Zhu, Phys. Rev. B 111, 085113 (2025)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Besides the fuzzy sphere S^2, the regularisation with the lowest Landau level can also be used for other manifolds or dimensions. This work studies the 2D CFT on a â€œfuzzy circle.â€ Although Landau levels can only be defined on even space dimensions, one can reach odd space dimensions by compactifying one of the even dimensions. Specifically, Han et al. construct the LLL on a thin torus T^2 and sends one of the lengths to infinity while fixing the other. In this way, a circle S^1 is recovered in the thermodynamic limit. They construct the 2D Ising and 3-state Potts CFTs on the fuzzy circle and compare the operator spectrum and OPE coefficients with the Virasoro multiplet structure and the known results in the exactly solvable minimal models.","category":"page"},{"location":"intro/#Model-Construction","page":"Introduction","title":"Model Construction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this section, we review the process of constructing a model on the fuzzy sphere and extracting the conformal data. We aim to provide the necessary technical information for those who want to get started with the research on the fuzzy sphere, especially the aspects rarely covered by other literature.","category":"page"},{"location":"intro/#Projection-onto-the-Lowest-Landau-Level","page":"Introduction","title":"Projection onto the Lowest Landau Level","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To build the setup of the fuzzy sphere, we consider a sphere with radius R and put a 4pi s-monopole at its centre. Consider free electrons moving on the sphere. The monopole modifies the single particle Hamiltonian","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_0=frac12MR^2(partial^mu+iA^mu)^2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where mu=thetaphi and the gauge connexion is taken as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    A_theta=0quad A_phi=-fracsRoperatornamectgtheta","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The eigenstates of the Hamiltonian are the monopole spherical harmonics","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_nm(mathbfr)=frac1RY_lm^(s)(hatmathbfn)qquad n=01dotsquad l=n+squad m=-ldotsl-1l","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where hatmathbfn is the unit vector of the point on the sphere specified by angular coordinates theta and phi, and the energies are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_n=frac12MR^2n(2s+n+1)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Each level, known as a Landau level, has a degeneracy (2l+1). Specifically, the wave-functions on the lowest Landau level (LLL) n=0l=s are easy to write out :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_0m(mathbfr)=frac1RY_sm^(s)(hatmathbfn)qquad Y_sm^(s)(hatmathbfn)=C_me^imphicos^s+mfractheta2sin^s-mfractheta2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where C_m=1sqrt4piBeta(s+m+1s-m+1) is the normalising factor, and Beta is the Euler's beta function. The LLL has a degeneracy N_m=2s+1.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We now consider N_f flavours of fermions moving on the sphere, characterised by the second-quantised fermion operator psi_f(mathbfr), with a flavour index f=1dotsN_f. We partially fill the lowest Landau level and set the single energy gap to be much larger than the scale of interaction H_0gg H_textint, so that the quantum fluctuation can be constrained on the lowest Landau level. In practice, we often fill integer number of flavours N_e=kN_m (kinmathbbZ) so that a quantum Hall ferromagnet (i. e. the state where integer number of LLLs are fully filled) is preferred in the absence of interaction, for which the charge degree of freedom is gapped and does not couple strongly to the gapless CFT degree of freedom when the interactions are introduced.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then project the system onto the LLL. Technically, this can be done by writing the fermion operators in terms of the annihilation operators of the LLL orbitals","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    psi^dagger_f(mathbfr)=sum_m=-s^s Phi_0m(mathbfr)c^dagger_mf=frac1Rsum_m=-s^s Y^(s)_sm(hatmathbfn)c^dagger_mf","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where c^(dagger)_mf annihilates/creates an electron with L^z-quantum number m at the f-th flavour of the lowest Landau level. Hereafter, we will omit the hats on the operators. In the old version, we used a different convension psi_f(hatmathbfn)_text(old)=sum_m=-s^s Y^(s)_sm(hatmathbfn)c_mf. In the old convension, the components of density operator n_Mlm are extensive and their action decreases the angular momentum L^z by m ; in the current convension, n_Mlm is intensive and its action increases the angular momentum L^z by m. In the code, two parameters ObsNormRadSq and ObsMomIncr controls the convension.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"After the projection, we obtain a finite Hilbert space on which numerical simulations can be carried out. For this purpose, the system is analogous to a length-(2s+1) spin chain with long-range interaction, where different Landau level orbitals behave like the lattice sites. The difference is that the (2s+1) orbital forms a spin-s representation of the mathrmSO(3) rotation group, and in this way the continuous rotation symmetry is preserved. The exact rotation symmetry shortens the RG flow from the UV to the IR and reduces the finite-size effect, so that the numerical results are considerably accurate even at a small system size.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The word â€œfuzzyâ€ means non-commutativity. Here, the magnetic field results in the non-commutativity of the coordinates. More concretely, we write the coordinate operators as a matrix on the lowest Landau level","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    X^mu_m_1m_2=intmathrmd^2mathbfrx^mu fracY_sm_1^(s)(mathbfr)RfracbarY_sm_2^(s)(mathbfr)R","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"These matrices mathbfX^mu (mu=xyz) satisfy relation","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathbfX_mumathbfX^mu=fracss+1R^2mathbbIqquad mathbfX^mumathbfX^nu=frac1s+1iepsilon^munurhoRmathbfX_rho","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The first equation involves a renormalised radius tildeR of the sphere, and the second equation involves the magnetic length l_B that determines the non-commutativity.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathbfX_mumathbfX^mu=tildeR^2mathbbIqquad mathbfX^mumathbfX^nu=l_B^2iepsilon^munurho(mathbfX_rhoR)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We can take l_B=1 as the unit length. In this way, the radius scales with the square root of the number of orbitals","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    tildeRl_B=s(s+1)^14simsqrtN_m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The thermodynamic limit can be taken as N_mtoinfty, where a regular sphere is recovered. Hereafter we take the radius of the sphere R=sqrtN_m","category":"page"},{"location":"intro/#Density-Operator","page":"Introduction","title":"Density Operator","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Having constructed the single-particle states, we then consider the interacting many-body Hamiltonian. The simplest building block is the density operator, i. e., local fermion bilinear","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(mathbfr)=psi_f^dagger(mathbfr)M_ffpsi_f(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here, the matrix insertion M puts the density operators in a certain representation of the flavour symmetry. For example, for a 2-flavour system, M can be taken as the Pauli matrices mathbbIsigma^xsigma^ysigma^z ; for a system with N_f flavours in the fundamental representation of mathrmSU(N_f) flavour symmetry, one can put n_M in the singlet or adjoint representation","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    n_S(mathbfr)=psi_c^dagger(mathbfr)psi^c(mathbfr)nonumber\n    n_a^b(mathbfr)=psi_a^dagger(mathbfr)psi^b(mathbfr)-tfrac1Ndelta_a^bpsi_c^dagger(mathbfr)psi^c(mathbfr)\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Like the fermion operator, the density operator can also be expressed in the orbital space","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_M(mathbfr)=sum_lmY_lm(hatmathbfn)n_Mlm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Conversely,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    n_Mlm=frac1R^2intmathrmd^2mathbfrbarY_lm(hatmathbfn)n_M(mathbfr)nonumber\n    =intmathrmd^2hatmathbfnbarY_lm(hatmathbfn)left(frac1Rsum_m_1Y^(s)_sm_1(hatmathbfn)c^dagger_m_1f_1right)M_f_1f_2left(frac1Rsum_m_2barY^(s)_sm_2(hatmathbfn)c_m_1f_2right)nonumber\n    =frac1R^2sum_m_1m_2c^dagger_m_1f_1M_f_1f_2c_m_1f_2intmathrmd^2hatmathbfnbarY_lm(hatmathbfn)Y^(s)_sm_1(hatmathbfn)barY^(s)_sm_2(hatmathbfn)nonumber\n    =frac1R^2sum_m_1c^dagger_m_1f_1M_f_1f_2c_m-m_1f_2timesnonumber\n    qquadqquad(-1)^s+2m-m_1(2s+1)sqrtfrac2l+14pibeginpmatrixlss-mm_1-m_1+mendpmatrixbeginpmatrixlss0-ssendpmatrix\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here, we have used the properties of the monopole spherical harmonics","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    barY_lm^s=(-1)^s+mY_l-m^(-s)\n    intmathrmd^2hatmathbfnY_lm^(s)barY_lm^(s)=delta_lldelta_mm\n    intmathrmd^2hatmathbfnY_l_1m_1^(s_1)Y_l_2m_2^(s_2)Y_l_3m_3^(s_3)=sqrtfrac(2l_1+1)(2l_2+1)(2l_3+1)4pibeginpmatrixl_1l_2l_3m_1m_2m_3endpmatrixbeginpmatrixl_1l_2l_3-s_1-s_2-s_3endpmatrix\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where left(beginsmallmatrixbulletbulletbulletbulletbulletbulletendsmallmatrixright) is the 3j-symbol, and we denote the common spherical harmonics by Y_lm^(0)=Y_lm. In this way, we have fully expressed the density operator in terms of the operators in the orbital space c^(dagger)_mf.","category":"page"},{"location":"intro/#Density-Density-Interaction","page":"Introduction","title":"Density-Density Interaction","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The most straightforward way to construct an interaction term is to add a density-density interaction with a potential function (This is, however, not the simplest construction and we will present the simpler construction in terms of pseudo-potentials in the next section)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_textint=intmathrmd^2mathbfr_1mathrmd^2mathbfr_2U(mathbfr_1-mathbfr_2)n_M(mathbfr_1)n_M(mathbfr_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The interacting potentials can be expanded in terms of the Legendre polynomials","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U(mathbfr_12)=sum_ltildeU_lP_l(costheta_12)=sum_lmfrac4pitildeU_l2l+1barY_lm(hatmathbfn_1)Y_lm(hatmathbfn_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where mathbfr_12=mathbfr_1-mathbfr_2 and mathbfr_12=2Rsintheta_122. Conversely","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    tildeU_l=intsintheta_12mathrmdtheta_12frac2l+12U(mathbfr_12)P_l(costheta_12)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Specifically, for local and super-local interactions","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    U(mathbfr_12)=g_0delta(mathbfr_12)tildeU_l=fracg_0R^2(2l+1)nonumber\n    U(mathbfr_12)=g_1nabla^2delta(mathbfr_12)tildeU_l=-fracg_1R^4l(l+1)(2l+1)\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here we make use of the conversion relations ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    delta(mathbfr)=frac1R^2delta(hatmathbfn)qquad nabla^2_mathbfr=frac1R^2nabla^2_hatmathbfn","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"for mathbfr=Rhatmathbfn. By expanding the density operators into the orbital space and completing the integrals,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_textint=sum_lmfrac4pi R^4tildeU_l 2l+1n^dagger_Mlmn_Mlm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"With these ingredients, we can now consider how to construct models. This comes down to matching the symmetry and phase diagram. E. g., for the Ising model, the mathbbZ_2 global symmetry is realised as the exchange of the two flavours psi_uparrow(mathbfr)leftrightarrowpsi_downarrow(mathbfr). We need a phase diagram with a paramagnetic (PM) phase where the mathbbZ_2 symmetry is conserved and a ferromagnetic (FM) phase where the mathbbZ_2 symmetry is spontaneously broken. The PM phase is favoured by a polarising term that resembles a transverse field","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    -hintmathrmd^2mathbfrn_x(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and the FM phase where either of the two flavours is fully filled is favoured by a repulsion between the two flavours","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    intmathrmd^2mathbfr_1mathrmd^2mathbfr_2U(mathbfr_12)n_uparrow(mathbfr_1)n_downarrow(mathbfr_2)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the density operators are defined as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n_x(mathbfr)=psi^dagger_downarrow(mathbfr)psi_uparrow(mathbfr)+psi^dagger_uparrow(mathbfr)psi_downarrow(mathbfr)quad n_uparrow(mathbfr)=psi^dagger_uparrow(mathbfr)psi_uparrow(mathbfr)quad n_downarrow(mathbfr)=psi^dagger_downarrow(mathbfr)psi_downarrow(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and the potentials can be most conveniently taken as a combination of local and super-local interactions. Altogether, the model Hamiltonian reads","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H_textint=intmathrmd^2mathbfr_1mathrmd^2mathbfr_2U(mathbfr_12)n_uparrow(mathbfr_1)n_downarrow(mathbfr_2)-hintmathrmd^2mathbfrn_x(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"By tuning the ratio between h and U(mathbfr_12), a phase transition described by the Ising CFT is realised.","category":"page"},{"location":"intro/#Interaction-in-Terms-of-Pseudo-Potentials","page":"Introduction","title":"Interaction in Terms of Pseudo-Potentials","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Another way that is computationally much more convenient to construct the four-fermion interaction terms is through Haldane pseudo-potential. To explain the idea, we take the 3D Ising model as an example. We first classify all the fermion bilinears lambda_m_1f_1m_2f_2c_m_1f_1c_m_2f_2. To simplify the discussion, we can take a specific flavour index lambda_m_1m_2c_m_1uparrowc_m_2downarrow. The fermion bilinears can be classified into irreducible representations (irreps) of mathrmSO(3) rotation symmetry. Since c_mf carries the spin-s representation, the spin of its bilinear ranges from 0 to 2s and takes integer values. The spin-(2s-l) combination reads","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm=sum_m_1langle sm_1s(m-m_1)(2s-l)mrangle c_m_1uparrowc_m-m_1downarrow","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where m=-(2s-l)dots(2s-l), and the Clebshbar-Gordan coefficients is related to the 3j-symbol by","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    langle l_1m_1l_2m_2lmrangle=(-1)^-l_1+l_2-msqrt2l+1beginpmatrixl_1l_2lm_1m_2-mendpmatrix","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A four-fermion interaction term is formed by contracting these paring operators with its conjugate","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=sum_lU_lH_lquad H_l=sum_mDelta_lm^daggerDelta_lm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Putting these together, the interaction Hamiltonian can be expressed as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    H=sum_lm_1m_2m_3m_4U_lC^l_m_1m_2m_3m_4c^dagger_m_1uparrowc^dagger_m_2downarrowc_m_3downarrowc_m_4uparrow-hsum_m(c_muparrow^dagger c_mdownarrow+texth c)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the matrix elements are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    C^l_m_1m_2m_3m_4=delta_m_1+m_2m_3+m_4langle sm_1sm_2(2s-l)(m_1+m_2)ranglelangle sm_3sm_4(2s-l)(m_3+m_4)rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The coupling strengths U_l of the spin-(2s-l) channel are called the Haldane pseudo-potentials.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We also need to consider the constraint that the two fermions must be antisymmetrised : for even l, the orbital index is symmetrised, so the spin index must be antisymmetrised, so the two fermions form a spin-singlet which is invariant under the mathrmSU(2) transformation ; for odd l, the orbital index is antisymmetrised, so the spin index is symmetrised, breaking the flavour symmetry from mathrmSU(2) to mathbbZ_2. Hence, an odd-l pseudo-potential must be added (This fact escapes the construction by density-density interaction).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The fermion bilinears with other flavour configurations lambda_m_1m_2pm(c_m_1uparrowc_m_2uparrowpm c_m_1downarrowc_m_2downarrow) can be analysed in a similar way. After that, we have enumerated all possible four-fermion interaction terms.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Each pseudo-potential corresponds to a profile of interaction potential functions. The conversion between the pseudo-potentials U_l and the Legendre expansion coefficients of the potential function tildeU_l","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U(mathbfr_12)=sum_ltildeU_lP_l(costheta_12)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"is","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    U_l=sum_k tildeU_k(-1)^l(2s+1)^2beginBmatrix2s-lsskssendBmatrixbeginpmatrixsks-s0sendpmatrix^2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where leftbeginsmallmatrixbulletbulletbulletbulletbulletbulletendsmallmatrixright is the 6j-symbol. Specifically, a local interaction delta(mathbfr_12) contains only pseudo-potential U_0 ; a superlocal interaction of form (nabla^2)^ldelta(mathbfr_12) contains U_0U_1dotsU_l. Here we explicitly give the expressions for the lowest pseudo-potentials","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    U(mathbfr_12)=delta(mathbfr_12)U_0=frac(2s+1)^24s+1nonumber\n    U(mathbfr_12)=nabla^2delta(mathbfr_12)U_0=-fracs(2s+1)^24s+1U_1=fracs(2s+1)^24s-1\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We also note that the construction for interaction Hamiltonian for LLL with pseudo-potentials is not restricted to sphere. E. g., on a torus, the interaction can also be parametrise by pseudo-potentials. ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For systems with more complicated continuous flavour symmetries, classification in terms of representation of flavour symmetry must also be considered, and the indices must be overall antisymmetrised. We explain that through the example of a 2N-flavour system with mathrmSp(N) symmetry. The maximal flavour symmetry is mathrmSU(2N), so interactions must be added to break the symmetry from mathrmSU(2N) to mathrmSp(N). The fermion operators c_ma live in the mathrmSp(N) fundamental representation, where a is the mathrmSp(N) index. We shall show that all the allowed terms are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    H=sum_substacklinmathbbZm_1m_2m_3m_4U_lC^l_m_1m_2m_3m_4c^dagger_m_1ac^dagger_m_2bc_m_3bc_m_4a\n    qquadqquad-frac12sum_substacklin 2mathbbZm_1m_2m_3m_4V_lC^l_m_1m_2m_3m_4Omega_aaOmega_bbc^dagger_m_1ac^dagger_m_2ac_m_3bc_m_4b\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where Omega=beginpmatrix0mathbbI_N-mathbbI_N0endpmatrix.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To find out all the four-fermion interactions allowed by the rotation symmetry mathrmSO(3) and flavour symmetry mathrmSp(N), we classify all the fermion bilinears c_m_1ac_m_2b into irreps of mathrmSO(3)timesmathrmSp(N). For each irrep, by contracting the bilinear with its Hermitian conjugate, we obtain an allowed four-fermion interaction term. Each fermion carries mathrmSO(3) spin-s and mathrmSp(N) fundamental. For the rotation symmetry mathrmSO(3), the bilinears can carry spin-(2s-l)(l=0dots2s) represetation ; for even l, the orbital indices are symmetrised ; for odd l, the orbital indices are antisymmetrised. For the flavour symmetry mathrmSp(N), the bilinears can carry singlet S, traceless antisymmetric rank-2 tensor A and symmetric rank-2 tensor T representation ; for S and A, the flavour indices are antisymmetrised ; for T, the flavour indices are symmetrised. As the two fermions altogether should be antisymmetrised, the allowed combinations are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Case 1.  mathrmSp(N) singlet and mathrmSO(3) spin-(2s-l) with even l, the bilinears are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm=sum_m_1m_2langle sm_1sm_2(2s-l)mrangleOmega_ccc_m_1cc_m_2cdelta_mm_1+m_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The corresponding interaction term H_Sl=sum_mDelta_lm^daggerDelta_lm is the even-l pseudo-potential for the V-term.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Case 2.  mathrmSp(N) antisymmetric and mathrmSO(3) spin-(2s-l) with even l, the bilinears are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lmab=sum_m_1m_2langle sm_1sm_2(2s-l)mrangle(c_m_1ac_m_2b-c_m_1bc_m_2a-tfrac1NOmega_abOmega_ccc_m_1cc_m_2c)delta_mm_1+m_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The corresponding interaction term H_Al=sum_mDelta_lmab^daggerDelta_lmab is the even-l pseudo-potential for the U-term.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Case 3.  mathrmSp(N) symmetric and mathrmSO(3) spin-(2s-l) with odd l, the bilinears are","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_lm(ab)=sum_m_1m_2langle sm_1sm_2(2s-l)mrangle(c_m_1ac_m_2b+c_m_1bc_m_2a)delta_mm_1+m_2","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The corresponding interaction term H_Tl=sum_mDelta_lm(ab)^daggerDelta_lm(ab) is the odd-l pseudo-potential for the U-term.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In summary, all allowed interactions are the U_l terms with both even and odd l, and the V_l terms with only even l.","category":"page"},{"location":"intro/#Operator-Spectrum-and-Search-for-Conformal-Point","page":"Introduction","title":"Operator Spectrum and Search for Conformal Point","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Having introduced the construction of an interacting model on the fuzzy sphere, we now turn to the verification of the conformal symmetry and the extraction of the CFT data. The most straightforward approach is to extract the scaling dimensions from the energy spectrum through the state-operator correspondence. Specifically, there is a one-to-one correspondence between the eigenstates of the Hamiltonian and the CFT operators. The state and its corresponding operator has the same mathrmSO(3) spin and representation under flavour symmetry, and the excitation energy of a state Phirangle is proportional to the scaling dimension of the corresponding operator Delta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    E_Phi-E_0=fracvRDelta_Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where E_0 is the ground state energy, R is the radius of the sphere (here we take R=sqrtN_m), and v is a model-dependent speed of light. The constant vR can be determined through a calibration process, i. e. comparing the spectrum to some known properties of a CFT spectrum. The criteria to determine the conformal symmetry include","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The existence of a conserved stress tensor T^munu. The stress tensor is the symmetry current of the translation transformation. It is known to be a singlet under the flavour symmetry, have spin-2 under mathrmSO(3) rotation and scaling dimension exactly Delta_T^munu=3.\nThe existence of a conserved flavour symmetry current J^mu if there is a continuous flavour symmetry. The symmetry current typically lives in the antisymmetric rank-2 tensor representation of the flavour symmetry. E. g., if the flavour symmetry is mathrmU(1), then the symmetry current has charge-0 ; if the flavour symmetry is mathrmO(3), then the symmetry current has spin-1 and is odd under the improper mathbbZ_2 transformation ; if the flavour symmetry is mathrmO(n) (nge 4) or mathrmSU(n) (nge 3), then the symmetry current lives in the antisymmetric rank-2 tensor representation.\nThe organisation of the operator spectrum into conformal multiplets. All the levels in the spectrum of a CFT can be organised into the conformal primaries and their descendants. The descendants live in the same representation under the flavour symmetry as the primary, and the difference between the scaling dimensions of a primary and its descendant is an integer. Specifically, for a scalar primary Phi, its descendants have the form (Hereafter, we will presume the subtraction of trace and omit the terms)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Box^npartial^mu_1partial^mu_2dotspartial^mu_lPhi-textrm(trace)qquad (nl=012dots)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"with mathrmSO(3) spin-l and scaling dimension ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta=Delta_Phi+2n+l","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where Box=partial_mupartial^mu. For a spinning primary Phi^mu_1dotsmu_s, its descendants has the two forms :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Box^npartial^nu_1dotspartial^nu_mpartial_rho_1dotspartial_rho_kPhi^rho_1dotsrho_kmu_1dots mu_s-kqquad (k=0dotssquad nm=01dots)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"with scaling dimension and mathrmSO(3) spin","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta=Delta_Phi+k+m+2nqquad l=s-k+m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Box^npartial^nu_1dotspartial^nu_mpartial_rho_1dotspartial_rho_kepsilon^sigma_tildemutildenupartial^tildenuPhi^rho_1dotsrho_ktildemumu_1dots mu_s-k-1qquad (k=0dotss-1quad nm=01dots)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"with","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta=Delta_Phi+k+m+2n+1qquad l=s-k+m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For the second form, the fully antisymmetric tensor epsilon alters the parity.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The most convenient way of determining the coefficient vR is by utilising criteria 1 or 2 :","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    fracvR=fracE_T^munu-E_03quadtextrmorquadfracE_J^mu-E_02","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Alternatively, one can define a cost function that depends on the tuning parameter and the speed of light and compares the scaling dimensions obtained from the fuzzy sphere and the prediction by conformal symmetry. E. g., for the Ising CFT, the tuning parameters are the pseudo-potentials U_i and the transverse field h. The criteria for conformal symmetry we use include the stress tensor T^munu and the descendants partial^musigma, partial^mupartial^nusigma, Boxsigma, partial^muepsilon. The cost function is the root-mean-square of the deviations of these criteria from the expectation of the conformal symmetry","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    Q^2(U_ihvN_m)=frac1N_sleft(Delta_T^munu^text(FS)-3)^2+(Delta_partial^musigma^text(FS)-Delta_sigma^text(FS)-1)^2right\n    qquadqquadleft+(Delta_partial^mupartial^nusigma^text(FS)-Delta_sigma^text(FS)-1)^2+(Delta_Boxsigma^text(FS)-Delta_sigma^text(FS)-1)^2+(Delta_partial^muepsilon^text(FS)-Delta_epsilon^text(FS)-1)^2right\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where N_s=5 is the number of criteria, the scaling dimension of an operator Phi on the fuzzy sphere is determined as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Delta_Phi^text(FS)(U_ihvN_m)=fracE_Phi-E_0vR","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The optimal conformal point and calibrator are determined by minimising this cost function for each system size N_m. Note that this optimal point depends on the system size. In order to do finite-size scaling, if the CFT describes a phase transition, one could fix all but one parameters at the optimal point in the largest accessible system size and tune the last parameter to determine the critical point through a finite-size scaling.","category":"page"},{"location":"intro/#Local-Observables","page":"Introduction","title":"Local Observables","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We have introduced how to determine the scaling dimensions from the energy spectrum. Beyond that, evaluating other CFT quantities requires realising local CFT operators on the fuzzy sphere. Any gapless local observables mathscrO(mathbfr) on the fuzzy sphere can be written as the linear combination of CFT operators that live in the same representation of flavour symmetry and parity","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathscrO(mathbfrtau)=sum_alpha lambda_alphaPhi^text(cyl)_alpha(mathbfrtau)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here special care should be taken for the CFT operator Phi^text(cyl)_alpha(mathbfrtau) on the cylinder. A conformal transformation produces a scale factor Lambda(mathbfr)^Delta_Phi to a primary operator Phi. The scale factor is Lambda(mathbfr)=rR for the Weyl transformation from the flat spacetime to the cylinder. Hence,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi^text(cyl)_alpha(mathbfrtau)=left(frace^tauRRright)^Delta_Phi_alphaPhi_alpha^text(flat)(x)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here we need to clarify some of the notations : mathscrO represents an operator in the microscopic model, and Phi represents a CFT operator ; the arguments Phi(mathbfr) or Phi(mathbfrtau) by default mean the operator is defined on a cylinder, and Phi(x) by default on flat spacetime. For descendants, certain other factors may be produced, but the conversion factors still scale with the radius of the sphere as R^-Delta where Delta is the scaling dimension of the descendants. For simplicity, hereafter we focus on the equal-time correlators with tau=0, for which Phi^text(cyl)_alpha(mathbfr)=R^-Delta_Phi_alphaPhi_alpha^text(flat)(x). The operator with larger system size decays faster when increasing system size.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The simplest local observable is the density operator defined in Section â€œDensity Operatorâ€. From the CFT perspective, the density operators are the superpositions of scaling operators with corresponding quantum numbers, i. e. with the same representation under flavour symmetry and parity.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Take the Ising model as an example. Consider the density operators n^x and n^z with matrix insertion M=sigma^xsigma^z. In the leading order, they can be used as UV realisations of CFT operators sigma and epsilon.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    n^x(mathbfr)=lambda_0+lambda_epsilonepsilon(mathbfr)+lambda_partial^muepsilonpartial^muepsilon(mathbfr)+lambda_T^munuT^munu(mathbfr)+dotsepsilon_textrmFS=fracn^x-lambda_0lambda_epsilon+dotsnonumber\n    n^z(mathbfr)=lambda_sigmasigma(mathbfr)+lambda_partial^musigmapartial^muepsilon(mathbfr)+lambda_partial^mupartial^nusigmapartial^mupartial^nusigma(mathbfr)+dotssigma_textrmFS=fracn^zlambda_sigma+dots\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the coefficients lambda_0lambda_epsilonlambda_sigmadots are model-dependent and need to be determined, and all the operators on the right-hand side are defined on the cylinder.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We first consider the insertion of a single operator langlePhi_1Phi_2(mathbfr)Phi_3rangle. It helps us produce the OPE coefficients. For the simplest example of three scalars, ","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    f_Phi_1Phi_2Phi_3=lim_r_inftytoinftyr_infty^-2Delta_Phi_1langle Phi_1(x_infty)Phi_2(x)Phi_3(0)rangle_text(flat)=langlePhi_1Phi_2^text(flat)(x)Phi_3rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where x_infty is a point on the sphere with radius r_infty, x is a point on the unit sphere, the states are obtained from acting the operator at the origin point on the vacuum state","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_3rangle=Phi_3(0)0rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"and its Hermitian conjugate is defined as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_1^dagger(infty)=(Phi_1(0))^dagger=lim_r_inftytoinftyr_infty^2Delta_Phi_1Phi_1(x_infty)qquadlanglePhi_1=langle0Phi_1^dagger(infty)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"After the Weyl transformation from the flat spacetime to the cylinder, we obtain the expression on the fuzzy sphere","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    f_Phi_1Phi_2Phi_3=R^Delta_Phi_2langlePhi_1Phi^(text(cyl))_2(mathbfr)Phi_3rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The UV realisation of Phi_2 contains many other operators with different spins. By integrating the correlation function against different spherical harmonics, i. e. take the angular modes of the operator inserted","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    intmathrmd^2mathbfrbarY_lm(hatmathbfn)langlePhi_1Phi_2(mathbfr)Phi_3rangle=langlePhi_1Phi_2lmPhi_3rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"we can filter out the subleading contributions with different spins. For the spinning operators, this also tells us about different OPE structures. By taking Phi_3=mathbbI, we can recover the 2-pt functions","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    langlePhi_2Phi_2000rangle=R^-Phi_2nonumber\n    Phi_2(mathbfr)0rangle=R^-Phi_2leftPhi_2rangle+lambda_mu(mathbfr)partial^muPhi_2rangle+lambda(mathbfr)BoxPhi_2rangle+lambda_munu(mathbfr)partial^mupartial^nuPhi_2rangleright\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"It is worth noting that acting a primary Phi_2(mathbfr) on the vacuum also produces various descendants in the multiplet.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In the example of Ising CFT, we first use the insertion of a single operator to determine the coefficients lambda_0lambda_epsilonlambda_sigma","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    lambda_0=fracR^-2sqrt4pilangle 0n^x_000ranglequadlambda_epsilon=fracR^Delta_epsilon-2sqrt4pilangle epsilonn^x_000ranglequadlambda_sigma=fracR^Delta_sigma-2sqrt4pilangle sigman^z_000rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Take the OPE coefficient f_sigmasigmaepsilon as an example. It can be expressed either as an inner product of sigma or epsilon","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    f_sigmasigmaepsilon=R^Delta_sigmalangleepsilonsigma(mathbfr)sigmarangle=fraclangleepsilonn_00^zsigmaranglelangle 0n_00^zsigmarangle+mathscrO(R^-2)nonumber\n    =R^Delta_epsilonlanglesigmaepsilon(mathbfr)sigmarangle=fraclanglesigman^x_00sigmarangle-langle0n^x_000ranglelangleepsilonn^x_000rangle+mathscrO(R^-(3-Delta_epsilon))\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For the first line, the subleading contribution comes from the contribution of the descendant Boxsigma to n_00^z. As sigma(mathbfr) scales as R^-Delta_sigma and Boxsigma(mathbfr) as R^-Delta_sigma-2,","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    langleepsilonn_00^zsigmarangle=f_sigmasigmaepsilonlambda_sigma R^-Delta_sigma(1+c_1R^-2+dots)nonumber\n    langleepsilonn_00^zsigmarangle=lambda_sigma R^-Delta_sigma(1+c_1R^-2+dots)nonumber\n    fraclangleepsilonn_00^zsigmaranglelangle 0n_00^zsigmarangle=f_sigmasigmaepsilon+mathscrO(R^-2)\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here c_1 and c_1 are constant factors that represent the contribution of Boxsigma and do not scale with system size. Hence, the subleading contribution scales as R^-2. For the second line, the subleading contribution comes from the stress tensor T^munu. Similarly, the power of the scaling is the difference of the scaling dimension R^-(Delta_T^munu-Delta_epsilon)=R^-(3-Delta_epsilon).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then proceed to the insertion of two operators. This can help us determine up to a 4-pt function. Through conformal transformation, any 4-pt function can be expressed in the form of","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    langlePhi_1Phi^textrm(cyl)_2(mathbfrtau)Phi^textrm(cyl)_3(hatmathbfz)Phi_4rangle=frace^Delta_Phi_2tauRR^Delta_Phi_2+Delta_Phi_3langlePhi_1^dagger(infty)Phi_2(x)Phi_3(hatmathbfz)Phi_4(0)rangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where the time-displaced operator can be defined as","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Phi_2(mathbfrtau)=e^-HtauPhi_2(mathbfr)e^Htau","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"As a sanity check, By taking Phi_1=Phi_4=mathbbI, Phi_2=Phi_3 and tau=0, the 2-pt function on the unit sphere is recovered","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    langle0Phi^textrm(cyl)_2(mathbfr)Phi^textrm(cyl)_2(hatmathbfz)0rangle=R^-2Delta_Phi_2langlePhi_2(mathbfr)Phi_2(hatmathbfz)rangle=frac1R^2Delta_Phi_2mathbfr-hatmathbfz^2Delta_Phi_2=frac1R^2Delta_Phi_2(1-costheta)^Delta_Phi_2","category":"page"},{"location":"intro/#Conformal-Generators","page":"Introduction","title":"Conformal Generators","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"So far, in the conformal group, we know that the rotation and the dilatation are manifest on the fuzzy sphere. The rest, viz. translation and SCT, are emergent. In this section, we consider how to express the generators of these emergent symmetries in terms of the microscopic operators.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"A general Noether current and corresponding generator of the infinitesimal spacetime transformation x^mumapsto x^mu+epsilon^mu(x) can be expressed in terms of the stress tensor","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    j_epsilon^mu(x)=epsilon^nu(x)T^mu_nu(x)quad Q_epsilon=int_Sigmamathrmd^d-1xsqrtgj_epsilon^0(x)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where for the second equation, the integral is evaluated on a closed surface Sigma. Specifically, for the generators P^muK^mu of translation and SCT in the embedded sphere","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    P^mu=intmathrmd^2mathbfr(r^mu T^0_0+iT^0mu)nonumber K^mu=intmathrmd^2mathbfr(r^mu T^0_0-iT^0mu)\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Hence, the conformal generator Lambda^mu=P^mu+K^mu is the l=1 component of the Hamiltonian density mathscrH=T^0_0","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=P_m+K_m=sqrtfrac16pi3intmathrmd^2mathbfrbarY_1m(hatmathbfn)mathscrH(mathbfr)","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here the indices mu and m are two equivalent way to express the components. By acting it on the states, the number of derivatives is increased or decreased by 1, e. g., for a primary Phi","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    Lambda^muPhirangle=textrmconsttimespartial^muPhiranglenonumber     Lambda^mupartial_muPhirangle=textrmconsttimesPhirangle+textrmconsttimespartial^mupartial^nuPhirangle+textrmconsttimesBoxPhirangle\nendaligned","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The derivation of the expression and the constant factors are calculated and given in Ref..","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"We then need to find the expression for the Hamiltonian density. For example, for the Ising model, it is the local density operator and density-density interactions with some full derivatives","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathscrH(mathbfr)=n_zleft(g_0+g_1nabla^2right)n_z-hn_x+g_D1nabla^2n_x+g_D2nabla^2n_z^2+dots","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"where g_Di are undetermined constants that does not affect the Hamiltonian H=intmathrmd^2mathbfrmathscrH. We have only listed a few examples of the allowed full derivatives.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To determine those constants, we consider another strategy by considering all the possible two-fermion and four-fermion operators that are singlet under flavour symmetry and spin-1 under mathrmSO(3). We consider the example of Ising CFT. The two-fermion terms include the density operators","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    n^x_1mquadtextrmandquad n^0_1m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Similar to what we have done for Hamiltonian, the four-fermion operators can be obtained by combining the fermion bilinears Delta_lm","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    sum_substackl_1l_2m_1m_2tildeU_l_1l_2Delta^dagger_l_1m_1Delta_l_2m_2langle (2s-l_1)m_1(2s-l_2)(-m_2)1mrangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"For l_1in2mathbbZ, the spin index in the pairing operator is antisymmetrised ; For l_1in2mathbbZ+1, the spin index in the pairing operator is symmetrised. Therefore, l_1-l_2in2mathbbZ for non-zero results. And since l_1-l_2leq 1, we conclude l_1=l_2. so","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    Lambda_m=sum_substacklm_1m_2tildeU_lDelta^dagger_lm_1Delta_lm_2beginpmatrix2s-l2s-l1-m_1m_2m     endpmatrix+tildehn^x_1m+tildemun^0_1m","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Here, tildeU_ltildehtildemu are tuning parameters.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"After obtaining Lambda^mu=P^mu+K^mu, the separate P^mu and K^mu can be obtained by considering the commutator with the dilatation generator D, which is proportional to the Hamiltonian. As DP^mu=P^mu and DK^mu=-K^mu.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"beginaligned\n    P^mu=tfrac12Lambda^mu+tfrac12DLambda^munonumber\n    K^mu=tfrac12Lambda^mu-tfrac12DLambda^mu\nendaligned","category":"page"},{"location":"intro/#Numerical-Methods","page":"Introduction","title":"Numerical Methods","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In this section, we briefly review the numerical methods supported in FuzzifiED. The numerical methods that have been applied to the fuzzy sphere include exact diagonalisation (ED), density matrix renormalisation group (DMRG) and determinant quantum Monte Carlo (DQMC). Among these, ED and DMRG have been implemented in FuzzifiED.","category":"page"},{"location":"intro/#Exact-Diagonalisation-(ED)","page":"Introduction","title":"Exact Diagonalisation (ED)","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Exact diagonalisation (ED) might be the most straightforward method for solving a quantum many-body Hamiltonian. In ED, one constructs a many-body basis and writes down all the non-zero elements of the Hamiltonian as a sparse matrix on this basis. The eigenstates of the Hamiltonian with the lowest energy can be solved without finding the full eigensystem by Arnoldi or Lanczos algorithm.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Briefly speaking, the Arnoldi algorithm is an iterative method. Each iteration constructs an orthonormal basis of the Krylov subspace from an initial vector and finds an approximation to the eigenvector on that basis. This approximate eigenvector is then used as the initial vector for the next iteration. An example of Krylov subspace is spanned by acting the matrix H repeatedly on the initial vector irangle","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"    mathscrK_r(Hirangle)=operatornamespanleftirangleHirangleH^2irangledotsH^r-1irangleright","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The ED calculation can be optimised in several ways. The storage of the Hamiltonian matrix may be compressed by data structure tailored for sparse matrix such as compressed sparse column (CSC). The Hamiltonian matrix is usually block diagonal due to the symmetry of the Hamiltonian. The Hilbert space is divided into several sectors that carry different representations under the symmetry, and acting the Hamiltonian on a state in a sector results in a state in the same sector. E. g., in the ED calculation for the Ising model on the fuzzy sphere, the symmetries we can use include two mathrmU(1) symmetries, viz. the conservation of particle number and the angular momentum in the z-direction, and three mathbbZ_2 symmetries, viz. the Ising mathbbZ_2 flavour symmetry, the particle-hole symmetry and the pi-rotation along the y-axis.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"The ED method enjoys several advantages, including (1) the full knowledge of the eigenstate wave-function and (2) the ability to access relatively high excited states. However, despite these optimisations, the dimension of the Hilbert space scales exponentially with the number of orbitals. This results in exponentially growing space and time complexity. E. g., for the Ising model on the fuzzy sphere, for N_m=14, the dimension of Hilbert space dimmathscrH=18times10^5 and the number of elements in the Hamiltonian is N_ textel=11times 10^7 ; for N_m=16, the numbers have already grown to dimmathscrH=22times10^6 and N_textel=21times 10^8, which translates to a memory demand of 31 gigabytes.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In FuzzifiED, we use the Fortran library Arpack to perform the Arnoldi algorithm.","category":"page"},{"location":"intro/#Density-Matrix-Renormalisation-Group-(DMRG)","page":"Introduction","title":"Density Matrix Renormalisation Group (DMRG)","text":"","category":"section"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"To overcome the size limit of ED, the density matrix renormalisation group (DMRG) is a powerful method to calculate the ground state of a quasi-one-dimensional system. It was first invented by White as an improvement to the numerical renormalisation group (NRG) used in the Kondo problem. Since its proposal, it has been proven potent in various problems in condensed matter physics, such as the static and dynamic properties of one-dimensional models such as the Heisenberg, tâ€“J and Hubbard models. Later, Schollw\\\"ock has discovered a new point of view that implements the DMRG in the language of matrix product states (MPS).","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Briefly speaking, in this language, DMRG is a variational method that optimises the fidelity between the exact ground state and the variational MPS. During each â€œsweep,â€ DMRG solves a local eigenvalue problem for the active tensors to improve the approximation. To find the excited states, one needs to add projection 0ranglelangle 0 of the ground state 0rangle to the Hamiltonian by hand.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"Although the fuzzy sphere deals with (2+1)-dimensional quantum systems, the basis of the lowest Landau level provides a natural way to express it as a quasi-1D problem. Therefore, DMRG has been a powerful numerical method for the fuzzy sphere. However, like other (2+1)D models, the DMRG on the fuzzy sphere also suffers from the divergence of the required maximal bond dimension with system size. One should thus be careful with the convergence of the results when doing DMRG.","category":"page"},{"location":"intro/","page":"Introduction","title":"Introduction","text":"In FuzzifiED, we use the ITensor library in Julia to perform the DMRG calculations.","category":"page"},{"location":"manifolds/#Fuzzy-Manifolds","page":"Fuzzy Manifolds","title":"Fuzzy Manifolds","text":"","category":"section"},{"location":"manifolds/","page":"Fuzzy Manifolds","title":"Fuzzy Manifolds","text":"FuzzyManifolds is a module to support calculations on other geometry regularised by lowest Landau level besides sphere. The supported geometries include torus T^2. Other geometries (e. g., disk) can be added upon request. To use the module, include also at the start of your Julia script","category":"page"},{"location":"manifolds/","page":"Fuzzy Manifolds","title":"Fuzzy Manifolds","text":"using FuzzifiED.FuzzyManifolds","category":"page"},{"location":"manifolds/#Torus","page":"Fuzzy Manifolds","title":"Torus","text":"","category":"section"},{"location":"manifolds/#FuzzifiED.FuzzyManifolds.GetTorusLz2QNDiag-Tuple{Int64, Int64}","page":"Fuzzy Manifolds","title":"FuzzifiED.FuzzyManifolds.GetTorusLz2QNDiag","text":"GetTorusLz2QNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of twice the angular momentum 2L_zmod 2N_m, with an offset such that one fully filled LLL has angular momentum 0, implemented as \n\nQNDiag(\"Lz\", [2 * m - 1 + mod(nm, 2) for m = 1 : nm for f = 1 : nf], 2 * nm)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#FuzzifiED.FuzzyManifolds.GetTorusTranslQNOffd-Tuple{Int64, Int64}","page":"Fuzzy Manifolds","title":"FuzzifiED.FuzzyManifolds.GetTorusTranslQNOffd","text":"GetTorusTranslQNOffd(nm :: Int64, nf :: Int64, Î” :: Int64 = 1) :: QNOffd\n\nReturn the QNOffd of translation \n\n    c_mc_m+Î”mod N_m\n\non the torus, implemented as \n\n    QNOffd([((m - 1 + Î”) % nm) * nf + f for m = 1 : nm for f = 1 : nf], nm)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#FuzzifiED.FuzzyManifolds.GetTorusIntMatrix-Tuple{Int64, Number, Vector{<:Number}}","page":"Fuzzy Manifolds","title":"FuzzifiED.FuzzyManifolds.GetTorusIntMatrix","text":"GetTorusIntMatrix(nm :: Int64, lx :: Number, ps_pot :: Vector{<:Number}) :: Array{ComplexF64, 3}\nGetTorusIntMatrix(nm :: Int64, ps_pot :: Vector{<:Number} ; aspect_ratio :: Number = 1.0) :: Array{ComplexF64, 3}\n\nGives the interaction matrix U_m_1m_2m_3m_4 from the pseudopotentials.\n\n    U_m_1m_2m_3m_4=Î´_m_1+m_2m_3+m_4frac1N_m_lðªÎ´_m_1-m_4tU_lL_l(q^2)e^-q^22e^2Ï€is(m_1-m_3)N_m\n\nwhere ðª=(2Ï€sL_x2Ï€tL_y) stâ„¤, L_xL_y=2Ï€N_m and the Kronecker Î´ is defined in a sense of mod N_m\n\nArgument\n\nnm :: Int64 is the number of orbitals.\nlx :: Number is the length along x-direction. Facultative.\nps_pot :: Vector{<:Number} is the vector of non-zero pseudopotentials.\naspect_ratio :: Number is the ratio L_yL_x. Facultative, at most one of lx and aspect_ratio is given. If both are omitted, L_x=L_y is taken. \n\nOutput\n\nA nmÃ—nmÃ—nm array giving the interaction matrix U_m_1m_2m_3m_4 where m_4=m_1+m_2-m_3mod N_m.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#FuzzifiED.FuzzyManifolds.GetTorusDenIntTerms","page":"Fuzzy Manifolds","title":"FuzzifiED.FuzzyManifolds.GetTorusDenIntTerms","text":"GetTorusDenIntTerms(nm :: Int64, nf :: Int64, lx :: Number, ps_pot :: Vector{<:Number}[, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]]) :: Terms\nGetTorusDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}[, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]] ; aspect_ratio :: Number = 1.0) :: Terms\n\nReturn the normal-ordered density-density term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nlx :: Number is the length along x-direction. Facultative.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \naspect_ratio :: Number is the ratio L_yL_x. Facultative, at most one of lx and aspect_ratio is given. If both are omitted, L_x=L_y is taken. \n\n\n\n\n\n","category":"function"},{"location":"manifolds/#FuzzifiED.FuzzyManifolds.GetTorusPairIntTerms","page":"Fuzzy Manifolds","title":"FuzzifiED.FuzzyManifolds.GetTorusPairIntTerms","text":"GetTorusPairIntTerms(nm :: Int64, nf :: Int64, lx :: Number, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]) :: Terms\nGetTorusPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}] ; aspect_ratio :: Number = 1.0) :: Terms\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_3f_4c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nlx :: Number is the length along x-direction. Facultative.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \naspect_ratio :: Number is the ratio L_yL_x. Facultative, at most one of lx and aspect_ratio is given. If both are omitted, L_x=L_y is taken. \n\n\n\n\n\n","category":"function"},{"location":"manifolds/#Related-Examples","page":"Fuzzy Manifolds","title":"Related Examples","text":"","category":"section"},{"location":"manifolds/","page":"Fuzzy Manifolds","title":"Fuzzy Manifolds","text":"circle_ising.jl calculates the spectrum of 2d Ising CFT on a fuzzy thin torus. This example reproduces Figure 4 and Tables Iâ€”III in Han 2025","category":"page"},{"location":"models/#Built-in-models","page":"Built-in Models","title":"Built-in models","text":"","category":"section"},{"location":"models/#Diagonal-Quantum-Numbers-on-the-Fuzzy-Sphere","page":"Built-in Models","title":"Diagonal Quantum Numbers on the Fuzzy Sphere","text":"","category":"section"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"The following diagonal quantum numbers (symmetry charges) on the fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/#FuzzifiED.GetNeQNDiag-Tuple{Int64}","page":"Built-in Models","title":"FuzzifiED.GetNeQNDiag","text":"GetNeQNDiag(no :: Int64[, modul :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of the number of electrons, implemented as \n\nQNDiag(\"Ne\", fill(1, no), modul)\n\nIf modul = 2, parity is returned.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetLz2QNDiag-Tuple{Int64, Int64}","page":"Built-in Models","title":"FuzzifiED.GetLz2QNDiag","text":"GetLz2QNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of twice the angular momentum 2L_z, implemented as \n\nQNDiag(\"Lz\", collect(0 : nm * nf - 1) .Ã· nf .* 2 .- (nm - 1))\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetFlavQNDiag","page":"Built-in Models","title":"FuzzifiED.GetFlavQNDiag","text":"GetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Dict{Int64, Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag \nGetFlavQNDiag(nm :: Int64, nf :: Int64, qf :: Vector{Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of linear combination of number of electrons in each flavour, \n\n    Q = _fq_fn_f\n\nthe factor q_f can either be given by a length-N_f vector or a dictionary containing non-zero terms. E.g., for Q=n_f=1-n_f=3 in a 4-flavour system, qf = [1, 0, -1, 0] or qf = Dict(1 => 1, 3 => -3). id is an index to be put in the name to distinguish. For qf given as vector, the function is implemented as \n\nQNDiag(\"Sz$id\", qf[collect(0 : nm * nf - 1) .% nf .+ 1], modul)\n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetZnfChargeQNDiag-Tuple{Int64, Int64}","page":"Built-in Models","title":"FuzzifiED.GetZnfChargeQNDiag","text":"GetZnfChargeQNDiag(nm :: Int64, nf :: Int64) :: QNDiag\n\nReturn the QNDiag of a â„¤_N_f-charge, \n\n    Q = _f=0^N_f-1fn_fmod N_f\n\nimplemented as \n\nQNDiag(\"Q_Z$nf\", collect(0 : nm * nf - 1) .% nf, nf)\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPinOrbQNDiag","page":"Built-in Models","title":"FuzzifiED.GetPinOrbQNDiag","text":"GetPinOrbQNDiag(no :: Int64, pin_o :: Vector{Int64}[, id :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of the number of electrons in the subset of sites pin_o, implemented as\n\nQNDiag(\"Npin$i\", [ o in pin_o ? 1 : 0 for o = 1 : no])\n\nThis QNDiag is useful in pinning defects, where certain subset of sites need to be set empty or filled. To empty the sites, set this QNDiag to 0 ; to fill the sites, set this QNDiag to length(pin_o). id is an index to be put in the name to distinguish. \n\n\n\n\n\n","category":"function"},{"location":"models/#Off-diagonal-Quantum-Numbers-on-the-Fuzzy-Sphere","page":"Built-in Models","title":"Off-diagonal Quantum Numbers on the Fuzzy Sphere","text":"","category":"section"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"The following off-diagonal quantum numbers (transformations) on the fuzzy sphere are built in in FuzzifiED.","category":"page"},{"location":"models/#FuzzifiED.GetParityQNOffd","page":"Built-in Models","title":"FuzzifiED.GetParityQNOffd","text":"GetParityQNOffd(nm :: Int64, nf :: Int64[, permf, fac])\n\nReturn the particle-hole transformation \n\n    ð’« c^_mfÎ±_fc_mÏ€_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation Ï€_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor Î±_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetFlavPermQNOffd","page":"Built-in Models","title":"FuzzifiED.GetFlavPermQNOffd","text":"GetFlavPermQNOffd(nm :: Int64, nf :: Int64, permf[, fac][, cyc :: Int64])\n\nReturn the flavour permutaiton transformation \n\n    ð’µ c^_mfÎ±_fc^_mÏ€_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation Ï€_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor Î±_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \ncyc :: Int64 is the period of the permutation. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetRotyQNOffd-Tuple{Int64, Int64}","page":"Built-in Models","title":"FuzzifiED.GetRotyQNOffd","text":"GetRotyQNOffd(nm :: Int64, nf :: Int64)\n\nReturn the Ï€-rotation with respect to the y-axis. \n\n    â„›_y c^_mf(-)^m+sc^_-mf\n\n\n\n\n\n","category":"method"},{"location":"models/#Operators-on-the-Fuzzy-Sphere","page":"Built-in Models","title":"Operators on the Fuzzy Sphere","text":"","category":"section"},{"location":"models/#FuzzifiED.GetIntMatrix-Tuple{Int64, Vector{<:Number}}","page":"Built-in Models","title":"FuzzifiED.GetIntMatrix","text":"GetIntMatrix(nm :: Int64, ps_pot :: Vector{<:Number}) :: Array{ComplexF64, 3}\n\nGives the interaction matrix U_m_1m_2m_3m_4 from the pseudopotentials.\n\nArgument\n\nnm :: Int64 is the number of orbitals.\nps_pot :: Vector{<:Number} is the vector of non-zero pseudopotentials.\n\nOutput\n\nA nmÃ—nmÃ—nm array giving the interaction matrix U_m_1m_2m_3-m_1-m_2-m_3.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDenIntTerms","page":"Built-in Models","title":"FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64[, ps_pot :: Vector{<:Number}][, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the normal-ordered density-density term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default. \nmat_a :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetDenIntTerms-2","page":"Built-in Models","title":"FuzzifiED.GetDenIntTerms","text":"GetDenIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Vector{<:AbstractMatrix{<:Number}}[, mat_b :: Vector{<:AbstractMatrix{<:Number}}][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the sum of a series of normal-ordered density-density term in the Hamiltonian \n\n_m_if_iÎ±U_m_1m_2m_3m_4(M^A_Î±)_f_1f_4(M^B_Î±)_f_2f_3c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default.\nmat_a :: Vector{<:AbstractMatrix{<:Number}} is a vector of nfÃ—nf matrix specifying (M^A_Î±)_ff. Facultative, I_N_f by default. \nmat_b :: Vector{<:AbstractMatrix{<:Number}} is a vector of nfÃ—nf matrix specifying (M^B_Î±)_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetPairIntTerms","page":"Built-in Models","title":"FuzzifiED.GetPairIntTerms","text":"GetPairIntTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}][ ; m_kept :: Vector{Int64}]) :: Terms\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian \n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_3f_4c^_m_1f_1c^_m_2f_2c_m_3f_3c_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \nm_kept :: Vector{Int64} is a list of orbitals that range from 1 to nm. Facultative, if specified, only terms for which all m_i are in the list are kept. \n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetPolTerms-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in Models","title":"FuzzifiED.GetPolTerms","text":"GetPolTerms(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; fld_m :: Vector{<:Number}]) :: Terms\n\nReturn the polarisation term in the Hamiltonian \n\n_mffc^_mfM_ffc_mf\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours. \nmat :: Matrix{<:Number} is a nfÃ—nf matrix specifying M_ff. Facultative, I_N_f by default. \nfld_m :: Vector{<:Number} gives an orbital dependent polarisation\n\n_mffh_mc^_mfM_ffc_mf\n\nFacultative. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetL2Terms-Tuple{Int64, Int64}","page":"Built-in Models","title":"FuzzifiED.GetL2Terms","text":"GetL2Terms(nm :: Int64, nf :: Int64) :: Terms\n\nReturn the terms for the total angular momentum.\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetLpLzTerms","page":"Built-in Models","title":"FuzzifiED.GetLpLzTerms","text":"GetLpLzTerms(nm :: Int64, nf :: Int64) :: Tuple{Terms, Terms}\n\nReturn the a pair of terms containing L^z and L^+\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\n\n\n\n\n\n","category":"function"},{"location":"models/#FuzzifiED.GetL2Terms-Tuple{Tuple{Vector{Term}, Vector{Term}}}","page":"Built-in Models","title":"FuzzifiED.GetL2Terms","text":"GetL2Terms(tms_lzlp :: Tuple{Terms, Terms}) :: Terms\n\nReturn the terms for the total angular momentum from a tuple of terms containing L^z and L^+, implemented as \n\ntms_lz, tms_lp = tms_lzlp \nreturn SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lp')\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetC2Terms","page":"Built-in Models","title":"FuzzifiED.GetC2Terms","text":"GetC2Terms(nm :: Int64, nf :: Int64, mat_gen :: Vector{Matrix{<:Number}}[, mat_tr :: Vector{Matrix{<:Number}}]) :: Terms\n\nReturn the terms for the quadratic Casimir of the flavour symmetry.\n\n    C_2=_immfrac(c^_mf_1G_if_1f_2c_mf_2)(c^_mf_3G^_if_3f_4c_mf_4)2operatornametrG_i^G_i-_immfrac(c^_mf_1T_if_1f_2c_mf_2)(c^_mf_3T^_if_3f_4c_mf_4)2operatornametrT_i^T_i\n\nwhere G_i are the generator matrices, and T_i are the trace matrices. \n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nmat_gen :: Vector{Matrix{Number}} is a list of the matrices that gives the generators. It will automatically be normalised such that its square traces to 12. \nmat_tr :: Vector{Matrix{Number}} is a list of trace matrices that will be normalised automatically and substracted. Facultative.\n\n\n\n\n\nGetC2Terms(nm :: Int64, nf :: Int64, group :: Symbol) :: Terms\n\nReturn the terms for the quadratic Casimir of the flavour symmetry for a built-in Lie-group\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\ngroup :: Symbol specifies the built-in Lie group. \n:Sp gives the Casimir of mathrmSp(N_f2)\n:SU gives the Casimir of mathrmSU(N_f)\n\nbeginaligned\n    C_2mathrmSp=-frac14(c^_m_1f_1c_m_1f_2)(c^_m_2f_3c_m_2f_4)Î©_f_1f_3Î©_f_2f_4+frac14(c^_m_1f_1c_m_1f_2)(c^_m_2f_2c_m_2f_1)\n    C_2mathrmSU=frac12(c^_m_1f_1c_m_1f_2)(c^_m_2f_2c_m_2f_1)-frac12N_f(c^_m_1f_1c_m_1f_1)(c^_m_2f_2c_m_2f_2)\nendaligned\n\n\n\n\n\n","category":"function"},{"location":"models/#Spherical-Observables","page":"Built-in Models","title":"Spherical Observables","text":"","category":"section"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"FuzzifiED supports local observables on sphere that can be decomposed into angular components Phi(Omega)=sum_lmPhi_lmY^(s)_lm","category":"page"},{"location":"models/#FuzzifiED.SphereObs","page":"Built-in Models","title":"FuzzifiED.SphereObs","text":"SphereObs\n\nThe mutable type SphereObs stores the information of a local observable (or local operator) ð’ª that can be decomposed into angular components.\n\n    ð’ª(Omega)=_lmð’ª_lmY^(s)_lm\n\nFields\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the observable is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/#FuzzifiED.SphereObs-Tuple{Int64, Int64, Function}","page":"Built-in Models","title":"FuzzifiED.SphereObs","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and the function (lm)ð’ª_lm.\n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.SphereObs-Tuple{Int64, Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in Models","title":"FuzzifiED.SphereObs","text":"SphereObs(s2 :: Int64, l2m :: Int64, comps :: Dict{Tuple{Int64, Int64}, Terms}) :: SphereObs\n\ninitialises the observable from 2s, 2l_max and a list of ð’ª_lm specified by a dictionary. \n\nArguments\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/#FuzzifiED.StoreComps!-Tuple{SphereObs}","page":"Built-in Models","title":"FuzzifiED.StoreComps!","text":"StoreComps!(obs :: SphereObs)\n\ncalculates and stores each component of the observable obs and replace the function in obs by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.StoreComps-Tuple{SphereObs}","page":"Built-in Models","title":"FuzzifiED.StoreComps","text":"StoreComps(obs :: SphereObs) :: SphereObs\n\ncalculates and stores each component of the observable obs and return a new observable with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"The multiplication, addition, conjugate and Laplacian operation of an observable is supported ","category":"page"},{"location":"models/#Base.:*-Tuple{Number, SphereObs}","page":"Built-in Models","title":"Base.:*","text":"*(fac :: Number, obs :: SphereObs) :: SphereObs\n*(obs :: SphereObs, fac :: Number) :: SphereObs\n/(obs :: SphereObs, fac :: Number) :: SphereObs\n-(obs :: SphereObs) :: SphereObs\n\nenables the multiplication of an observable with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{SphereObs, SphereObs}","page":"Built-in Models","title":"Base.:+","text":"+(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n-(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the addition of two observables.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{SphereObs}","page":"Built-in Models","title":"Base.adjoint","text":"adjoint(obs :: SphereObs) :: SphereObs\n\nenables the Hermitian conjugate of a spherical observable.\n\nbeginaligned\n    ð’ª^(Î©)=_lm(ð’ª_lm)^barY^(s)_lm(Î©)=_lm(ð’ª_lm)^(-1)^s+mY^(-s)_l-m(Î©)\n    (ð’ª^)_lm=(-1)^s-m(ð’ª_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{SphereObs, SphereObs}","page":"Built-in Models","title":"Base.:*","text":"*(obs1 :: SphereObs, obs2 :: SphereObs) :: SphereObs\n\nenables the multiplication of two observable by making use of the composition of two monopole harmonics into one. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.Laplacian-Tuple{SphereObs}","page":"Built-in Models","title":"FuzzifiED.Laplacian","text":"Laplacian(obs :: SphereObs[ ; norm_r2 :: Float64]) :: SphereObs\n\nTakes the Laplacian of an observable\n\n    (^2ð’ª)_lm=-l(l+1)ð’ª_lm\n\nArguments\n\nnorm_r2 :: Float64 is the radius squared R^2 used for normalisation. Facultative, ObsNormRadSq by default. If R1, an extra factor 1R^2 is included. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"Padding orbitals for SphereObs is realised ","category":"page"},{"location":"models/#FuzzifiED.PadSphereObs","page":"Built-in Models","title":"FuzzifiED.PadSphereObs","text":"PadSphereObs(obs :: SphereObs, nol :: Int64)\n\nadds nol empty orbitals to the left by shifting each orbital index, implemented as \n\nSphereObs(obs.s2, obs.l2m, (l, m) -> PadTerms(obs.get_comp(l, m), nol))\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"Here, two parameters ObsNormRadSq and ObsMomIncr are respectively used to specify the normalisation of the observables and whether it increases or decreases L^z","category":"page"},{"location":"models/#FuzzifiED.ObsNormRadSq","page":"Built-in Models","title":"FuzzifiED.ObsNormRadSq","text":"FuzzifiED.ObsNormRadSq :: Float64\n\nThe default radius squared R^2 that is used to normalise the observables, 1 by default. In the convention of He2025, R^2=N_m.\n\n\n\n\n\n","category":"constant"},{"location":"models/#FuzzifiED.ObsMomIncr","page":"Built-in Models","title":"FuzzifiED.ObsMomIncr","text":"FuzzifiED.ObsMomIncr :: Bool\n\nA flag to control whether action of ð’ª_lm increases or decreases the L^z component of the angular momentum, false by default, true in the convention of He2025. \n\n\n\n\n\n","category":"constant"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"One can evaluate an angular component, the value at one point, the uniform spatial integral of an observable, or filter a specific set of components.","category":"page"},{"location":"models/#FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}","page":"Built-in Models","title":"FuzzifiED.GetComponent","text":"GetComponent(obs :: SphereObs, l :: Number, m :: Number) :: Terms\n\nreturns an angular component ð’ª_lm of an observable in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}","page":"Built-in Models","title":"FuzzifiED.GetPointValue","text":"GetPointValue(obs :: SphereObs, Î¸ :: Float64, Ï• :: Float64) :: Terms\n\nevaluates an observable at one point ð’ª(Î¸Ï•) in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetIntegral-Tuple{SphereObs}","page":"Built-in Models","title":"FuzzifiED.GetIntegral","text":"GetIntegral(obs :: SphereObs[ ; norm_r2 :: Float64]) :: Terms\n\nreturns the uniform spatial integral mathrmd^2ð«ð’ª(ð«) in the format of a list of terms.\n\nArguments\n\nnorm_r2 :: Float64 is the radius squared R^2 used for normalisation. Facultative, ObsNormRadSq by default. If R1, an extra factor R^2 is included. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterComponent-Tuple{SphereObs, Any}","page":"Built-in Models","title":"FuzzifiED.FilterComponent","text":"FilterComponent(obs :: SphereObs, flt) :: AngModes\n\nreturns an observable object with certain modes filtered out.\n\nArguments\n\nobs :: SphereObs is the original observable\nflt is the filter function whose input is the pair (lm) and output is a logical that indicates whether this mode is chosen. E.g., if one wants to filter out the components with L^z=0, one should put (l, m) -> m == 0.\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/#FuzzifiED.GetElectronObs-Tuple{Int64, Int64, Int64}","page":"Built-in Models","title":"FuzzifiED.GetElectronObs","text":"GetElectronObs(nm :: Int64, nf :: Int64, f :: Int64[ ; norm_r2 :: Float64, mom_incr :: Bool]) :: SphereObs\n\nreturns the electron annihilation operator Ïˆ_f.\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the flavour to be taken.\nnorm_r2 :: Float64 is the radius squared R^2 used for normalisation. Facultative, ObsNormRadSq by default. If R1, an extra factor 1R is included. \nmom_incr :: Bool controls whether the observable increases or decreases L^z. Facultative, ObsMomIncr by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDensityObs-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in Models","title":"FuzzifiED.GetDensityObs","text":"GetDensityObs(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; norm_r2 :: Float64, mom_incr :: Bool]) :: SphereObs\n\nreturns the density operator n=_ffÏˆ^_fM_ffÏˆ_f\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix ð•€ by default.\nnorm_r2 :: Float64 is the radius squared R^2 used for normalisation. Facultative, ObsNormRadSq by default. If R1, an extra factor 1R^2 is included. \nmom_incr :: Bool controls whether the observable increases or decreases L^z. Facultative, ObsMomIncr by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPairingObs-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in Models","title":"FuzzifiED.GetPairingObs","text":"GetPairingObs(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}[ ; norm_r2 :: Float64, mom_incr :: Bool]) :: SphereObs\n\nreturns the pair operator Î”=_ffÏˆ_fM_ffÏˆ_f.\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\nnorm_r2 :: Float64 is the radius squared R^2 used for normalisation. Facultative, ObsNormRadSq by default. If R1, an extra factor 1R^2 is included. \nmom_incr :: Bool controls whether the observable increases or decreases L^z. Facultative, ObsMomIncr by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#Angular-Modes","page":"Built-in Models","title":"Angular Modes","text":"","category":"section"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"An angular modes object is similar to spherical observables except that it superposes in the rule of Clebsch-Gordan coefficients and does not have the notion of locality.","category":"page"},{"location":"models/#FuzzifiED.AngModes","page":"Built-in Models","title":"FuzzifiED.AngModes","text":"AngModes\n\nThe mutable type AngModes stores angular momentum components of an operator on the sphere Î¦_lm and superposes in the rule of Clebsch-Gordan coefficients. The usage is similar to the spherical observables, except that SphereObs superposes in the rule of spherical harmonics and has the notion of locality\n\nFields\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the modes object is stored.\ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"type"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"It can be initialised with the following methods ","category":"page"},{"location":"models/#FuzzifiED.AngModes-Tuple{Int64, Function}","page":"Built-in Models","title":"FuzzifiED.AngModes","text":"AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2l_max and the function (lm)Phi_lm\n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: Terms that sends the component specified by a tuple of integers (2l2m) where sleq sleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.AngModes-Tuple{Int64, Dict{Tuple{Int64, Int64}, Vector{Term}}}","page":"Built-in Models","title":"FuzzifiED.AngModes","text":"AngModes(l2m :: Int64, get_comp :: Function) :: AngModes\n\ninitialises the modes object from 2l_max and a list of Phi_lm specified by a dictionary. \n\nArguments\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \ncomps :: Dict{Tuple{Int64, Int64}, Terms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"The following methods explicitly calculates and stores each component","category":"page"},{"location":"models/#FuzzifiED.StoreComps!-Tuple{AngModes}","page":"Built-in Models","title":"FuzzifiED.StoreComps!","text":"StoreComps!(amd :: AngModes)\n\ncalculates and stores each component of the modes object amd and replace the function in amd by the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.StoreComps-Tuple{AngModes}","page":"Built-in Models","title":"FuzzifiED.StoreComps","text":"StoreComps(amd :: AngModes) :: AngModes\n\ncalculates and stores each component of the modes object amd and return a new modes object with the list of calculated components. \n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"The multiplication, addition and conjugate of an observable is supported ","category":"page"},{"location":"models/#Base.:*-Tuple{Number, AngModes}","page":"Built-in Models","title":"Base.:*","text":"*(fac :: Number, amd :: AngModes) :: AngModes\n*(amd :: AngModes, fac :: Number) :: AngModes\n/(amd :: AngModes, fac :: Number) :: AngModes\n-(amd :: AngModes) :: AngModes\n\nenables the multiplication of a mode with a number.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:+-Tuple{AngModes, AngModes}","page":"Built-in Models","title":"Base.:+","text":"+(amd1 :: AngModes, amd2 :: AngModes) :: AngModes\n-(amd1 :: AngModes, amd2 :: AngModes) :: AngModes\n\nenables the addition of two modes.\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.adjoint-Tuple{AngModes}","page":"Built-in Models","title":"Base.adjoint","text":"adjoint(amd :: AngModes) :: AngModes\n\nenables the Hermitian conjugate of a spherical mode.\n\nbeginaligned\n    (Î¦^)_lm=(-1)^l+m(Î¦_l-m)^\nendaligned\n\n\n\n\n\n","category":"method"},{"location":"models/#Base.:*-Tuple{AngModes, AngModes}","page":"Built-in Models","title":"Base.:*","text":"*(amd1 :: AngModes, amd2 :: AngModes) :: AngModes\n\nenables the multiplication of two modes in the rule of CG coefficients. \n\n    Î¦_lm=_l_1l_2m_1m_2Î´_mm_1+m_2l_1m_1l_2m_2lmÎ¦_l_1m_1Î¦_l_2m_2\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"Padding orbitals for AngModes is realised ","category":"page"},{"location":"models/#FuzzifiED.PadAngModes","page":"Built-in Models","title":"FuzzifiED.PadAngModes","text":"PadAngModes(amd :: AngModes, nol :: Int64)\n\nadds nol empty orbitals to the left by shifting each orbital index, implemented as \n\nAngModes(amd.l2m, (l, m) -> PadTerms(amd.get_comp(l, m), nol))\n\n\n\n\n\n","category":"function"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"One can take out either one or a set of components, or contract two angular modes. ","category":"page"},{"location":"models/#FuzzifiED.GetComponent-Tuple{AngModes, Number, Number}","page":"Built-in Models","title":"FuzzifiED.GetComponent","text":"GetComponent(amd :: AngModes, l :: Number, m :: Number) :: Terms\n\nreturns an angular component Î¦_lm of a modes object in the format of a list of terms.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterL2-Tuple{AngModes, Number}","page":"Built-in Models","title":"FuzzifiED.FilterL2","text":"FilterL2(amd :: AngModes, l :: Number) :: AngModes\n\nreturns an angular modes object with modes of a certain total angular momentum filtered out.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.FilterComponent-Tuple{AngModes, Any}","page":"Built-in Models","title":"FuzzifiED.FilterComponent","text":"FilterComponent(amd :: AngModes, flt) :: AngModes\n\nreturns an angular modes object with certain modes filtered out.\n\nArguments\n\namd :: AngModes is the original angular modes\nflt is the filter function whose input is the pair (lm) and output is a logical that indicates whether this mode is chosen. E.g., if one wants to filter out the modes with angular momentum l0, one should put (l, m) -> l == l0.\n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.ContractMod-Tuple{AngModes, AngModes, Dict}","page":"Built-in Models","title":"FuzzifiED.ContractMod","text":"ContractMod(amd1 :: AngModes, amd2 :: amd2, comps :: Dict) :: Terms\nContractMod(amd1 :: AngModes, amd2 :: AngModes, l0 :: Number) :: Terms\n\nReturn the contraction of two angular modes \n\n    _lU_l_m=-l^l(-1)^l+mÎ¦_1lÎ¦_2l(-m)\n\nwhere the list of U_l is given by a dictionary, or\n\n    U_lâ‚€_m=-lâ‚€^lâ‚€(-1)^lâ‚€+mÎ¦_1lâ‚€mÎ¦_2lâ‚€(-m)\n\n\n\n\n\n","category":"method"},{"location":"models/","page":"Built-in Models","title":"Built-in Models","text":"Three types of operators, viz. electrons and density operators, and pairing operators are built-in.","category":"page"},{"location":"models/#FuzzifiED.GetElectronMod-Tuple{Int64, Int64, Int64}","page":"Built-in Models","title":"FuzzifiED.GetElectronMod","text":"GetElectronMod(nm :: Int64, nf :: Int64, f :: Int64[ ; mom_incr :: Bool]) :: AngModes\n\nreturns the modes of electron annihilation operator c_m, with angular momentum s=(N_m-1)2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nf :: Int64 is the index of the flavour to be taken.\nmom_incr :: Bool controls whether the observable increases or decreases L^z. Facultative, ObsMomIncr by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetPairingMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in Models","title":"FuzzifiED.GetPairingMod","text":"GetPairingMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}[ ; mom_incr :: Bool]) :: AngModes\n\nreturns the modes of two electrons superposed in the rule of CG coefficients. \n\n    Î”_lm=_m_1m_2Î´_mm_1+m_2sm_1sm_2lmc_am_1M_abc_bm_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff.\nmom_incr :: Bool controls whether the observable increases or decreases L^z. Facultative, ObsMomIncr by default. \n\n\n\n\n\n","category":"method"},{"location":"models/#FuzzifiED.GetDensityMod-Tuple{Int64, Int64, Matrix{<:Number}}","page":"Built-in Models","title":"FuzzifiED.GetDensityMod","text":"GetDensityMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}[ ; mom_incr :: Bool]) :: AngModes\n\nreturns the modes of electron creation and annihilation superposed in the rule of CG coefficients. \n\n    n_lm=_m_1m_2Î´_m-m_1+m_2(-1)^s+m_1s(-m_1)sm_2lmc^_m_1c_m_2\n\nArguments\n\nnf :: Int64 is the number of flavours.\nnm :: Int64 is the number of orbitals.\nmat :: Int64 is the matrix M_ff. Facultative, identity matrix ð•€ by default.\nmom_incr :: Bool controls whether the observable increases or decreases L^z. Facultative, ObsMomIncr by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Fuzzifino","page":"Fuzzifino","title":"Fuzzifino","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"Fuzzifino is a module for exact diagonalisation (ED) calculation on the fuzzy sphere for systems with both bosons and fermions. The usage is similar to FuzzifiED, with new types SQNDiag, SQNOffd, SConf, SBasis, STerm and SOperator defined. To use the module, include also at the start of your Julia script","category":"page"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"using FuzzifiED.Fuzzifino","category":"page"},{"location":"fuzzifino/#Core-Functions","page":"Fuzzifino","title":"Core Functions","text":"","category":"section"},{"location":"fuzzifino/#Environment-Parameter","page":"Fuzzifino","title":"Environment Parameter","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.Libpathino","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.Libpathino","text":"Fuzzifino.Libpathino :: String = FuzzifiED_jll.LibpathFuzzifino\n\ndefine path of the Fortran library libfuzzifino.so. You do not need to modify that by yourself. However, if you compile the Fortran codes by yourself, you need to point this to your compiled library. \n\n\n\n\n\n","category":"constant"},{"location":"fuzzifino/#Quantum-Numbers","page":"Fuzzifino","title":"Quantum Numbers","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The diagonal and off-diagonal quantum numbers are implemented as","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNDiag","text":"SQNDiag\n\nThe mutable type SQNDiag records the information of a diagonal mathrmU(1) or â„¤_p quantum number in the form of a symmetry charge\n\nQ=_o=1^N_ofq_fon_fo+_o=1^N_obq_bon_bo\n\nor\n\nQ=_o=1^N_ofq_fon_fo+_o=1^N_obq_bon_bo mathrmmod p\n\nwhere i=1N_U is the index of quantum number, o is the index of site, N_of and N_ob are the number of fermionic and bosonic sites, n_fo=f^_of_o, n_bo=b^_ob_o, and q_foq_bo are a set of symmetry charges that must be integer valued.\n\nFields\n\nname :: String is the name of the diagonal quantum number \nchargef :: Vector{Int64} is the symmetry charge q_fo of each site\nchargeb :: Vector{Int64} is the symmetry charge q_bo of each site\nmodul :: Vector{Int64} is the modulus p, set to 1 for mathrmU(1) SQNDiags. \n\nInitialisation\n\nIt can be initialised by the following method\n\nSQNDiag([name :: String, ]chargef :: Vector{Int64}, chargeb :: Vector{Int64}[, modul :: Int64]) :: SQNDiag\n\nThe arguments name and modul are facultative. By default name is set to \"QN\" and modul is set to 1. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNOffd","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNOffd","text":"SQNOffd\n\nThe mutable type SQNOffd records the information of an off-diagonal â„¤_p quantum number in the form of a discrete transformation\n\nð’µ f_o Î±_fo^* f^(p_fo)_Ï€_foâ€ƒ f_o^Î±_fo c^(1-p_fo)_Ï€_foâ€ƒ b_o^Î±_bo b^_Ï€_bo\n\nwhere we use a notation c^(1)=c^ and c^0=c for convenience, Ï€_foÏ€_bo are permutations of 1N_of or N_ob, Î±_foÎ±_bo are coefficients, and p_fo specified whether or not particle-hole transformation is performed for the fermionic site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal QNs. \n\nArguments\n\npermf :: Vector{Int64} is a length-N_of vector that records the fermion permutation Ï€_fo.\npermb :: Vector{Int64} is a length-N_ob vector that records the boson permutation Ï€_bo.\nphf :: Vector{Int64} is a length-N_of vector that records p_fo to determine whether or not to perform a particle-hole transformation\nfacf :: Vector{ComplexF64} is a length-N_of vector that records the factor Î±_fo in the transformation.\nfacb :: Vector{ComplexF64} is a length-N_ob vector that records the factor Î±_bo in the transformation.\ncyc :: Int64 is the cycle p. \n\nInitialisation\n\nIt can be initialised by the following method\n\nSQNOffd(permf :: Vector{Int64}, permb :: Vector{Int64}[, phf :: Vector{Int64}][, facf :: Vector{ComplexF64}, facb :: Vector{ComplexF64}][, cyc :: Int64]) :: SQNOffd\nSQNOffd(permf :: Vector{Int64}, permb :: Vector{Int64}, phf_q :: Bool[, fac :: Vector{ComplexF64}, facb :: Vector{ComplexF64}]) :: SQNOffd\n\nThe arguments phf, facf, facb and cyc are facultative. By default ph is set all 0, facf, facb is set to all 1 and cyc is set to 2. If phf_q is a bool and true, then ph is set to all 1. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The SQNs can be converted from the fermionic QNs by setting the bosonic part to identity. ","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNDiag-Tuple{QNDiag, Int64}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNDiag","text":"SQNDiag(qnd :: QNDiag, nob :: Int64) :: SQNDiag\n\nconverts a pure fermionic QNDiag to a SQNDiag with the boson charges set to empty, implemented as \n\nSQNDiag(qnd.name, qnd.charge, fill(0, nob), qnd.modul)\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SQNOffd-Tuple{QNOffd, Int64}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SQNOffd","text":"SQNOffd(qnf :: QNOffd, nob :: Int64) :: SQNOffd\n\nconverts a pure fermionic QNOffd to a SQNOffd with the boson transformations set to identity, implemented as \n\nSQNOffd(qnf.perm, collect(1 : nob), qnf.ph, qnf.fac, fill(ComplexF64(1), nob), qnf.cyc)\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"Several operations of the SQNs are supported.","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{Int64, SQNDiag}","page":"Fuzzifino","title":"Base.:*","text":"*(fac :: Int64, qnd :: SQNDiag) :: SQNDiag \n*(qnd :: SQNDiag, fac :: Int64) :: SQNDiag \nÃ·(qnd :: SQNDiag, fac :: Int64) :: SQNDiag \n-(qnd :: SQNDiag) :: SQNDiag\n\nreturns the SQNDiag multiplied or divided by an integer factor, where the charge is multiplied or integer-divided by the factor. For â„¤_p quantum numbers, their modulus will be multiplied or integer-divided by the absolute value. If qnd.modul Ã· abs(fac) â‰¤ 1, a trivial SQNDiag will be returned.  \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:+-Tuple{SQNDiag, SQNDiag}","page":"Fuzzifino","title":"Base.:+","text":"+(qnd1 :: SQNDiag, qnd2 :: SQNDiag) :: SQNDiag \n-(qnd1 :: SQNDiag, qnd2 :: SQNDiag) :: SQNDiag\n\nreturns the sum or substraction of two SQNDiags, whose name is the samea as qnd1, charge is the same as qnd1 Â± qnd2, and modulus is the GCD of qnd1 and qnd2. If qnd1 and qnd2 are both â„¤_p quantum numbers and their modulus are coprime, a trivial SQNDiag will be returned. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{SQNOffd, SQNOffd}","page":"Fuzzifino","title":"Base.:*","text":"*(qnf1 :: SQNOffd, qnf2 :: SQNOffd) :: SQNOffd\n\nreturns the composition of two SQNOffd transformations. The cycle is set to be the LCM of two QNOffds.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.PadSQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.PadSQNDiag","text":"PadSQNDiag(qnd :: SQNDiag, nofl :: Int64, nobl :: Int64, nofr :: Int64, nobr :: Int64)\n\nadds nol empty orbitals to the left and nor empty orbitals to the right, implemented as \n\nSQNDiag(qnd.name, \n    [ fill(0, nofl) ; qnd.chargef ; fill(0, nofr) ], \n    [ fill(0, nobl) ; qnd.chargeb ; fill(0, nobr) ], \n    qnd.modul)\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.PadSQNOffd","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.PadSQNOffd","text":"PadSQNOffd(qnf :: SQNOffd, nofl :: Int64, nobl :: Int64, nofr :: Int64, nobr :: Int64)\n\nadds nofl fermionic and nobl bosonic empty orbitals to the left and nofr fermionic and nobr bosonic empty orbitals to the right, implemented as \n\nSQNOffd(\n    [ collect(1 : nofl) ; qnf.permf .+ nofl ; collect(1 : nofr) .+ (nofl + length(qnf.permf)) ], \n    [ collect(1 : nobl) ; qnf.permb .+ nobl ; collect(1 : nobr) .+ (nobl + length(qnf.permb)) ], \n    [ fill(0, nofl) ; qnf.phf ; fill(0, nofr) ], \n    [ fill(ComplexF64(1), nofl) ; qnf.facf ; fill(ComplexF64(1), nofr) ], \n    [ fill(ComplexF64(1), nobl) ; qnf.facb ; fill(ComplexF64(1), nobr) ], \n    qnf.cyc)\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#Configurations","page":"Fuzzifino","title":"Configurations","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SConfs","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SConfs","text":"SConfs\n\nThe mutable type SConfs stores all the configurations that respects the diagonal quantum numbers (SQNDiag) and also a table to inversely look up the index from the configuration. \n\nFields\n\nnof :: Int64 is the number of fermionic sites.\nnof :: Int64 is the number of bosonic sites.\nnebm :: Int64 is the maximal number of boson occupation.\nncf :: Int64 is the number of configurations.\nconff :: Vector{Int64} is an array of length ncf containing all the fermion configurations. Each configuration is expressed in a binary number. If the o-1-th bit of conf[i] is 1, then the o-th site in the i-th configuration is occupied ; if the bit is 0, then the site is empty. \nconfb :: Vector{Int64} is an array of length ncf containing all the boson configurations. Each configuration is expressed in a binary number that has N_bo 1's and N_eb 0's and the number of 0's following each 1 records the number of bosons in that site. \nnorf :: Int64, nobf :: Int64, lid :: Vector{Int64} and rid :: Vector{Int64} contain the information of Lin table that is used to inversely look up the index i from the configuration. \n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated from the QNDiags.","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SConfs-Tuple{Int64, Int64, Int64, Vector{Int64}, Vector{SQNDiag}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SConfs","text":"SConfs(nof :: Int64, nob :: Int64, nebm :: Int64, secd :: Vector{Int64}, qnd :: Vector{SQNDiag} ; , num_th :: Int64, disp_std :: Bool) :: Confs\n\ngenerates the configurations from the list of QNDiags. \n\nArguments\n\nnof :: Int64 is the number of fermionic sites N_of.\nnob :: Int64 is the number of bosonic sites N_ob.\nnebm :: Int64 is the maximal number of total bosons.\nsecd :: Vector{Int64} is the set of Q_i for the selected configurations in the sector.\nqnd :: Vector{SQNDiag} is the set of SQNDiags.\nnorf :: Int64 and norb :: Int64 are the number of less significant bits used to generate the Lin table. Facultative, N_of2 and N_ob2 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\ncfs :: SConfs is a SConfs object.\n\nNote\n\nIf your qnd has negative entries, QNDiags must contain the total number of particles (i. e., bosons plus fermions).\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Basis","page":"Fuzzifino","title":"Basis","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis\n\nThe mutable type SBasis stores the information of the SBasis that respects both diagonal and off-diagonal quantum numbers. The states in the SBasis is in the form \n\nI=Î»_i_I1i_I1+Î»_i_I2i_I2++Î»_i_Im_Ii_Im_I\n\nwhere i is a direct product state, i. e., the configurations i_Ik are grouped into a state I. \n\nFields\n\ncfs :: SConfs stores the configurations that respect the QNDiags.\ndim :: Int64 is the dimension of the SBasis.\nszz :: Int64 records the maximum size max m_g of groups.\ncfgr :: Vector{Int64} is a vector of length cfs.ncf and records which group I each configuration i belong to.\ncffac :: Vector{ComplexF64} is a vector of length cfs.ncf and records the coefficients Î»_i of each configuration.\ngrel :: Matrix{Int64} is a szzÃ—dim matrix that records the configurations in each group i_Ik (k = 1m_I)\ngrsz :: Vector{Int64} is a vector of length dim that records the size m_I of each group.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated by the following methods.","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis-Tuple{SConfs, Vector{<:Number}, Vector{SQNOffd}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis(cfs :: SConfs, secf :: Vector{ComplexF64}, qnf :: Vector{SQNOffd} ; num_th :: Int64, disp_std :: Bool)\n\ngenerates the SBasis that respects the off-diagonal â„¤_p quantum numbers (secfQNOffd)\n\nArguments\n\ncfs :: SConfs is the diagonal QNâ€“preserving configurations.\nsecf :: Vector{ComplexF64} is a vector of length the same as the number of discrete symmetries that records the eigenvalue of each transformation in the sector.\nqnf :: Vector{SQNOffd} is a vector of off-diagonal quantum numbers.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\nOutput\n\nbs :: SBasis is the resulting SBasis object.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SBasis-Tuple{SConfs}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SBasis","text":"SBasis(cfs :: SConfs)\n\nGenerate a SBasis from the configurations without off-diagonal â„¤_n symmetries.\n\nArguments\n\ncfs :: SConfs is the diagonal QNâ€“preserving configurations.\n\nOutput\n\nbs :: SBasis is the resulting SBasis object.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Term","page":"Fuzzifino","title":"Term","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STerm","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STerm","text":"STerm\n\nThe mutable type STerm records a STerm that looks like Ua^(p_1)_o_1a^(p_2)_o_2 a^(p_l)_o_l in an operator, where positive o denotes fermions and negative o denotes bosons\n\n    a^(0)_o=f_oâ€ƒa^(1)_o=f_o^â€ƒa^(0)_-o=b_oâ€ƒa^(1)_-o=b_o^\n\nFields\n\ncoeff :: ComplexF64 records the coefficient U\ncstr :: Vector{Int64} is a length-2l vector (p_1o_1p_2o_2 p_lo_l) recording the operator string\n\nMethod\n\nIt can be generated by the function or directly from a term\n\nSTerm(coeff :: ComplexF64, cstr :: Vector{Int64})\nSTerm(tm :: Term)\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STerms","text":"STerms is an alias for Vector{STerm} for convenience\n\nInitialisation\n\nSTerms(coeff :: Number, cstr :: Vector{Int64})\n\nGives a STerms with a single STerm.\n\nSTerms(tms :: Terms)\n\nGenerates STerms from Terms\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The product of terms with a number, the sum and product of terms, adjoint and particle-hole transformation are defined","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{Number, Vector{STerm}}","page":"Fuzzifino","title":"Base.:*","text":"*(fac :: Number, tms :: STerms) :: STerms\n-(tms :: STerms) :: STerms\n*(tms :: STerms, fac :: Number) :: STerms\n/(tms :: STerms, fac :: Number) :: STerms\n\nReturn the product of a collection of STerms with a number. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:+-Tuple{Vector{STerm}, Vector{STerm}}","page":"Fuzzifino","title":"Base.:+","text":"+(tms1 :: STerms, tms2 :: STerms) :: STerms\n-(tms1 :: STerms, tms2 :: STerms) :: STerms\n\nReturn the naive sum of two series of STerms by taking their union. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{Vector{STerm}, Vector{STerm}}","page":"Fuzzifino","title":"Base.:*","text":"*(tms1 :: STerms, tms2 :: STerms) :: STerms\n^(tms :: STerms, pow :: Int64) :: STerms\n\nReturn the naive product of two series of STerms or the power of one STerms. The number of STerms equals the product of the number of STerms in tms1 and tms2. For each STerm in tms1 Ua^(p_1)_o_1 and tms2 Ua^(p_1)_o_1, a new STerm is formed by taking UUa^(p_1)_o_1 a^(p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.adjoint-Tuple{Vector{STerm}}","page":"Fuzzifino","title":"Base.adjoint","text":"adjoint(tm :: STerm) :: STerm\nadjoint(tms :: STerms) :: STerms\n\nReturn the Hermitian conjugate of a series of STerms. For each STerm Ua^(p_1)_o_1a^(p_2)_o_2 a^(p_l)_o_l, the adjoint is barUa^(1-p_l)_o_l a^(1-p_2)_o_2a^(1-p_1)_o_1\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The terms can be simplified and manipulated by ","category":"page"},{"location":"fuzzifino/#FuzzifiED.NormalOrder-Tuple{STerm}","page":"Fuzzifino","title":"FuzzifiED.NormalOrder","text":"NormalOrder(tm :: STerm) :: STerms\n\nrearrange a STerm such that \n\nthe creation operators must be commuted in front of the annihilation operator \nthe site index of the creation operators are in ascending order and the annihilation operators in descending order. \n\nreturn a list of STerms whose result is equal to the original STerm. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.SimplifyTerms-Tuple{Vector{STerm}}","page":"Fuzzifino","title":"FuzzifiED.SimplifyTerms","text":"SimplifyTerms(tms :: STerms ; cutoff :: Float64 = eps(Float64)) :: STerms\n\nsimplifies the sum of STerms such that \n\neach STerm is normal ordered,\nlike STerms are combined, and STerms with zero coefficients are removed.\n\nArgument\n\ncutoff :: Float64 is the cutoff such that STerms with smaller absolute value of coefficients will be neglected. Facultative, eps(Float64) by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.RemoveOrbs-Tuple{Vector{STerm}, Vector{Int64}}","page":"Fuzzifino","title":"FuzzifiED.RemoveOrbs","text":"RemoveOrbs(tms :: STerms, o_rm :: Vector{Int64}) :: STerms\n\nremove all the terms that has creation or annihilation operators of sites in the set o_rm.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.RelabelOrbs-Tuple{Vector{STerm}, Dict{Int64, Int64}}","page":"Fuzzifino","title":"FuzzifiED.RelabelOrbs","text":"RelabelOrbs(tms :: STerms, dict_o :: Dict{Int64, Int64})\n\nRelabel all the orbitals. Terms that has operators on the sites that are not in the keys of dict_o are removed. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.PadSTerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.PadSTerms","text":"PadSTerms(tms :: STerms, nol :: Int64)\n\nadds nofl fermionic and nobl bosonic empty orbitals to the left by shifting each orbital index.\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#Operator","page":"Fuzzifino","title":"Operator","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SOperator","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SOperator","text":"SOperator\n\nThe mutable type SOperator records the sum of terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0.\nntm :: Int64 is the number of terms.\nnc :: Int64 is the maximum number of operators in an operator string\ncstrs :: Matrix{Int64} is a matrix recording the operator string of each term. Each column corresponds to a term and is padded to the maximum length with -1's.\ncoeffs :: Vector{ComplexF64} corresponds to the coefficients in each term.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"It can be generated by the following methods.","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SOperator-Tuple{SBasis, SBasis, Vector{STerm}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SOperator","text":"SOperator(bsd :: SBasis[, bsf :: SBasis], terms :: STerms ; red_q :: Int64, sym_q :: Int64, num_th :: Int64, disp_std :: Bool) :: SOperator\n\ngenerates an operator object from a series of terms. \n\nArguments\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state. Facultative, the same as bsd by default. \nterms :: STerms records the terms.\nred_q :: Int64 is a flag that records whether or not the conversion to a sparse martrix can be simplified : if bsd and bsf have exactly the same set of quantum numbers, and the operator fully respects the symmetries, and all the elements in bsd.cffac and bsf.cffac has the same absolute value, then red_q = 1 ; otherwise red_q = 0 ; Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nsym_q :: Int64 records the symmetry of the operator : if the matrix is Hermitian, then sym_q = 1 ; if it is symmetric, then sym_q = 2 ; otherwise sym_q = 0. Facultative, if bsf is not given, 1 by default, otherwise 0 by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The product of an operator on a state and the inner product of a final state, an operator and an initial state can be calculated by","category":"page"},{"location":"fuzzifino/#Base.:*-Tuple{SOperator, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(op :: SOperator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: Vector{ComplexF64}\n*(op :: SOperator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Vector{Float64}\n\nMeasure the action of an operator on a state. st_d must be of length op.bsd.dim. Returns a vector of length op.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{Adjoint{ComplexF64, Vector{ComplexF64}}, SOperator, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(st_fp :: LinearAlgebra.Adjoint{ComplexF64, Vector{ComplexF64}}, op :: SOperator, st_d :: Vector{ComplexF64} ; num_th :: Int64, disp_std :: Bool) :: ComplexF64\n*(st_fp :: LinearAlgebra.Adjoint{Float64, Vector{Float64}}, op :: SOperator, st_d :: Vector{Float64} ; num_th :: Int64, disp_std :: Bool) :: Float64\n\nMeasuring the inner product between two states and an operator. st_d must be of length op.bsd.dim and st_fp must be of length op.bsf.dim, and st_fp must be an adjoint. \n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Sparse-Matrix","page":"Fuzzifino","title":"Sparse Matrix","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The OpMat can be generated from SOperator by the following methods.","category":"page"},{"location":"fuzzifino/#FuzzifiED.OpMat-Tuple{SOperator}","page":"Fuzzifino","title":"FuzzifiED.OpMat","text":"OpMat[{type}](op :: SOperator ; num_th :: Int64, disp_std :: Bool) :: OpMat{type}\n\nGenerates the sparse matrix from the operator. The parameter type is either Float64 or ComplexF64 ; it is facultative, given by ElementType by default. \n\nArguments\n\nop :: SOperator is the operator.\ntype :: DataType specifies the type of the matrix. It can either be ComplexF64 or Float64. Facultative, the same as ElementType by default\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"After the generation of sparse matrix, the diagonalisation can be condicted with FuzzifiED. ","category":"page"},{"location":"fuzzifino/#Entanglement","page":"Fuzzifino","title":"Entanglement","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.StateDecompMat-Tuple{Vector{<:Number}, SBasis, SBasis, SBasis, Vector{<:Number}, Vector{<:Number}, Vector{<:Number}, Vector{<:Number}}","page":"Fuzzifino","title":"FuzzifiED.StateDecompMat","text":"StateDecompMat(st :: Vector{<:Number}, bs0 :: SBasis, bsa :: SBasis, bsb :: SBasis, amp_ofa :: Vector{<:Number}, amp_oba :: Vector{<:Number}, amp_ofb :: Vector{<:Number}, amp_obb :: Vector{<:Number}) :: Matrix{ComplexF64}\n\nDecompose a state Ïˆ=v_II into a direct-product basis of two subsystems Ïˆ=M_JII_AJ_B\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: SBasis is the total basis. \nbsa :: SBasis is the basis for the subsystem A.\nbsb :: SBasis is the basis for the subsystem B. \namp_ofa :: Vector{ComplexF64} is a complex list of length no that specifies the fermionic amplitute of each orbital in the subsystem A. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to â„±_mA in PRB 85, 125308 (2012) with an extra phase factor. \namp_oba :: Vector{ComplexF64} is a complex list of length no that specifies the bosonic amplitute of each orbital in the subsystem A. \namp_ofb :: Vector{ComplexF64} is a complex list of length no that specifies the fermionic amplitute of each orbital in the subsystem B. \namp_obb :: Vector{ComplexF64} is a complex list of length no that specifies the bosonic amplitute of each orbital in the subsystem B. \n\nOutput\n\nA complex matrix of dimension bsb.dim * bsa.dim that corresponds to the state in the decomposed basis Ïˆ=M_JII_AJ_B. This is equivalent to R_Î¼Î½^Ap in PRB 85, 125308 (2012). After calculating all the sectors, the reduced density matrix will be Ï_B=ðŒðŒ^.\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.GetEntSpec-Tuple{Vector{<:Number}, SBasis, Vector{Vector{Vector{Int64}}}, Union{Vector{Vector{Vector{ComplexF64}}}, Vector{Vector{Vector{Float64}}}, Vector{Vector{Vector{Int64}}}}}","page":"Fuzzifino","title":"FuzzifiED.GetEntSpec","text":"GetEntSpec(st :: Vector{<:Number}, bs0 :: SBasis, secd_lst :: Vector{Vector{Vector{Int64}}}, secf_lst :: Vector{Vector{Vector{<:Number}}} ; qnd_a :: Vector{SQNDiag}, qnd_b :: Vector{SQNDiag} = qnd_a, qnf_a :: Vector{SQNOffd}, qnf_b :: Vector{SQNOffd} = qnf_a, amp_oa :: Vector{<:Number}, amp_ob :: Vector{<:Number} = sqrt.(1 .- abs.(amp_oa .^ 2))) :: Dict{@NamedTuple{secd_a, secf_a, secd_b, secf_b}, Vector{Float64}}\n\nArguments\n\nst :: Vector{<:Number} is the state to be decomposed into direct-product basis of two subsystems.\nbs0 :: SBasis is the total basis. \nsecd_lst :: Vector{Vector{Vector{Int64}}} gives the list of QNDiag sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nsecf_lst :: Vector{Vector{Vector{ComplexF64}}} gives the list of QNOffd sectors of subsystems to be calculated. Each of its elements is a two element vector ; the first specifies the sector for subsystem A, and the second specifies the sector for subsystem B. \nqnd_a :: Vector{SQNDiag}, qnd_b :: Vector{SQNDiag} = qnd_a, qnf_a :: Vector{QNOffd}, qnf_b :: Vector{QNOffd} specifies the diagonal and off-diagonal quantum numbers of the subsystems A and B. qnd_b and qnf_b are facultative and the same as qnd_a and qnf_a by default. \namp_oa :: Vector{ComplexF64} and amp_ob :: Vector{ComplexF64} are complex lists of length no that specify the amplitute of each orbital in the subsystems A and B. For a non-local basis, we decompose each electron into creation operators in two subsystems c^_o=a_oAc^_oA+a_oBc^_oB and this list specifies a_oA. This is equivalent to â„±_mA in PRB 85, 125308 (2012) with an extra phase factor. \n\nOutput\n\nA dictionary whose keys are named tuples that specify the sector containing entries secd_a, secf_a, secd_b, secf_b and values are lists of eigenvalues of the density matrix in those sectors. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Transformation","page":"Fuzzifino","title":"Transformation","text":"","category":"section"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STransf","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STransf","text":"STransf\n\nThe mutable type STransf records a transformation in the same form as a SQNOffd\n\nð’µ c_o Î±_o^* c^(p_o)_Ï€_oâ€ƒ c_o^ Î±_o c^(1-p_o)_Ï€_o\n\ntogether with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.\n\nFields\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state.\npermf :: Vector{Int64}, permb :: Vector{Int64},phf :: Vector{Int64}andfacf :: Vector{ComplexF64},facb :: Vector{ComplexF64}` records the transformation in the same form as a SQNOffd.\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.STransf-Tuple{SBasis, SBasis, SQNOffd}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.STransf","text":"STransf(bsd :: SBasis, bsf :: SBasis, qnf :: SQNOffd)\n\ngenerates a transformation object from a SQNOffd. \n\nArguments\n\nbsd :: SBasis is the basis of the initial state.\nbsf :: SBasis is the basis of the final state. Facultative, the same as bsd by default. \nqnf :: SQNOffd records the transformation ; \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Base.:*-Tuple{STransf, Vector{ComplexF64}}","page":"Fuzzifino","title":"Base.:*","text":"*(trs :: STransf, st_d :: Vector{ComplexF64} ; num_th = NumThreads) :: Vector{ComplexF64}\n*(trs :: STransf, st_d :: Vector{Float64} ; num_th = NumThreads) :: Vector{Float64}\n\nAct a transformation on a state. st_d must be of length trs.bsd.dim. Returns a vector of length trs.bsf.dim that represents the final state.\n\nFacultative arguments\n\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default. \n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#Models","page":"Fuzzifino","title":"Models","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"Several quantum numbers and operator terms for the pure bosonic models are built-in.","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetNeSQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetNeSQNDiag","text":"GetNeSQNDiag(nof :: Int64, nob :: Int64) :: SQNDiag\n\nReturn the SQNDiag of the number of particles, implemented as \n\nSQNDiag(\"Ne\", fill(1, nof), fill(1, nob))\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonLz2SQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonLz2SQNDiag","text":"GetBosonLz2SQNDiag(nof :: Int64, nm :: Int64, nf :: Int64) :: SQNDiag\n\nReturn the SQNDiag of twice the angular momentum 2L_z for pure bosons, implemented as \n\nSQNDiag(\"Lz\", fill(0, nof), collect(0 : nm * nf - 1) .Ã· nf .* 2 .- (nm - 1))\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonFlavSQNDiag","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonFlavSQNDiag","text":"GetBosonFlavSQNDiag(nof :: Int64, nm :: Int64, nf :: Int64, qf :: Dict{Int64, Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag \nGetBosonFlavSQNDiag(nof :: Int64, nm :: Int64, nf :: Int64, qf :: Vector{Int64}[, id :: Int64 = 1, modul :: Int64 = 1]) :: QNDiag\n\nReturn the QNDiag of linear combination of number of particles in each flavour for pure bosons, \n\n    Q = _fq_fn_f\n\nthe factor q_f can either be given by a length-N_f vector or a dictionary containing non-zero terms. E.g., for Q=n_f=1-n_f=3 in a 4-flavour system, qf = [1, 0, -1, 0] or qf = Dict(1 => 1, 3 => -3). id is an index to be put in the name to distinguish. For qf given as vector, the function is implemented as \n\nSQNDiag(\"Sz$id\", fill(0, nof), qf[collect(0 : nm * nf - 1) .% nf .+ 1], modul)\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonFlavPermSQNOffd","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonFlavPermSQNOffd","text":"GetBosonFlavPermSQNOffd(nof :: Int64, nm :: Int64, nf :: Int64, permf[, fac][, cyc :: Int64])\n\nReturn the flavour permutaiton transformation for pure bosons\n\n    ð’µ b^_mfÎ±_fb^_mÏ€_f\n\nArguments\n\nnm :: Int64 and nf :: Int64 are the number of orbitals and the flavours.\npermf :: Dict{Int64, Int64}, permf :: Vector{Vector{Int64}} or Vector{Int64} gives the flavour permutation Ï€_f. It is either a vector of the cycles, a vector of the target flavours, or a dictionary of the changed elements. E.g., a permutation 142533415662 can be expressed as [4,5,3,1,6,2], [[1,4],[2,5,6]] or Dict(1=>4,2=>5,4=>1,5=>6,6=>2). Facultative, identity by default. \nfac :: Dict{Int64, <: Number} or Vector{<: Number} gives the factor Î±_f. It is either a vector of all vectors, or a dictionary of all non-unity elements. Facultative, all unity by default. \ncyc :: Int64 is the period of the permutation. \n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonRotySQNOffd","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonRotySQNOffd","text":"GetBosonRotySQNOffd(nof :: Int64, nm :: Int64, nf :: Int64)\n\nReturn the Ï€-rotation with respect to the y-axis for pure bosons. \n\n    â„›_y b^_mf(-)^m+sb^_-mf\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonDenIntSTerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonDenIntSTerms","text":"GetBosonDenIntSTerms(nm :: Int64, nf :: Int64[, ps_pot :: Vector{<:Number}][, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]]) :: Terms\n\nReturn the normal-ordered density-density term in the Hamiltonian for bosons\n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_4M^B_f_2f_3b^_m_1f_1b^_m_2f_2b_m_3f_3b_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default. \nmat_a :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \n\n\n\n\n\nGetBosonDenIntSTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Vector{<:AbstractMatrix{<:Number}}[, mat_b :: Vector{<:AbstractMatrix{<:Number}}]) :: Terms\n\nReturn the sum of a series of normal-ordered density-density term in the Hamiltonian for bosons\n\n_m_if_iÎ±U_m_1m_2m_3m_4(M^A_Î±)_f_1f_4(M^B_Î±)_f_2f_3b^_m_1f_1b^_m_2f_2b_m_3f_3b_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. Facultative, [1.0] by default.\nmat_a :: Vector{<:AbstractMatrix{<:Number}} is a vector of nfÃ—nf matrix specifying (M^A_Î±)_ff. Facultative, I_N_f by default. \nmat_b :: Vector{<:AbstractMatrix{<:Number}} is a vector of nfÃ—nf matrix specifying (M^B_Î±)_ff. Facultative, the Hermitian conjugate of mat_a by default. \n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonPairIntSTerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonPairIntSTerms","text":"GetBosonPairIntSTerms(nm :: Int64, nf :: Int64, ps_pot :: Vector{<:Number}, mat_a :: Matrix{<:Number}[, mat_b :: Matrix{<:Number}]) :: Terms\n\nReturn the normal-ordered pair-pair interaction term in the Hamiltonian for bosons\n\n_m_if_iU_m_1m_2m_3m_4M^A_f_1f_2M^B_f_3f_4b^_m_1f_1b^_m_2f_2b_m_3f_3b_m_4f_4\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nps_pot :: Vector{<:Number} is a list of numbers specifying the pseudopotentials for the interacting matrix U_m_1m_2m_3m_4. \nmat_a :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^A_ff. Facultative, I_N_f by default. \nmat_b :: Matrix{<:Number} is a nfÃ—nf matrix specifying M^B_ff. Facultative, the Hermitian conjugate of mat_a by default. \n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonPolSTerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonPolSTerms","text":"GetBosonPolSTerms(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; fld_m :: Vector{<:Number}]) :: STerms\n\nReturn the polarisation term in the Hamiltonian for bosons\n\n_mffc^_mfM_ffc_mf\n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours. \nmat :: Matrix{<:Number} is a nfÃ—nf matrix specifying M_ff. Facultative, I_N_f by default. \nfld_m :: Vector{<:Number} gives an orbital dependent polarisation\n\n_mffh_mc^_mfM_ffc_mf\n\nFacultative. \n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonLpLzSTerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonLpLzSTerms","text":"GetBosonLpLzSTerms(nm :: Int64, nf :: Int64) :: Tuple{Terms, Terms}\n\nReturn the a pair of terms containing L^z and L^+ for bosons. \n\nArguments\n\nnm :: Int64 is the number of bosonic orbitals.\nnf :: Int64 is the number of bosonic flavours.\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetL2STerms-Tuple{Tuple{Vector{STerm}, Vector{STerm}}}","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetL2STerms","text":"GetL2Terms(tms_lzlp :: Tuple{STerms, STerms}) :: STerms\n\nReturn the terms for the total angular momentum from a tuple of terms containing L^z and L^+, implemented as \n\ntms_lz, tms_lp = tms_lzlp \nreturn SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lp')\n\n\n\n\n\n","category":"method"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.GetBosonC2STerms","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.GetBosonC2STerms","text":"GetBosonC2STerms(nm :: Int64, nf :: Int64, mat_gen :: Vector{Matrix{<:Number}}[, mat_tr :: Vector{Matrix{<:Number}}]) :: STerms\n\nReturn the terms for the quadratic Casimir of the flavour symmetry for bosons.\n\n    C_2=_immfrac(b^_mf_1G_if_1f_2b_mf_2)(b^_mf_3G^_if_3f_4b_mf_4)2operatornametrG_i^G_i-_immfrac(b^_mf_1T_if_1f_2b_mf_2)(b^_mf_3T^_if_3f_4b_mf_4)2operatornametrT_i^T_i\n\nwhere G_i are the generator matrices, and T_i are the trace matrices. \n\nArguments\n\nnm :: Int64 is the number of orbitals.\nnf :: Int64 is the number of flavours.\nmat_gen :: Vector{Matrix{Number}} is a list of the matrices that gives the generators. It will automatically be normalised such that its square traces to 12. \nmat_tr :: Vector{Matrix{Number}} is a list of trace matrices that will be normalised automatically and substracted. Facultative.\n\n\n\n\n\n","category":"function"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"The types SSphereObs and SAngModes are similarly defined as their fermionic counterparts","category":"page"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SSphereObs","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SSphereObs","text":"SSphereObs\n\nThe mutable type SSphereObs stores the information of a local observable (or local operator) ð’ª that can be decomposed into angular components.\n\n    ð’ª(Omega)=_lmð’ª_lmY^(s)_lm\n\nFields\n\ns2 :: Int64 is twice the spin 2s of the observable.\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the observable. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: STerms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the observable is stored.\ncomps :: Dict{Tuple{Int64, Int64}, STerms} stores each component of the observable in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\nMethods\n\nThe methods for this type is similarly defined as in SphereObs.\n\nSSphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function) :: SSphereObs\nSSphereObs(s2 :: Int64, l2m :: Int64, comps :: Dict{Tuple{Int64, Int64}, STerms}) :: SSphereObs\nStoreComps(obs :: SSphereObs) :: SSphereObs\n*(fac :: Number, obs :: SSphereObs) :: SSphereObs\n+(obs1 :: SSphereObs, obs2 :: SSphereObs) :: SSphereObs\nadjoint(obs :: SSphereObs) :: SSphereObs\n*(obs1 :: SSphereObs, obs2 :: SSphereObs) :: SSphereObs\nPadSSphereObs(obs :: SSphereObs, nofl :: Int64, nobl :: Int64) :: SSphereObs\nLaplacian(obs :: SSphereObs[ ; norm_r2 :: Float64]) :: SSphereObs\nGetIntegral(obs :: SSphereObs[ ; norm_r2 :: Float64]) :: STerms\nGetComponent(obs :: SSphereObs, l :: Number, m :: Number) :: STerms\nFilterComponent(obs :: SSphereObs, flt) :: AngModes \nGetPointValue(obs :: SSphereObs, Î¸ :: Float64, Ï• :: Float64) :: STerms\nGetFermionSObs(nm :: Int64, nf :: Int64, f :: Int64[ ; norm_r2 :: Float64]) :: SSphereObs\nGetBosonSObs(nm :: Int64, nf :: Int64, f :: Int64[ ; norm_r2 :: Float64]) :: SSphereObs\nGetFerDensitySObs(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; norm_r2 :: Float64]) :: SSphereObs\nGetBosDensitySObs(nm :: Int64, nf :: Int64[, mat :: Matrix{<:Number}][ ; norm_r2 :: Float64]) :: SSphereObs\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#FuzzifiED.Fuzzifino.SAngModes","page":"Fuzzifino","title":"FuzzifiED.Fuzzifino.SAngModes","text":"SAngModes\n\nThe mutable type SAngModes stores angular momentum components of an operator on the sphere Î¦_lm and superposes in the rule of Clebsch-Gordan coefficients. The usage is similar to the spherical observables, except that SphereObs superposes in the rule of spherical harmonics and has the notion of locality\n\nFields\n\nl2m :: Int64 is twice the maximal angular momentum 2l_max of the components of the modes object. \nget_comp :: Function is a function get_comp(l2 :: Int64, m2 :: Int64) :: STerms that sends the component specified by a tuple of integers (2l2m) where sleq lleq l_max -lleq mleq l to a list of terms that specifies the expression of the component. \nstored_q :: Bool is a boolean that specifies whether or not each component of the modes object is stored.\ncomps :: Dict{Tuple{Int64, Int64}, STerms} stores each component of the modes object in the format of a dictionary whose keys are the tuples of integers (2l2m) and values are the lists of terms that specifies the expression of the component. \n\nMethods\n\nThe methods for this type is similarly defined as in AngModes.\n\nSAngModes(l2m :: Int64, get_comp :: Function) :: SAngModes\nSAngModes(l2m :: Int64, cmps :: Dict{Tuple{Int64, Int64}, STerms}) :: SAngModes\nStoreComps!(amd :: SAngModes)\nStoreComps(amd :: SAngModes) :: SAngModes\n*(fac :: Number, amd :: SAngModes) :: SAngModes\n+(amd1 :: SAngModes, amd2 :: SAngModes) :: SAngModes\nadjoint(amd :: SAngModes) :: SAngModes\n*(amd1 :: SAngModes, amd2 :: SAngModes) :: SAngModes\nPadSAngModes(amd :: SAngModes, nofl :: Int64, nobl :: Int64) :: SAngModes\nGetComponent(amd :: SAngModes, l :: Number, m :: Number) :: STerms\nContractMod(amd1 :: SAngModes, amd2 :: amd2, comps :: Dict) :: STerms\nContractMod(amd1 :: SAngModes, amd2 :: SAngModes, l0 :: Number) :: STerms\nFilterComponent(amd :: SAngModes, flt) :: SAngModes \nFilterL2(amd :: SAngModes, l :: Number) :: SAngModes \nGetFermionSMod(nm :: Int64, nf :: Int64, f :: Int64) :: SAngModes\nGetBosonSMod(nm :: Int64, nf :: Int64, f :: Int64) :: SAngModes\nGetFerPairingSMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SAngModes\nGetBosPairingSMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SAngModes\nGetFerDensitySMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SAngModes\nGetBosDensitySMod(nm :: Int64, nf :: Int64, mat :: Matrix{<:Number}) :: SAngModes\n\n\n\n\n\n","category":"type"},{"location":"fuzzifino/#Related-Examples","page":"Fuzzifino","title":"Related Examples","text":"","category":"section"},{"location":"fuzzifino/","page":"Fuzzifino","title":"Fuzzifino","text":"ising_frac_boson.jl calculates the spectrum of 3d Ising model on the fuzzy sphere for bosons at fractional filling Î½ = 12. This example reproduces Figure 12a,b in Voinea 2024.\nsu2_1_scal_spectrum.jl calculates the spectrum of the mathrmSU(2)_1 coupled to a complex scalar Chern-Simons matter CFT on the fuzzy sphere. This example reproduces Figs. 2d and 3 in Zhou 2025Jul.\nfree_majorana_spectrum.jl calculates the spectrum of free Majorana fermion. This example reproduces Figure 5 in Zhou 2025Sep. \nfree_majorana_correlator.jl calculates the 2-pt correlator of free Majorana fermion. This example reproduces Figure 7 in Zhou 2025Sep.\nbpf_220_spectrum.jl calculates the spectrum of the transition between bosonic Pfaffian and Halperin 220 described by gauged Majorana fermion CFT # This example reproduces Figure 4a in Voinea 2025","category":"page"},{"location":"extension/#Other-Extensions","page":"Other Extensions","title":"Other Extensions","text":"","category":"section"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"Apart from ITensor extension, FuzzifiED also provides other extensions, viz. HDF5 extension, KrylovKit extension, CUDA extension and SparseArrays extension. ","category":"page"},{"location":"extension/#HDF5-Extension","page":"Other Extensions","title":"HDF5 Extension","text":"","category":"section"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"The HDF5 extension supports writing the types Confs, Basis, Terms, Operator, OpMat{ComplexF64} and OpMat{Float64} into HDF5 files and reading them from groups and subgroups in HDF5 format. This extension requires the packages HDF5. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"using HDF5","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"A typical file operation process looks like","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"h5open(file_name, \"cw\")\n# include the file name as a string \n# Modes : \"cw\" for write and \"r\" for read\n...\nclose(f)","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"To write, include in the middle ","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"write(f, group_name :: String, cfs :: Confs)\nwrite(f, group_name :: String, bs  :: Basis)\nwrite(f, group_name :: String, tms :: Terms)\nwrite(f, group_name :: String, op  :: Operator)\nwrite(f, group_name :: String, mat :: OpMat{ComplexF64})\nwrite(f, group_name :: String, mat :: OpMat{Float64})","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"To read, include in the middle ","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"cfs = read(f, group_name :: String, Confs)\nbs  = read(f, group_name :: String, Basis)\ntms = read(f, group_name :: String, Terms)\nop  = read(f, group_name :: String, Operator)\nmat = read(f, group_name :: String, OpMat{ComplexF64})\nmat = read(f, group_name :: String, OpMat{Float64})","category":"page"},{"location":"extension/#SparseArrays-Extension","page":"Other Extensions","title":"SparseArrays Extension","text":"","category":"section"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"The SparseArrays extension supports the conversion between OpMat in FuzzifiED and the SparseMatrixCSC and Matrix format. This extension requires the packages SparseArrays. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"using SparseArrays","category":"page"},{"location":"extension/#SparseArrays.SparseMatrixCSC-Tuple{OpMat}","page":"Other Extensions","title":"SparseArrays.SparseMatrixCSC","text":"SparseMatrixCSC(mat :: OpMat{ComplexF64}) :: SparseMatrixCSC{Int64,ComplexF64}\nSparseMatrixCSC(mat :: OpMat{Float64}) :: SparseMatrixCSC{Int64,Float64}\n\nconverts the OpMat objects to a SparseMatrixCSC object in the SparseArrays package.\n\n\n\n\n\n","category":"method"},{"location":"extension/#Base.Matrix-Tuple{OpMat}","page":"Other Extensions","title":"Base.Matrix","text":"Matrix(mat :: OpMat{ComplexF64}) :: Matrix{ComplexF64}\nMatrix(mat :: OpMat{Float64}) :: Matrix{Float64}\n\nconverts the OpMat objects to a full matrix.\n\n\n\n\n\n","category":"method"},{"location":"extension/#FuzzifiED.OpMat-Tuple{SparseMatrixCSC}","page":"Other Extensions","title":"FuzzifiED.OpMat","text":"OpMat(matcsc :: SparseMatrixCSC{Int64,ComplexF64}) :: OpMat{ComplexF64}\nOpMat(matcsc :: SparseMatrixCSC{Int64,Float64}) :: OpMat{Float64}\n\nconverts the SparseMatrixCSC object in the SparseArrays package to an OpMat objects.\n\n\n\n\n\n","category":"method"},{"location":"extension/#KrylovKit-Extension","page":"Other Extensions","title":"KrylovKit Extension","text":"","category":"section"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"The KrylovKit extension supports an interface diagonalising the sparse matrix using the KrylovKit pakage in Julia. This extension requires the packages KrylovKit. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"using KrylovKit","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"Besides Arpack in Fortran, we also provide an interface calling KrylovKit in Julia.","category":"page"},{"location":"extension/#FuzzifiED.GetEigensystemKrylov-Tuple{OpMat{ComplexF64}, Int64}","page":"Other Extensions","title":"FuzzifiED.GetEigensystemKrylov","text":"GetEigensystemKrylov(mat :: OpMat{ComplexF64}, nst :: Int64 ; initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{ComplexF64}, Matrix{ComplexF64}}\nGetEigensystemKrylov(mat :: OpMat{Float64}, nst :: Int64 ; initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{Float64}, Matrix{Float64}}\n\nThis method calls the eigsolve from Julia KrylovKit.jl package instead of Arpack from Fortran to calculate the lowest eigenstates of sparse matrix. The performance should be similar. For an example, refer to ising_spectrum_krylov.jl.\n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix.\nnst :: Int64 is the number of eigenstates to be calculated.\ntol :: Float64 is the tolerence for the KrylovKit process. The default value is 1E-8.\nncv :: Int64 is the maximum dimension of the Krylov subspace. The default value is max(2 * nst, nst + 10). If krylovdim is also given, ncv will not be used.\ninitvec :: Vector{ComplexF64} or initvec :: Vector{Float64} is the initial vector. Facultative, a random initialisation by default.\nnum_th :: Int64, the number of threads. Facultative, NumThreads by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default.\nkwargs... is the options that will directly sent into eigsolve, see its documentation for detail.\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimdÃ—nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"extension/#CUDA-Extension","page":"Other Extensions","title":"CUDA Extension","text":"","category":"section"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"The CUDA extension supports the conversion between OpMat in FuzzifiED and the CuSparseMatrixCSC in CUDA.CUSPARSE as well as the acceleration of diagonalisation on GPU. This extension requires the packages CUDA, KrylovKit and SparseArrays. To use this extension, include at the heading ","category":"page"},{"location":"extension/","page":"Other Extensions","title":"Other Extensions","text":"using CUDA, KrylovKit, SparseArrays","category":"page"},{"location":"extension/#CUDA.CUSPARSE.CuSparseMatrixCSC-Tuple{OpMat{ComplexF64}}","page":"Other Extensions","title":"CUDA.CUSPARSE.CuSparseMatrixCSC","text":"CUSPARSE.CuSparseMatrixCSC(mat :: OpMat{ComplexF64})\nCUSPARSE.CuSparseMatrixCSC(mat :: OpMat{Float64})\n\nconverts the OpMat objects to a CuSparseMatrixCSC object in the CUDA.CUSPARSE package.\n\n\n\n\n\n","category":"method"},{"location":"extension/#FuzzifiED.GetEigensystemCuda-Tuple{OpMat{ComplexF64}, Int64}","page":"Other Extensions","title":"FuzzifiED.GetEigensystemCuda","text":"GetEigensystemCuda(mat :: OpMat{ComplexF64}, nst :: Int64 ; initvec :: Vector{ComplexF64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{ComplexF64}, CuArray{ComplexF64, 2, CUDA.DeviceMemory}}\nGetEigensystemCuda(mat :: OpMat{Float64}, nst :: Int64 ; initvec :: Vector{Float64}, num_th :: Int64, disp_std :: Bool, kwargs...) :: Tuple{Vector{Float64}, CuArray{Float64, 2, CUDA.DeviceMemory}}\n\nThis method uses Julia KrylovKit package to calculate the lowest eigenstates of sparse matrix. The sparse matrix multiplication is realised by CUDA.CUSPARSE. For an example, refer to ising_spectrum_cuda.jl.\n\nArguments\n\nmat :: OpMat{ComplexF64} or mat :: OpMat{Float64} is the matrix.\nnst :: Int64 is the number of eigenstates to be calculated.\ntol :: Float64 is the tolerence for the KrylovKit process. The default value is 1E-8.\nncv :: Int64 is the maximum dimension of the Krylov subspace. The default value is max(2 * nst, nst + 10). If krylovdim is also given, ncv will not be used.\ninitvec is the initial vector. Facultative, a random initialisation CUDA.rand(T, mat.dimd) by default.\ndisp_std :: Bool, whether or not the log shall be displayed. Facultative, !SilentStd by default. \nkwargs... is the options that will directly sent into eigsolve, see its documentation for detail.\n\nOutput\n\nA length-nst array that has the same type as mat recording the eigenvalues, and \nA dimdÃ—nst matrix that has the same type as mat where every column records an eigenstate. \n\n\n\n\n\n","category":"method"},{"location":"releases/#Release-notes","page":"Releases","title":"Release notes","text":"","category":"section"},{"location":"releases/#Version-1.x","page":"Releases","title":"Version 1.x","text":"","category":"section"},{"location":"releases/#Version-1.2","page":"Releases","title":"Version 1.2","text":"","category":"section"},{"location":"releases/#Version-1.2.1-(28th-November-2025)","page":"Releases","title":"Version 1.2.1 (28th November 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add flag to control whether SphereObs and AngModes increase or decrease angular momenta.\nFix bugs.","category":"page"},{"location":"releases/#Version-1.2.0-(4th-November-2025)","page":"Releases","title":"Version 1.2.0 (4th November 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Update the implementation of Sp and SU Casimir.\nAdd total angular momentum for boson-fermion mixture.\nAdd total angular momentum through L^z and L^+. \nAdd functions padding orbitals. \nUpdate the reference and examples.","category":"page"},{"location":"releases/#Version-1.1","page":"Releases","title":"Version 1.1","text":"","category":"section"},{"location":"releases/#Version-1.1.0-(14th-July-2025)","page":"Releases","title":"Version 1.1.0 (14th July 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the removal and relabelling of orbitals for Terms. \nInclude SphereObs and AngModes for Fuzzifino.\nAdd Contract for AngModes. \nFix the normalisation of Casimir normalisation.\nUpdate the reference and examples. ","category":"page"},{"location":"releases/#Version-1.0","page":"Releases","title":"Version 1.0","text":"","category":"section"},{"location":"releases/#Version-1.0.4-(15th-May-2025)","page":"Releases","title":"Version 1.0.4 (15th May 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add example of Yang-Lee CFT.\nUpdate compat for ITensor.","category":"page"},{"location":"releases/#Version-1.0.3-(30th-April-2025)","page":"Releases","title":"Version 1.0.3 (30th April 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Relax constraint on negative QNDiag and particle conservation. \nAdd GetTorusTranslQNOffd for torus. (We acknowledge Shuai Yang for the suggestion.)","category":"page"},{"location":"releases/#Version-1.0.2-(28th-March-2025)","page":"Releases","title":"Version 1.0.2 (28th March 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Enable the normalisation of the observables. \nAdd uniform spatial integral and component filter of the observables. \nAdd conversion from Term to STerm.","category":"page"},{"location":"releases/#Version-1.0.1-(11th-March-2025)","page":"Releases","title":"Version 1.0.1 (11th March 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Implement the pure bosonic models.","category":"page"},{"location":"releases/#Version-1.0.0-(1st-March-2025)","page":"Releases","title":"Version 1.0.0 (1st March 2025)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Release together with the documentation.\nAdd support for torus. \nAdd example for Potts. \nFix bugs.","category":"page"},{"location":"releases/#Version-0.x","page":"Releases","title":"Version 0.x","text":"","category":"section"},{"location":"releases/#Version-0.10","page":"Releases","title":"Version 0.10","text":"","category":"section"},{"location":"releases/#Version-0.10.7-(9th-December-2024)","page":"Releases","title":"Version 0.10.7 (9th December 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add implementation of transformations.","category":"page"},{"location":"releases/#Version-0.10.6-(6th-December-2024)","page":"Releases","title":"Version 0.10.6 (6th December 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add entanglement calculations in Fuzzifino. ","category":"page"},{"location":"releases/#Version-0.10.5-(4th-December-2024)","page":"Releases","title":"Version 0.10.5 (4th December 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Fix the dependency in FuzzifiED_jll\nMove KrylovKit and SparseArrays to extensions. \nFix minor bugs. ","category":"page"},{"location":"releases/#Version-0.10.4-(30th-November-2024)","page":"Releases","title":"Version 0.10.4 (30th November 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Split ITensorsExt and EasySweepExt.\nDefine a new SiteType \"FuzzyFermion\" for ITensors to avoid overwriting \"Fermion\" in ITensorsExt.\nChange the names of Density and Electron to avoid conflict with other packages.\nCreate the alias Terms and STerms.\nFix bugs in converting OpSum to Terms.\nImprove the interface for ITensor extension.","category":"page"},{"location":"releases/#Version-0.10.3-(28th-November-2024)","page":"Releases","title":"Version 0.10.3 (28th November 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add options for DMRG. \nOptimise the implementation of confs in Fuzzifino.\nAdd the examples of fractional filling.","category":"page"},{"location":"releases/#Version-0.10.1-(25th-November-2024)","page":"Releases","title":"Version 0.10.1 (25th November 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add CUDA extension. \nAdd interface with KrylovKit.","category":"page"},{"location":"releases/#Version-0.10.0-(24th-November-2024)","page":"Releases","title":"Version 0.10.0 (24th November 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add module Fuzzifino for boson-fermion systems.","category":"page"},{"location":"releases/#Version-0.9","page":"Releases","title":"Version 0.9","text":"","category":"section"},{"location":"releases/#Version-0.9.3-(23rd-November-2024)","page":"Releases","title":"Version 0.9.3 (23rd November 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Move HDF5 and ITensor to extensions\nModify ITensor extension interfaces in alignment with the update of ITensor.","category":"page"},{"location":"releases/#Version-0.9.2-(16th-September-2024)","page":"Releases","title":"Version 0.9.2 (16th September 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the example of Ising generators and Sp(3) CFT.","category":"page"},{"location":"releases/#Version-0.9.1-(13th-September-2024)","page":"Releases","title":"Version 0.9.1 (13th September 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Allow input of initial vectors for diagonalisation. (We acknowledge Andrew Fitzpatrick for the suggestion.)","category":"page"},{"location":"releases/#Version-0.9.0-(11th-September-2024)","page":"Releases","title":"Version 0.9.0 (11th September 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add feature of angular modes observables.\nFix typos and bugs.","category":"page"},{"location":"releases/#Version-0.8","page":"Releases","title":"Version 0.8","text":"","category":"section"},{"location":"releases/#Version-0.8.2-(28th-July-2024)","page":"Releases","title":"Version 0.8.2 (28th July 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Fix bugs in GetDenIntTerms and multiplication in SphereObs. ","category":"page"},{"location":"releases/#Version-0.8.0-(26th-July-2024)","page":"Releases","title":"Version 0.8.0 (26th July 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Improve the performance of SimplifyTerms. \nAdd file operation. ","category":"page"},{"location":"releases/#Version-0.7","page":"Releases","title":"Version 0.7","text":"","category":"section"},{"location":"releases/#Version-0.7.2-(24th-July-2024)","page":"Releases","title":"Version 0.7.2 (24th July 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add example and support for surface CFTs. \nAdd example of Ising cusp.","category":"page"},{"location":"releases/#Version-0.7.1-(11th-June-2024)","page":"Releases","title":"Version 0.7.1 (11th June 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add some new interfaces for built-in operators. \nAdd new examples. \nFix bugs","category":"page"},{"location":"releases/#Version-0.7.0-(9th-June-2024)","page":"Releases","title":"Version 0.7.0 (9th June 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Revise the implementation of diagonal and off-diagonal quantum number. ","category":"page"},{"location":"releases/#Version-0.6","page":"Releases","title":"Version 0.6","text":"","category":"section"},{"location":"releases/#Version-0.6.3-(8th-June-2024)","page":"Releases","title":"Version 0.6.3 (8th June 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for calculating entanglement spectrum. \nAdd global parameters to control the number of threads, the output and the path of the dynamic library. \nFix bugs. ","category":"page"},{"location":"releases/#Version-0.6.0-(5th-June-2024)","page":"Releases","title":"Version 0.6.0 (5th June 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for full diagonalisation. \nFix bugs and typos.\nReady for formal release !","category":"page"},{"location":"releases/#Version-0.5","page":"Releases","title":"Version 0.5","text":"","category":"section"},{"location":"releases/#Version-0.5.8-(3rd-June-2024)","page":"Releases","title":"Version 0.5.8 (3rd June 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Change the binary dependence to Julia Binary Builder. ","category":"page"},{"location":"releases/#Version-0.5.0-(30th-May-2024)","page":"Releases","title":"Version 0.5.0 (30th May 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Enable simplification of terms.\nAdd general observables and built-in electrons and density operators. \nReorganise the realisations of built-in models.\nCancel ITensorMPOConstruction dependence. ","category":"page"},{"location":"releases/#Version-0.4","page":"Releases","title":"Version 0.4","text":"","category":"section"},{"location":"releases/#Version-0.4.3-(29th-May-2024)","page":"Releases","title":"Version 0.4.3 (29th May 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add QNU truncation for ITensor use.\nChange the Fortran code to be robust against QNU breaking terms\nAdd built-in density-density interaction. \nAdd built-in 3-state Potts model.\nAdd built-in Ising model with magnetic line defect. ","category":"page"},{"location":"releases/#Version-0.4.0-(28th-May-2024)","page":"Releases","title":"Version 0.4.0 (28th May 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add support for DMRG.\nAdd convertion from diagonal QNs to sites. \nAdd the support of mathbbZ_n diagonal quantum numbers in Confs.\nMerge the submodules to the main package. \nAdd Ising model in X basis.  \nAdd functions in built-in models to export diagonal QNs. ","category":"page"},{"location":"releases/#Version-0.3","page":"Releases","title":"Version 0.3","text":"","category":"section"},{"location":"releases/#Version-0.3.0-(27th-May-2024)","page":"Releases","title":"Version 0.3.0 (27th May 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add the support for Hamiltonians with real elements. \nAdd conversion with SparseMatrixCSC. \nAdd the conversion from terms to OpSum.\nAdd the look-up of configurations. \nFor the built-in Ising model, add density operator.\nAdd built-in mathrmSp(N) model. ","category":"page"},{"location":"releases/#Version-0.2","page":"Releases","title":"Version 0.2","text":"","category":"section"},{"location":"releases/#Version-0.2.0-(26th-May-2024)","page":"Releases","title":"Version 0.2.0 (26th May 2024)","text":"","category":"section"},{"location":"releases/","page":"Releases","title":"Releases","text":"Add operations of terms.\nAdd built-in Ising model. ","category":"page"},{"location":"#FuzzifiED.jl","page":"Home","title":"FuzzifiED.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Version) (Image: Documentation online) (Image: Documentation PDF) (Image: Source GitHub) (Image: arXiv) (Image: Contact)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since its proposal, the fuzzy sphere regularisation has made significant contributions to the study of 3d CFTs. The Julia package FuzzifiED aims at simplifying the numerical calculations on the fuzzy sphere. It supports exact diagonalisation (ED) calculations, as well as the density matrix renormalisation group (DMRG) using the ITensor library. FuzzifiED can also apply to generic fermionic and bosonic models. This package offers the following features : ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Flexibility : FuzzifiED can reproduce nearly all the ED and DMRG results from fuzzy sphere research. Its flexible design also makes it straightforward to adapt to new models.\nUsability : The expressive Julia interface simplifies coding and comprehension. To help users get started, we provide a collection of examples.\nEfficiency : FuzzifiED produces results on reasonable system sizes within minutes.\nOpen source : The FuzzifiED codebase is freely available under the MIT License, welcoming reviews and contributions from the wider community.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A PDF version of the documentation is provided at this link. If you have any questions, please contact Zheng Zhou (å‘¨æ­£) at physics@zhengzhou.page.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, run the following command in the Julia REPL (read-eval-print loop) (To enter Julia REPL, simply type julia in the command line) ","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg ; Pkg.add(\"FuzzifiED\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To use the package, include at the start of the Julia script","category":"page"},{"location":"","page":"Home","title":"Home","text":"using FuzzifiED","category":"page"},{"location":"","page":"Home","title":"Home","text":"To obtain the documentation for an interface, type ? followed by the keyword in the Julia REPL, e. g., ?Confs.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If this package is helpful in your research, please cite the package as : ","category":"page"},{"location":"","page":"Home","title":"Home","text":"FuzzifiED : Julia package for numerics on the fuzzy sphere, Zheng Zhou, arXiv:2503.00100.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We have also provided a BibTeX file that includes all the works on the fuzzy sphere works at this link.","category":"page"},{"location":"#Useful-Information","page":"Home","title":"Useful Information","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Jupyter Notebook is highly recommended as it allows you to run Julia (and Python) just like running a Mathematica notebook.\nThe package regisitry may have some delay. If you encounter trouble at installation, to bring the registry up to date, use Pkg.Registry.update(), or install from the GitHub repos.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/FuzzifiED/FuzzifiED_jll.jl\")\nPkg.add(url=\"https://github.com/FuzzifiED/FuzzifiED.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please find following some useful links.\nInstallation for Julia : https://julialang.org/downloads\nHomepage : https://www.fuzzified.world\nJulia source code : https://github.com/FuzzifiED/FuzzifiED.jl\nJLL wrapper : https://github.com/FuzzifiED/FuzzifiED_jll.jl\nFortran source code : https://github.com/FuzzifiED/FuzzifiED_Fortran\nRegistry of the package : https://juliahub.com/ui/Packages/General/FuzzifiED","category":"page"},{"location":"#Outline","page":"Home","title":"Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"intro.md\",\n    \"tutorial.md\",\n    \"core.md\",\n    \"models.md\",\n    \"itensors.md\",\n    \"extension.md\",\n    \"fuzzifino.md\",\n    \"manifolds.md\",\n    \"releases.md\"\n]\nDepth = 2","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[Zhu 2022] Uncovering conformal symmetry in the 3d Ising transition : state-operator correspondence from a quantum fuzzy sphere regularisation, Wei Zhu, Chao Han, Emilie Huffman, Johannes S. Hofmann, and Yin-Chen He, arXiv:2210.13482, Phys. Rev. X 13, 021009 (2023).\n[Hu 2023Mar] Operator product expansion coefficients of the 3d Ising criticality via quantum fuzzy sphere, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2303.08844, Phys. Rev. Lett 131, 031601 (2023).\n[Han 2023Jun] Conformal four-point correlators of the 3d Ising transition via the quantum fuzzy sphere, Chao Han, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.04681, Phys. Rev. B 108, 235123 (2023).\n[Zhou 2023] The mathrmSO(5) deconfined phase transition under the fuzzy sphere microscope: approximate conformal symmetry, pseudo-criticality, and operator spectrum, Zheng Zhou, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2306.16435, Phys. Rev. X 14, 021044 (2024).\n[Hu 2023Aug] Solving conformal defects in 3d conformal field theory using fuzzy sphere regularisation, Liangdong Hu, Yin-Chen He, and Wei Zhu, arXiv:2308.01903, Nat. Commun. 15, 3659 (2024).\n[Hofmann 2024] Quantum Monte Carlo simulation of the 3d Ising transition on the fuzzy sphere, Johannes S. Hofmann, Florian Goth, Wei Zhu, Yin-Chen He, and Emilie Huffman, arXiv:2310.19880, SciPost Phys. Core 7, 028 (2024).\n[Han 2023Dec] Conformal operator content of the Wilson-Fisher transition on fuzzy sphere bilayers, Chao Han, Liangdong Hu, and Wei Zhu, arXiv:2312.04047, Phys. Rev. B 110, 115113 (2024).\n[Zhou 2024Jan] The g-function and defect changing operators from wavefunction overlap on a fuzzy sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, Yijian Zou, arXiv:2401.00039, SciPost Phys. 17, 021 (2024).\n[Hu 2024] Entropic F-function of 3d Ising conformal field theory via the fuzzy sphere regularisation, Liangdong Hu, Wei Zhu, and Yin-Chen He, arXiv:2401.17362, Phys. Rev. B 111, 155151 (2025).\n[Cuomo 2024] Impurities with a cusp : general theory and 3d Ising, Gabriel Cuomo, Yin-Chen He, Zohar Komargodski, arXiv:2406.10186, JHEP 11 (2024) 061. \n[Zhou 2024Jul] Studying the 3d Ising surface CFTs on the fuzzy sphere, Zheng Zhou, and Yijian Zou, arXiv:2407.15914, SciPost Phys. 18, 031 (2025).\n[Dedushenko 2024] Ising BCFTs from the fuzzy hemisphere, Mykola Dedushenko, arXiv:2407.15948.\n[Fardelli 2024] Constructing the infrared conformal generators on the fuzzy sphere, Giulia Fardelli, A. Liam Fitzpatrick, and Emanuel Katz, arXiv:2409.02998, SciPost Phys. 18, 086 (2025).\n[Fan 2024] Note on explicit construction of conformal generators on the fuzzy sphere, Ruihua Fan, arXiv:2409.08257.\n[Zhou 2024Oct] 3D conformal field theories with mathrmSp(N) global symmetry on a fuzzy sphere, Zheng Zhou, and Yin-Chen He, arXiv:2410.00087, Phys. Rev. Lett. 135, 026504 (2025).\n[Voinea 2024] Regularising 3d conformal field theories via anyons on the fuzzy sphere, arXiv:2411.15299, Phys. Rev. X 15, 031007 (2025).\n[Han 2025] Quantum phase transitions on the noncommutative circle, Chao Han, and Wei Zhu, Phys. Rev. B 111, 085113 (2025).\n[Yang 2025Jan] Microscopic study of 3d Potts phase transition via fuzzy sphere regularisation, Shuai Yang, Yan-Guang Yue, Yin Tang, Chao Han, Wei Zhu, and Yan Chen, arXiv:2501.14320, Phys. Rev. B 112, 024436 (2025).\n[LÃ¤uchli 2025] Exact diagonalization, matrix product states and conformal perturbation theory study of a 3d Ising fuzzy sphere model, Andreas M. LÃ¤uchli, LoÃ¯c Herviou, Patrick H. Wilhelm, and Slava Rychkov, SciPost Phys. 19, 076 (2025), arXiv:2504.00842.\n[Fan 2025] Simulating the non-unitary Yang-Lee conformal field theory on the fuzzy sphere, Ruihua Fan, Junkai Dong, and Ashvin Vishwanath arXiv:2505.06342.\n[Arguello Cruz 2025] Yang-Lee quantum criticality in various dimensions, Erick Arguello Cruz, Igor R. Klebanov, Grigory Tarnopolsky, and Yuan Xin, arXiv:2505.06369.\n[Elias Miro 2025] Flowing from the Ising model on the fuzzy sphere to the 3d Lee-Yang CFT, Joan Elias Miro, Olivier Delouche, JHEP 10 (2025) 037, arXiv:2505.07655.\n[He 2025Jun] Free real scalar CFT on fuzzy sphere : Spectrum, algebra and wavefunction ansatz, arXiv:2506.14904.\n[Taylor 2025] Conformal scalar field theory from Ising tricriticality on the fuzzy sphere, Joseph Taylor, Cristian Voinea, Zlatko PapiÄ‡, Ruihua Fan, arXiv:2506.22539.\n[Yang 2025Jul] Conformal operator flows of the deconfined quantum criticality from mathrmSO(5) to mathrmO(4), Shuai Yang, Liang-Dong Hu, Chao Han, Wei Zhu, Yan Chen, arXiv:2507.01322.\n[Zhou 2025Jul] Chern-Simons-matter conformal field theory on fuzzy sphere: Confinement transition of Kalmeyer-Laughlin chiral spin liquid, Zheng Zhou, Chong Wang, Yin-Chen He, arXiv:2507.19580.\n[Dong 2025] Numerical extraction of crosscap coefficients in microscopic models for (2+1)D conformal field theory, Jia-Ming Dong, Yueshui Zhang, Kai-Wen Huang, Hong-Hao Tu, and Ying-Hai Wu, arXiv:2507.20005.\n[Zhou 2025Sep] Free Majorana fermion meets gauged Ising conformal field theory on the fuzzy sphere, Zheng Zhou, Davide Gaiotto, Yin-Chen He, arXiv:2509.08038.\n[Voinea 2025] Critical Majorana fermion at a topological quantum Hall bilayer transition, Cristian Voinea, Wei Zhu, Nicolas Regnault, Zlatko PapiÄ‡, arXiv:2509.08036.\n[Wiese 2025] Locating the Ising CFT via the ground-state energy on the fuzzy sphere, Kay Joerg Wiese, arXiv:2510.09482.\n[Dey 2025] Conformal data for the mathrmO(3) Wilson-Fisher CFT from fuzzy sphere realization of quantum rotor model, Arjun Dey, Loic Herviou, Christopher Mudry, Andreas Martin LÃ¤uchli, arXiv:2510.09755.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"core.md\",\n    \"models.md\",\n    \"itensors.md\",\n    \"extension.md\",\n    \"fuzzifino.md\",\n    \"manifolds.md\"\n]","category":"page"},{"location":"tutorial/#FuzzifiED-Explained-in-a-Tutorial","page":"Tutorial","title":"FuzzifiED Explained in a Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To demonstrate the usage of FuzzifiED interfaces for ED and DMRG, in this section, we use a tutorial that calculates the eigenstates for the Ising model on the fuzzy sphere. Specifically, it","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"calculates the lowest eigenstates in the symmetry sector L^z=0 and (mathscrPmathscrZmathscrR)=(+++),\nmeasures their total angular momenta, and \ncalcultes the OPE coefficient f_sigmasigmaepsilon=langle sigman^z_00epsilonranglelangle sigman^z_000rangle.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Four versions of the tutorial code are provided : ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tutorial_ising.jl â€” the ED code that uses the built-in models.\ntutorial_ising_primitive.jl â€” The ED code that uses only the core functions.\ntutorial_ising_dmrg.jl â€” the DMRG code that converts the format into ITensor.\ntutorial_ising_dmrg_easysweep.jl â€” the DMRG code that uses the Easy-Sweep extension.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The examples can be found in the directory examples. We also append in the end a list of given examples at the end of the page. ","category":"page"},{"location":"tutorial/#ED-with-FuzzifiED","page":"Tutorial","title":"ED with FuzzifiED","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this section, we briefly describe the procedure for exact diagonalisation (ED) calculation and give an instruction for using FuzzifiED for ED. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Practically, the ED calculation can be divided into 4 steps.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Construct a many-body basis that respect a given set of quantum numbers. Specifically, in FuzzifiED we support quantum numbers of commuting mathrmU(1) or discrete mathbbZ_p symmetries.\nConstruct the sparse matrix corresponding to the Hamiltonian in the basis above. \nFind the lowest eigenstates and their corresponding eigenenergies of the sparse matrix.\nMaking measurements on the eigenstates. This including the total angular momentum, density operators, entanglement, etc.","category":"page"},{"location":"tutorial/#Setup","page":"Tutorial","title":"Setup","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Before starting the calculation, we need to input the setup for the system, including the number of flavours N_f, orbitals N_m and sites N_o ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A â€œflavourâ€ is labelled by f. The number of flavours is N_f.\nAn â€œorbitalâ€ is specified by the magnetic quantum number labelled by m. The number of orbitals is N_m=2s+1.\nA â€œsiteâ€ is specific by both the flavour and the orbital index o=(fm). The number of sites is N_o=N_mN_f. In practice, we label the sites with an integer from 1 to N_o. We store the sites in an ascending order of first m and then f : o=(m+s)N_f+f.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model with s=55,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nm = 12\nnf = 2\nno = nm * nf","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"FuzzifiED also provides several environment parameters that defines how FuzzifiED works, viz. FuzzifiED.ElementType, FuzzifiED.NumThreads and FuzzifiED.SilentStd.","category":"page"},{"location":"tutorial/#Constructing-the-Configurations","page":"Tutorial","title":"Constructing the Configurations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first step for the ED calculation is to construct the basis tha respects the symmetries of the Hamiltonian. This is divided into two steps : (1) generate the â€œconfigurationsâ€ that carry the diagonal quantum numbers, and (2) generate the â€œbasisâ€ that also carry the off-diagonal quantum numbers (under discrete transformations). The â€œconfigurationsâ€ are the collection of states that can be written as direct product of occupied 1rangle or empty 0rangle on each site and carries certain diagonal quantum numbers (QNDiag). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The QNDiags supported by FuzzifiED are the charges of mathrmU(1) or mathbbZ_p symmetry in the form of ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n    Q=sum_oq_on_omathrmU(1)textrm symmetry\n    Q=sum_oq_on_omod pmathbbZ_ptextrm symmetry\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where n_o=c^dagger_oc_o is the particle number on each site, and q_o is the charge that each orbital carries. FuzzifiED restricts q_o to be integer-valued. In FuzzifiED, the QNDiags are recorded in the mutable type QNDiag. Several useful QNDiags are built-in. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The collection of configurations is generated from the QNDiags. It is recorded in the mutable type Confs  and can be constructed by the method ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where qnd is the array of QNDiags, and secd is the array of charges Q of each QNDiag. Here each configuration is stored as a binary number with N_o bits. If the o-th site in the configuration is occupied, the (o-1)-th bit of the configuration is 1; if the site is empty, then the bit is 0. Besides the storation of the configuration, we also need a reverse look-up process that returns the index from the binary string. This is realised by a Lin table.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, there are two QNDiags, viz. the particle number and the angular momentum. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\nQ_1=N_e q_1msigma=1\nQ_2=2L_zq_2msigma=2m\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The full code to generating the configurations in the L_z=0 sector is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnd = [ \n    QNDiag(fill(1, no)), \n    QNDiag([ 2 * m - nm - 1 for m = 1 : nm for f = 1 : nf ])\n]\ncfs = Confs(no, [nm, 0], qnd)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in models, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnd = [ \n    GetNeQNDiag(no), \n    GetLz2QNDiag(nm, nf) \n]\ncfs = Confs(no, [nm, 0], qnd)","category":"page"},{"location":"tutorial/#Constructing-the-Basis","page":"Tutorial","title":"Constructing the Basis","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having constructed the configurations, we now construct the basis of the Hilbert space. The `basis' is the collection of states that are linear combinations of the configuration carrying certain diagonal and mathbbZ_p off-diagonal quantum numbers (QNOffd). ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The QNOffds supported by FuzzifiED are the mathbbZ_p symmetry that are in the form of ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    mathscrZ c_oto alpha_o^* c^(p_o)_pi_oquad c_o^daggerto alpha_o c^(1-p_o)_pi_o","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where we use a notation c^(1)=c^dagger and c^(0)=c for convenience, pi_o is a permutation of the sites 1dots N_o, alpha_o is a coefficient, and p_o specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. In FuzzifiED, the QNOffds are recorded in the mutable type QNOffd. Several useful QNOffds are built-in.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After implementing the QNOffds, a state in the new basis should look like ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    Irangle=lambda_i_I1i_I1rangle+lambda_i_I2i_I2rangle+cdots+lambda_i_Im_Ii_Im_Irangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where the irangle's are configurations, and Irangle is a linear combination of them. This process can be regarded as organising the configurations into groups of size m_I. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the basis Irangle is recorded in the mutable type Basis. It can be constructed by the methods ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd})\nBasis(cfs :: Confs)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where secf records the eigenvalue of each transformation, typically in the form e^i2pi qp where p is the cycle and q is the mathbbZ_p charge. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, There are three mathbbZ_2 symmetries, viz. the particle-hole transformation mathscrP, the pi-rotation along the y-axis mathscrR_y, and the flavour (Ising) symmetry mathscrZ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n    mathscrPc^dagger_sigma mtosigma c_-sigmam\n    mathscrZc^dagger_sigma mto c^dagger_-sigmam\n    mathscrR_yc^dagger_sigma mto c^dagger_sigma-m\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The code to generate the basis in the all-positive sector is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnf = [\n    # Parity (Particle-hole)\n    QNOffd([ (m - 1) * nf + [2, 1][f] for m = 1 : nm for f = 1 : nf ], true, \n        ComplexF64[ [-1, 1][f] for m = 1 : nm for f = 1 : nf ]),\n    # Flavour symmetry\n    QNOffd([ (m - 1) * nf + [2, 1][f] for m = 1 : nm for f = 1 : nf ]),\n    # Y-axis pi-rotation\n    QNOffd([ (nm - m) * nf + f for m = 1 : nm for f = 1 : nf], \n        ComplexF64[ iseven(m) ? 1 : -1 for m = 1 : nm for f = 1 : nf ])\n]\nbs = Basis(cfs, [1, 1, 1], qnf) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnf = [ \n    GetParityQNOffd(nm, 2, [2, 1], [-1, 1]), \n    GetFlavPermQNOffd(nm, 2, [2, 1]), \n    GetRotyQNOffd(nm, 2) \n]\nbs = Basis(cfs, [1, 1, 1], qnf)\n# The second argument gives the eigenvalues under the transformations, for Z_2 put 1,-1 ; for Z_n put exp(2im*pi*q/p)","category":"page"},{"location":"tutorial/#Recording-the-Many-Body-Operator-Terms","page":"Tutorial","title":"Recording the Many-Body Operator Terms","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having constructed the basis, we now construct the many-body operators. A general many-body operator can be written as","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    mathscrO=sum_t=1^N_tU_tc^(p_t1)_o_t1c^(p_t2)_o_t2dots c^(p_tl_t)_o_tl_t","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where c^(0)=c and c^(1)=c^dagger. In FuzzifiED, this is recorded as an array of Term, and each Term records the building block Uc^(p_1)_o_1c^(p_2)_o_2dots c^(p_l)_o_l. It can be initialised by the method ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Term(coeff :: ComplexF64, cstr :: Vector{Int64})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The addition and multiplication of terms are supported, and the terms can be simplified by the method SimplifyTerms","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SimplifyTerms(tms :: Vector{Term})","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, several useful operator terms are built-in.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, the full code that records the Hamiltonian is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using WignerSymbols\n# Input the parameters of the Hamiltonian\nps_pot = [ 4.75, 1. ] * 2.\nh = 3.16\ntms_hmt = Term[]\n# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m\nm = zeros(Int64, 4)\nfor m[1] = 0 : nm - 1, m[2] = 0 : nm - 1, m[3] = 0 : nm - 1\n    m[4] = m[1] + m[2] - m[3]\n    (m[4] < 0 || m[4] >= nm) && continue\n    f = [0, 1, 1, 0]\n    o = m .* nf .+ f .+ 1\n    mr = m .- s\n    \n    # Calculate the matrix element val from pseudo-potentials\n    val = ComplexF64(0)\n    for l in eachindex(ps_pot)\n        (abs(mr[1] + mr[2]) > nm - l || abs(mr[3] + mr[4]) > nm - l) && break \n        val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, mr[1], mr[2], -mr[1] - mr[2]) * wigner3j(s, s, nm - l, mr[4], mr[3], -mr[3] - mr[4])\n    end \n    # Record the interaction term val, \"Cdag\", o1, \"Cdag\", o2, \"C\", o3, \"C\", o4\n    tms_hmt += Terms(val, [1, o[1], 1, o[2], 0, o[3], 0, o[4]])\nend \nfor m = 0 : nm - 1\n    o = m * nf .+ [1, 2]\n    # Record the transverse field term\n    tms_hmt += Terms(-h, [1, o[1], 0, o[2]])\n    tms_hmt += Terms(-h, [1, o[2], 0, o[1]])\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in functions","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ïƒ1 = [ 1 0 ; 0 0 ]\nÏƒ2 = [ 0 0 ; 0 1 ]\nÏƒx = [ 0 1 ; 1 0 ]\nÏƒz = [ 1 0 ; 0 -1]\nps_pot = [ 4.75, 1.0 ] * 2.0\nfld_h = 3.16\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot, Ïƒ1, Ïƒ2)\n    - fld_h * GetPolTerms(nm, 2, Ïƒx) \n)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We also need to construct the total angular momentum. It is defined as ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    L^2=L^+L^-+(L^z)^2-L^z","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"as c_m carries the mathrmSO(3) spin-s representation, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    L^z=sum_mfmc_m^dagger c_mquad L^pm=sum_mfsqrt(smp m)(spm m+1)c^dagger_mpm 1c_m","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we can first construt its building blocks and use the addition and multiplication of the terms","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_lz = [ Term(m - s - 1, [1, (m - 1) * nf + f, 0, (m - 1) * nf + f]) for m = 1 : nm for f = 1 : nf ]\ntms_lp = [ Term(sqrt((nm - m) * m), [1, m * nf + f, 0, (m - 1) * nf + f]) for m = 1 : nm - 1 for f = 1 : nf ]\ntms_lm = tms_lp' \ntms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Alternatively, using the built-in functions,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, nf)","category":"page"},{"location":"tutorial/#Generating-the-Sparse-Matrix","page":"Tutorial","title":"Generating the Sparse Matrix","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having gotten the terms in the many-body operator, we now need to generate the matrix elements given the initial and final basis and find its eigenstates. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the mutable type Operator records the terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.  be initialised with the method ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Operator(bsd :: Basis[, bsf :: Basis], terms :: Vector{Term} ; red_q :: Int64, sym_q :: Int64)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the sparse matrix is stored in the mutable type OpMat{T} where T is the type of the elements (ComplexF64 or Float64). It can be generated from the method","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"OpMat[{T}](op :: Operator)","category":"page"},{"location":"tutorial/#Finding-the-Eigenstates","page":"Tutorial","title":"Finding the Eigenstates","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After generating the sparse matrix, the method GetEigensystem uses the Fortran Arpack package to calculate its lowest eigenstates. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, the full code to calculate the lowest N_mathrmst=10 eigenstates from the basis and the terms is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nst = 10\nhmt = Operator(bs, tms_hmt)\nhmt_mat = OpMat(hmt)\nenrg, st = GetEigensystem(hmt_mat, nst)","category":"page"},{"location":"tutorial/#Write-the-Sparse-Matrix-into-a-HDF5-File","page":"Tutorial","title":"Write the Sparse Matrix into a HDF5 File","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It is sometimes needed to write the sparse matrix into file to avoid extra effort to generate it again in another calculation. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using HDF5 \nf = h5open(\"data.h5\", \"cw\")\nwrite(f, \"hmt_mat\", hmt_mat)\nclose(f)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To read from the file","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f = h5open(\"data.h5\", \"r\") \nhmt_mat = read(f, \"hmt_mat\", OpMat{ComplexF64})\nclose(f)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Apart from OpMat, the supported types for writing include Confs, Basis, Terms, Operator, OpMat{ComplexF64} and OpMat{Float64}. For details, refer to the â€œHDF5 Extensionâ€","category":"page"},{"location":"tutorial/#Inner-Product-of-States,-Operators-and-Transformations","page":"Tutorial","title":"Inner Product of States, Operators and Transformations","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having obtained the eigenstates, we need to make measurements on it. The simplest kind of measurements is the inner product of a many body operator with two states langle jmathscrOirangle. FuzzifiED supports the inner product and vector product of Operator and OpMat{T} with vectors that represent the state","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(op :: Operator) * (st_d :: Vector{T}) :: Vector{T}\n(mat :: OpMat{T}) * (st_d :: Vector{T}) :: Vector{T}\n(st_f :: Vector{T}) * (op :: Operator) * (st_d :: Vector{T}) :: T\n(st_f :: Vector{T}) * (mat :: OpMat{T}) * (st_d :: Vector{T}) :: T","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For example, the code to measure the angular momenta of each state is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = Operator(bs, tms_l2)\nl2_mat = OpMat(l2)\nl2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]","category":"page"},{"location":"tutorial/#Go-through-All-the-Sectors","page":"Tutorial","title":"Go through All the Sectors","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"One can repeat the calculation for all the sectors and records the results","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"result = []\nfor P in [1, -1], Z in [1, -1], R in [1, -1]\n    bs = Basis(cfs, [P, Z, R], qnf)\n    hmt = Operator(bs, tms_hmt)\n    hmt_mat = OpMat(hmt)\n    enrg, st = GetEigensystem(hmt_mat, 10)\n\n    l2 = Operator(bs, tms_l2)\n    l2_mat = OpMat(l2)\n    l2_val = [ st[:, i]' * l2_mat * st[:, i] for i in eachindex(enrg)]\n\n    for i in eachindex(enrg)\n        push!(result, round.([enrg[i], l2_val[i], P, Z], digits = 6))\n    end\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We then sort the eigenstates, find the energy of ground state and stress tensor, and calibrate the scaling dimensions. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"sort!(result, by = st -> real(st[1]))\nenrg_0 = result[1][1]\nenrg_T = filter(st -> st[2] â‰Š 6 && st[3] â‰Š 1 && st[4] â‰Š 1, result)[1][1]\nresult_dim = [ [ 3 * (st[1] - enrg_0) / (enrg_T - enrg_0) ; st] for st in result ]\ndisplay(permutedims(hcat(result_dim...)))","category":"page"},{"location":"tutorial/#Measuring-Local-Observables","page":"Tutorial","title":"Measuring Local Observables","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Local observables are a kind of particularly useful operators on the fuzzy sphere. Their value at a point on the sphere can be decomposed into spherical components, and the multiplication of the components follows the triple integral formula of monopole spherical harmonics","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"beginaligned\n    mathscrO(hatmathbfn)=sum_lmY^(s)_lm(hatmathbfn)mathscrO_lm\n    (mathscrO_1mathscrO_2)_lm=sum_l_1l_2m_1m_2(mathscrO_1)_l_1m_1(mathscrO_2)_l_2m_2\n    qquadqquadtimes(-1)^s+msqrtfrac(2l_1+1)(2l_2+1)(2l_3+1)4pibeginpmatrixl_1l_2lm_1m_2-mendpmatrixbeginpmatrixl_1l_2l-s_1-s_2sendpmatrix\nendaligned","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, they are stored in the type SphereObs and can be initialised from either a function or a dictionary that specifies the components","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)\nSphereObs(s2 :: Int64, l2m :: Int64, comps :: Dict)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Their adjoint, addition, multiplication and Laplacian are supported. The related functions are StoreComps that stores all the components, GetComponent and GetPointValue that evaluate a spherical component mathscrO_lm or value at one point mathscrO(hatmathbfn). Several important types of spherical observables are built-in in FuzzifiED, viz., electron, density operator and pairing operator.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, to calculate the OPE coefficient f_sigmasigmaepsilon=langle sigman^z_00epsilonranglelangle sigman^z_000rangle, one need to first calculate the eigenstates in the mathbbZ_2-odd sector","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bs_m = Basis(cfs, [1, -1, 1], qnf)\nhmt_m = Operator(bs_m, bs_m, tms_hmt ; red_q = 1, sym_q = 1) \nhmt_mat_m = OpMat(hmt_m)\nenrg_m, st_m = GetEigensystem(hmt_mat_m, 10)\nst0 = st[:, 1] \nste = st[:, 2] \nsts = st_m[:, 1]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and then construct the density operator","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obs_nz = GetDensityObs(nm, 2, Ïƒz)\ntms_nz00 = SimplifyTerms(GetComponent(obs_nz, 0.0, 0.0))\nnz00 = Operator(bs, bs_m, tms_nz00 ; red_q = 1) \nf_sse = abs((sts' * nz00 * ste) / (sts' * nz00 * st0))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Besides the spherical observable, we also provide a type AngModes that superposes under the rule of angular momentum superposition instead of spherical harmonics triple integral","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    (mathscrA_1mathscrA_2)_lm=sum_l_1m_1l_2m_2(mathscrA_1)_l_1m_1(mathscrA_2)_l_2m_2langle l_1m_1l_2m_2lmrangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The interfaces are similar.","category":"page"},{"location":"tutorial/#Measuring-the-Entanglement","page":"Tutorial","title":"Measuring the Entanglement","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A non-local quantity that bears particular significance is the entanglement. To calculate the entanglement, we divide the sphere into two parts A and B. The reduced density matrix of part A is obtained by tracing the density matrix over the part B","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    rho_A(Psi)=operatornametr_BPsiranglelanglePsi","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The entanglement entropy is S=-operatornametrrho_Alogrho_A and the entanglement spectrum is the collection of eigenvalues of rho_A taken negative logarithm. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The detail of the calculation is given in PRB 85, 125308 (2012). Here we only sketch the process. The creation operator in each orbital is divided into the creation on A part and the creation on B part. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    c^dagger_o=alpha_oc^dagger_oA+beta_mc^dagger_oB","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where alpha_o^2+beta_o^2=1. For the cut in orbital space m_c, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    alpha_mf=Theta(m_c-m)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where Theta is the Heaviside function ; for the cut in real space along latitude circle theta_c,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    alpha_mf=Beta_cos^2theta_c2(s-m+1s+m+1)^12","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where Beta is the incomplete beta function. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To calculate the reduced density matrix, we decompose the state into the direct-product basis of two subsystems","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    Psirangle=sum_K_0v_K_0K_0rangle=sum_I_AJ_BM_I_AJ_BI_ArangleJ_Brangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"where the indices K_0inmathscrHI_AinmathscrH_AJ_BinmathscrH_B are in the overall Hilbert space and the Hilbert space of subsystem A and B. The density matrix is then ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    rho_A=mathbfMmathbfM^dagger","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the entanglement spectrum can be obtained from the SVD decomposition of the mathbfM matrix. Like the Hamiltonian, the mathbfM matrix is block diagonal, and each block carries different quantum numbers of the Hilbert spaces of A and B subsystem. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, the decomposition of states into matrix M_I_AJ_B is done by the funciton StateDecompMat, and the calculation of entanglement spectrum is done by the funciton GetEntSpec.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, to calculate the entanglement entropy cut from the equator, we first need to specify the quantum numbers of the subsystems : the conservation of N_e, L_z and the mathbbZ_2 symmetry.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"qnd_a = [ GetNeQNDiag(no), GetLz2QNDiag(nm, nf) ]\nqnf_a = [ GetFlavPermQNOffd(nm, nf, [2, 1]) ]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"we then specify the sectors to calculate : The number of electrons in subsystem A run from 0 to N_m ; the angular momenta in subsystem A can take all permitted values ; for subsystem B, N_eB=N_m-N_eA, L_zB=-L_zA ; the mathbbZ_2 sectors of the two subsystems are the same. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"secd_lst = Vector{Vector{Int64}}[]\nfor nea = 0 : nm \n    neb = nm - nea \n    for lza = -min(nea, neb) * (nm - 1) : 2 : min(nea, neb) * (nm - 1)\n        lzb = -lza \n        push!(secd_lst, [[nea, lza], [neb, lzb]])\n    end\nend\nsecf_lst = [ [[1], [1]], [[-1], [-1]] ]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we specify the list of amplitute alpha_m.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"amp_oa = [ sqrt(beta_inc(m, nm - m + 1, 0.5)) for f = 1 : 2 for m = 1 : nm]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To calculate the entanglement spectrum, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ent_spec = GetEntSpec(st_g, bs, secd_lst, secf_lst ; qnd_a, qnf_a, amp_oa)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The entanglement entropy can be calculated by collecting all the eigenvalues of the density matrix.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"eig_rho = vcat(values(ent_spec)...)\nent_entropy = -sum(eig_rho .* log.(eig_rho))","category":"page"},{"location":"tutorial/#DMRG-with-FuzzifiED","page":"Tutorial","title":"DMRG with FuzzifiED","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having introduced ED, we now turn to density matrix renormalisation group (DMRG) that deals with larger systems. We briefly describe its procedure  and give an instruction for using FuzzifiED for DMRG. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Practically, the dmrg function in ITensor package automatically uses DMRG to optimise a matrix product state (MPS) to be the lowest eigenstate of a Hermitian Hamiltonian represented as a matrix product operator (MPO). To generate the input of the function, one needs to ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"construct a set of sites that carries a certain set of QNDiags,\nconstruct a MPO representing the Hamiltonian on the sites from a set of terms (or OpSum in ITensor), and \nconstruct an initial MPS on the sites in the desired symmetry sector.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In FuzzifiED, a new SiteType \"FuzzyFermion\" is defined that behaves similar to the built-in \"Fermion\" type and the set of sites can be generated by the function GetSites.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In the example of Ising model, for convenience we exchange the Pauli matrices sigma^x and sigma^z so that the two flavours carry mathbbZ_2-charge 0 and 1. The sites can be constructed by ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"nm = 12\nnf = 2\nno = nm * nf\nsites = GetSites([\n    GetNeQNDiag(nm * nf), \n    GetLz2QNDiag(nm, nf),\n    GetZnfChargeQNDiag(nm, nf)\n])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In ITensor, the MPO is generated from an OpSum and the sites. The OpSum can be directly converted from the array of terms. In the example of Ising model, ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ïƒx = [  0  1 ;  1  0 ]\nÏƒz = [  1  0 ;  0 -1 ]\nps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, Ïƒx) - \n    3.16 * GetPolTerms(nm, nf, Ïƒz)\n)\nos_hmt = OpSum(tms_hmt)\nhmt = MPO(os_hmt, sites)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To calculate the mathbbZ_2-even L^z=0 sector, the initial state can be taken as the all the mathbbZ_2-even sites being filled and all the mathbbZ_2-odd sites being empty. (Note that ITensor takes the string \"1\" instead of the number 1 as occupied and \"0\" instead of 0 as filled.) ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cfi_p = [ [1, 0][f] for m = 1 : nm for f = 1 : nf ]\nsti_p = MPS(sites, string.(cfi_p))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Having these ingrediants ready, we can call the dmrg function. To ensure performance, the maximal bond dimension should be increased gradually and the noise decreased gradually to 0. An example that deals with maximal bond dimension 500 is ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"E0, st0 = dmrg(hmt, sti_p ; \n    nsweeps = 10, \n    maxdim = [10,20,50,100,200,500], \n    noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], \n    cutoff = [1E-8])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate a mathbbZ_2-odd initial state, we can simply flip the spin on the first orbital","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cfi_m = [ m == 1 ? [0, 1][f] : [1, 0][f] for m = 1 : nm for f = 1 : nf ]\nsti_m = MPS(sites, string.(cfi_m))\nEs, sts = dmrg(hmt, sti_m ; \n    nsweeps = 10, \n    maxdim = [10,20,50,100,200,500], \n    noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], \n    cutoff = [1E-8])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first excited mathbbZ_2-even state can be generated by adding a projector w0ranglelangle0 to the MPO ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ee, ste = dmrg(hmt, [st0], sti_p ; \n    nsweeps = 10, \n    maxdim = [10,20,50,100,200,500], \n    noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], \n    cutoff = [1E-8], \n    weight = 100)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The inner product can be measured by the ITensor function inner. For example, to measure the angular momentum L^2 of the ground state,","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = MPO(OpSum(tms_l2), sites)\nval_l20 = inner(st0', l2, st0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To measure the OPE coefficient f_sigmasigmaepsilon=langle sigman^x_00epsilonranglelangle sigman^x_000rangle. (Note that the indices x and z have already been exchanged here.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obs_nx = GetDensityObs(nm, 2, Ïƒx)\ntms_nx00 = SimplifyTerms(GetComponent(obs_nx, 0.0, 0.0))\nnx00 = MPO(OpSum(tms_nx00), sites)\nf_sse = abs(inner(sts', nx00, ste) / inner(sts', nx00, st0))","category":"page"},{"location":"tutorial/#The-Easy-Sweep-Extension","page":"Tutorial","title":"The Easy-Sweep Extension","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The extension Easy-Sweep facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. This extension contains the following functions : GetMPOSites, GetMPO, SweepOne, EasySweep.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To use the this extension, one need to use the packages ITensors, ItensorMPS and HDF5. A path need to be created a priori to store the result HDF5 files. We recommend using the package ITensorMPOConstruction to generate the MPO, which can be installed through ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Pkg ; Pkg.add(url=\"https://github.com/ITensor/ITensorMPOConstruction.jl.git\"); ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using FuzzifiED\nusing ITensors, ITensorMPS, HDF5\nusing ITensorMPOConstruction\nconst Ïƒx = [  0  1 ;  1  0 ]\nconst Ïƒz = [  1  0 ;  0 -1 ]\n\nfunction MyMPO(os, sites)\n    operatorNames = [ \"I\", \"C\", \"Cdag\", \"N\" ]\n    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]\n    return MPO_new(os, sites ; basis_op_cache_vec = opCacheVec)\nend\n\nnm = 12\nnf = 2\nno = nm * nf\n\npath = \"nm_$(nm)_tmp/\"\nmkpath(path)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Like the previous section, we first put in the terms for Hamiltonian and the QNDiags ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ps_pot = [4.75, 1.] ./ 2\ntms_hmt = SimplifyTerms(\n    GetDenIntTerms(nm, 2, ps_pot) - \n    GetDenIntTerms(nm, 2, ps_pot, Ïƒx) - \n    3.16 * GetPolTerms(nm, 2, Ïƒz)\n)\nqnd = [ \n    GetNeQNDiag(no), \n    GetLz2QNDiag(nm, nf), \n    GetZnfChargeQNDiag(nm, nf) \n]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The Sites and Hamiltonian MPO can be generated with the function GetMPOSites. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"hmt, sites = GetMPOSites(\"hmt\", tms_hmt, qnd ; path, mpo_method = MyMPO)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To generate the initial MPS that respects the mathbbZ_2 symmetry, we can use a direct product state. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"cfi_p = [ [1, 0][f] for m = 1 : nm for f = 1 : nf ]\nsti_p = MPS(sites, string.(cfi_p))\ncfi_m = [ m == 1 ? [0, 1][f] : [1, 0][f] for m = 1 : nm for f = 1 : nf ]\nsti_m = MPS(sites, string.(cfi_m))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The lowest eigenenergies and the eigenstate MPSs 0ranglesigmarangleepsilonrangle can be easily generated by the function EasySweep.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"E0, st0 = EasySweep(\"0\", hmt, sti_p ; path)\nEe, ste = EasySweep(\"e\", hmt, sti_p ; path, proj = [\"0\"])\nEs, sts = EasySweep(\"s\", hmt, sti_m ; path)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To measure the angular momentum L^2 of the ground state, we generate the MPO for L^2.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"tms_l2 = GetL2Terms(nm, 2)\nl2 = GetMPO(\"l2\", tms_l2, sites ; path, mpo_method = MyMPO)\nval_l20 = inner(st0', l2, st0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Similarly, to measure the OPE coefficient f_sigmasigmaepsilon=langle sigman^x_00epsilonranglelangle sigman^x_000rangle","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"obs_nx = GetDensityObs(nm, 2, Ïƒx)\ntms_nx00 = SimplifyTerms(GetComponent(obs_nx, 0.0, 0.0))\nnx00 = GetMPO(\"nx00\", tms_nx00, sites ; path, mpo_method = MyMPO)\nf_sse = abs(inner(sts', nx00, ste) / inner(sts', nx00, st0))","category":"page"},{"location":"tutorial/#List-of-Examples","page":"Tutorial","title":"List of Examples","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We offer a series of other examples that reproduces various achievements of fuzzy sphere. For a more detailed summary of the background, see the review of existing works. ","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ising_spectrum.jl calculates the spectrum of 3D Ising model on the fuzzy sphere at N_m = 12. For each (PZR) sector, 20 states are calculated. This example reproduces Table I and Figure 4 in Zhu 2022.\nising_phase_diagram.jl calculates the phase diagram of fuzzy sphere Ising modelby calculating the order parameter langle M^2rangle. This example reproduces Figure 3 in Zhu 2022.\nising_ope.jl calculates various OPE coefficients at N_m = 12 by taking overlaps between CFT states and density operators and composite. This example reproduces Figure 2 and Table I in Hu 2023Mar.\nising_correlator.jl calculates the ÏƒÏƒ two-point function on sphere and the ÏƒÏƒÏƒÏƒ four-point function on sphere, 0 and . This example reproduces Figures 1c and 2a in Han 2023Jun.\nising_optimisation.jl defines a cost function as the square sum of the deviations of descendants and stress tensor to evaluate the conformal symmetry for Ising model and minimises this cost function to find the best parameter.\nising_full_spectrum.jl calculates the full spectrum of 3D Ising model on the fuzzy sphere at N_m = 10 for sector (PZR) = (111).\nising_space_entangle.jl calculates the entanglement entropy of the Ising ground state along the real space cut of Î¸ = 0500Ï€ and 0499Ï€ respectively, and use these two data to extract finite size F-function without sustracting the IQHE contribution. This example reproduces Figures 3 in Hu 2024.\nising_orbital_entangle.jl calculates the entanglement entropy of the Ising ground state along the orbital space cut at m = 0, and also the entanglement spectrum in the half-filled l_z = 0 1 and  both mathbbZ_2 sectors.\nising_generator.jl examines the quality of conformal symmetry at N_m = 12 by examining the matrix elements of conformal generators P^z + K^z and compare the states (P^z + K^z)Î¦ with the CFT expectations. This example reproduces Figure 7 in Fardelli 2024.\ndefect_spectrum.jl calculates the spectrum of magnetic line defect in 3D Ising model in l_z = 0 P = 1 and l_z = 1 sectors, calibrated by bulk T. This example reproduces Table I in Hu 2023Aug.\ndefect_correlator.jl calculates the 1-pt function Ïƒ and 2-pt function ÏƒhatÏ• of magnetic line defect in 3D Ising model. The normalisation of the correlators require extra bulk data. This example reproduces Figure 4 in Hu 2023Aug.\ndefect_changing.jl calculates the spectrum of the defect creation and changing operators of the magnetic line defect in 3D Ising model. This example reproduces Table 2 and Figure 5 in Zhou 2024Jan.\ndefect_overlap.jl calculates the g-function of magnetic line defect in 3D Ising model using the ovelaps between the bulk, defect ground state and the lowest defect-creation state. This example reproduces Figure 6 in Zhou 2024Jan.\ncusp_dim.jl calculates the scaling dimension of the cusp of the magnetic line defect in 3D Ising model as a function of the angle Î¸. This example reproduces Table 2, upper panel in Cuomo 2024.\nsurface_ordinary_spectrum.jl calculates the spectrum of ordinary surface CFT in 3D Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figures 3 and 4 in Zhou 2024Jul.\nsurface_normal_spectrum.jl calculates the spectrum of normal surface CFT in 3D Ising model calibrated by surface displacement operator D in the orbital boundary scheme. This example reproduces Figure 5 in Zhou 2024Jul.\nhsb_2l_spectrum.jl calculates the spectrum of mathrmO(3) Wilson-Fisher CFT using the bilayer Heisenberg model. This example reproduces Table I and Figure 2 in Han 2023Dec.\nso5_spectrum.jl calculates the spectrum of SO(5) DQCP on the fuzzy sphere. This example reproduces Table II in Zhou 2023.\nsp3_spectrum.jl calculates the spectrum of Sp(3) CFT on the fuzzy sphere. This example reproduces Table I in Zhou 2024Oct.\nising_frac_fermion.jl calculates the spectrum of 3D Ising model on the fuzzy sphere for fermions at fractional filling Î½ = 13. This example reproduces Figure 10 in Voinea 2024.\nising_frac_boson.jl calculates the spectrum of 3D Ising model on the fuzzy sphere for bosons at fractional filling Î½ = 12 with the module Fuzzifino. This example reproduces Figure 12a,b in Voinea 2024.\npotts_spectrum.jl calculates the spectrum of 3D Potts model on the fuzzy sphere. This example reproduces Table I and Figure 4 in Yang 2025Jan.\ncircle_ising.jl calculates the spectrum of 2d Ising CFT on a fuzzy thin torus. This example reproduces Figure 4 and Tables Iâ€”III in Han 2025.\nyang_lee_spectrum.jl calculates the spectrum of 3D non-unitary Yang-Lee CFT on the fuzzy sphere. This example reproduces the finite size data of Figure 11 Arguello Cruz 2025\nfree_scalar_spectrum.jl calculates the spectrum of free real scalar. This example reproduces Figure 2 in He 2025Jun.\nfree_scalar_correlator.jl calculates calculates the correlator of n^i for Ï•, Ï•^2 and Ï€ of free real scalar. This example reproduces Figure 3 in He 2025Jun\no4_dqcp_spectrum.jl calculates the spectrum of mathrmO(4) DQCP on the fuzzy sphere. This example reproduces Figure 4 and Table I in Yang 2025Jul.\nsu2_1_scal_spectrum.jl calculates the spectrum of the mathrmSU(2)_1 coupled to a complex scalar Chern-Simons matter CFT on the fuzzy sphere. This example reproduces Figs. 2d and 3 in Zhou 2025Jul.\nfree_majorana_spectrum.jl calculates the spectrum of free Majorana fermion. This example reproduces Figure 5 in Zhou 2025Sep. \nfree_majorana_correlator.jl calculates the 2-pt correlator of free Majorana fermion. This example reproduces Figure 7 in Zhou 2025Sep.\nbpf_220_spectrum.jl calculates the spectrum of the transition between bosonic Pfaffian and Halperin 220 described by gauged Majorana fermion CFT. This example reproduces Figure 4a in Voinea 2025\no3_wf_spectrum.jl calculates the spectrum of mathrmO(3) Wilson-Fisher CFT. This example takes the model from Dey 2025 and reproduces partly Tables I and II, Figures 1 and 2.\no2_wf_spectrum.jl calculates the spectrum of mathrmO(2) Wilson-Fisher CFT. This example reproduces Figure 3, upper panel in Guo 2025.\no2_free_spectrum.jl calculates the spectrum of mathrmO(2) free scalar CFT. This example reproduces Figure 4, upper-left panel in Guo 2025.\no4_wf_spectrum.jl calculates the spectrum of mathrmO(4) Wilson-Fisher CFT. This example reproduces Figure 3, lower panel in Guo 2025.\nising_spectrum_krylov.jl calculates the spectrum of 3D Ising model on the fuzzy sphere by calling the eigsolve function in KrylovKit.jl instead of Arpack.\nising_spectrum_cuda.jl calculates the spectrum of 3D Ising model on the fuzzy sphere for one sector by performing the sparse matrix multiplication on CUDA.","category":"page"}]
}
