<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · FuzzifiED.jl</title><meta name="title" content="Tutorial · FuzzifiED.jl"/><meta property="og:title" content="Tutorial · FuzzifiED.jl"/><meta property="twitter:title" content="Tutorial · FuzzifiED.jl"/><meta name="description" content="Documentation for FuzzifiED.jl."/><meta property="og:description" content="Documentation for FuzzifiED.jl."/><meta property="twitter:description" content="Documentation for FuzzifiED.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/serif.css" rel="stylesheet" type="text/css"/><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="FuzzifiED.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">FuzzifiED.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../intro/">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#ED-with-FuzzifiED"><span>ED with FuzzifiED</span></a></li><li><a class="tocitem" href="#DMRG-with-FuzzifiED"><span>DMRG with FuzzifiED</span></a></li><li><a class="tocitem" href="#List-of-examples"><span>List of examples</span></a></li></ul></li><li><a class="tocitem" href="../core/">Core functions</a></li><li><a class="tocitem" href="../models/">Built-in models</a></li><li><a class="tocitem" href="../itensors/">ITensor extension</a></li><li><a class="tocitem" href="../extension/">Other extensions</a></li><li><a class="tocitem" href="../fuzzifino/">Fuzzifino</a></li><li><a class="tocitem" href="../manifolds/">Fuzzy manifolds</a></li><li><a class="tocitem" href="../releases/">Releases</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FuzzifiED/FuzzifiED.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/docs/src/tutorial.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="FuzzifiED-explained-in-a-tutorial"><a class="docs-heading-anchor" href="#FuzzifiED-explained-in-a-tutorial">FuzzifiED explained in a tutorial</a><a id="FuzzifiED-explained-in-a-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#FuzzifiED-explained-in-a-tutorial" title="Permalink"></a></h1><p>To demonstrate the usage of FuzzifiED interfaces for ED and DMRG, in this section, we use a tutorial that calculates the eigenstates for the Ising model on fuzzy sphere. Specifically, it</p><ol><li>calculates the lowest eigenstates in the symmetry sector <span>$L^z=0$</span> and <span>$(\mathcal{P},\mathcal{Z},\mathcal{R})=(+,+,+)$</span>,</li><li>measures their total angular momenta, and </li><li>calcultes the OPE coefficient <span>$f_{\sigma\sigma\epsilon}=\langle \sigma|n^z_{00}|\epsilon\rangle/\langle \sigma|n^z_{00}|0\rangle$</span>.</li></ol><p>Four versions of the tutorial code are provided : </p><ol><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/tutorial_ising.jl"><code>tutorial_ising.jl</code></a> – the ED code that uses the built-in models.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/tutorial_ising_primitive.jl"><code>tutorial_ising_primitive.jl</code></a> – The ED code that uses only the core functions.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/tutorial_ising_dmrg.jl"><code>tutorial_ising_dmrg.jl</code></a> – the DMRG code that converts the format into ITensor.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/tutorial_ising_dmrg_easysweep.jl"><code>tutorial_ising_dmrg_easysweep.jl</code></a> – the DMRG code that uses the EasySweep extension.</li></ol><p>The examples can be found in the directory <a href="https://github.com/FuzzifiED/FuzzifiED.jl/tree/main/examples"><code>examples</code></a>. We also append in the end <a href="#List-of-examples">a list of given examples</a> at the end of the page. </p><h2 id="ED-with-FuzzifiED"><a class="docs-heading-anchor" href="#ED-with-FuzzifiED">ED with FuzzifiED</a><a id="ED-with-FuzzifiED-1"></a><a class="docs-heading-anchor-permalink" href="#ED-with-FuzzifiED" title="Permalink"></a></h2><p>In this section, we briefly describe the procedure for exact diagonalisation (ED) calculation and give an instruction for using FuzzifiED for ED. </p><p>Practically, the ED calculation can be divided into 4 steps.</p><ul><li>Construct a many-body basis that respect a given set of quantum numbers. Specifically, in FuzzifiED we support quantum numbers of commuting <span>$\mathrm{U}(1)$</span> or discrete <span>$\mathbb{Z}_p$</span> symmetries.</li><li>Construct the sparse matrix corresponding to the Hamiltonian in the basis above. </li><li>Find the lowest eigenstates and their corresponding eigenenergies of the sparse matrix.</li><li>Making measurements on the eigenstates. This including the total angular momentum, density operators, entanglement, <em>etc.</em></li></ul><h3 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h3><p>Before starting the calculation, we need to input the setup for the system, including the number of flavours <span>$N_f$</span>, orbitals <span>$N_m$</span> and sites <span>$N_o$</span> </p><ul><li>A &#39;flavour&#39; is labelled by <span>$f$</span>. The number of flavours is <span>$N_f$</span>.</li><li>An &#39;orbital&#39; is specified by the magnetic quantum number labelled by <span>$m$</span>. The number of orbitals is <span>$N_m=2s+1$</span>.</li><li>A &#39;site&#39; is specific by both the flavour and the orbital index <span>$o=(f,m)$</span>. The number of sites is <span>$N_o=N_mN_f$</span>. In practice, we label the sites with an integer from <span>$1$</span> to <span>$N_o$</span>. We store the sites in an ascending order of first <span>$m$</span> and then <span>$f$</span> : <span>$o=(m+s)N_f+f$</span>.</li></ul><p>In the example of Ising model with <span>$s=5.5$</span>,</p><pre><code class="language-julia hljs">nm = 12
nf = 2
no = nm * nf</code></pre><p>FuzzifiED also provides several environment parameters that defines how FuzzifiED works, <em>viz.</em> <a href="../core/#FuzzifiED.ElementType">FuzzifiED.ElementType</a>, <a href="../core/#FuzzifiED.NumThreads">FuzzifiED.NumThreads</a> and <a href="../core/#FuzzifiED.SilentStd">FuzzifiED.SilentStd</a>.</p><h3 id="Constructing-the-configurations"><a class="docs-heading-anchor" href="#Constructing-the-configurations">Constructing the configurations</a><a id="Constructing-the-configurations-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-configurations" title="Permalink"></a></h3><p>The first step for the ED calculation is to construct the basis tha respects the symmetries of the Hamiltonian. This is divided into two steps : (1) generate the &#39;configurations&#39; that carry the diagonal quantum numbers, and (2) generate the &#39;basis&#39; that also carry the off-diagonal quantum numbers (under discrete transformations). The &#39;<em>configurations</em>&#39; are the collection of states that can be written as direct product of occupied <span>$|1\rangle$</span> or empty <span>$|0\rangle$</span> on each site and carries certain diagonal quantum numbers (QNDiag). </p><p>The QNDiags supported by FuzzifiED are the charges of <span>$\mathrm{U}(1)$</span> or <span>$\mathbb{Z}_p$</span> symmetry in the form of </p><p class="math-container">\[\begin{aligned}
    Q&amp;=\sum_oq_on_o&amp;\mathrm{U}(1)&amp;\textrm{ symmetry}\\
    Q&amp;=\sum_oq_on_o\mod p&amp;\mathbb{Z}_p&amp;\textrm{ symmetry}
\end{aligned}\]</p><p>where <span>$n_o=c^\dagger_oc_o$</span> is the particle number on each site, and <span>$q_o$</span> is the charge that each orbital carries. FuzzifiED restricts <span>$q_o$</span> to be integer-valued. In FuzzifiED, the QNDiags are recorded in the mutable type <a href="../core/#FuzzifiED.QNDiag"><code>QNDiag</code></a>. Several useful QNDiags are <a href="../models/#Diagonal-quantum-numbers-on-fuzzy-sphere">built-in</a>. </p><p>The collection of configurations is generated from the QNDiags. It is recorded in the mutable type <a href="../core/#FuzzifiED.Confs"><code>Confs</code></a>  and can be constructed by the method </p><pre><code class="language-julia hljs">Confs(no :: Int64, secd :: Vector{Int64}, qnd :: Vector{QNDiag})</code></pre><p>where <code>qnd</code> is the array of QNDiags, and <code>secd</code> is the array of charges <span>$Q$</span> of each QNDiag. Here each configuration is stored as a binary number with <span>$N_o$</span> bits. If the <span>$o$</span>-th site in the configuration is occupied, the <span>$(o-1)$</span>-th bit of the configuration is <span>$1$</span>; if the site is empty, then the bit is <span>$0$</span>. Besides the storation of the configuration, we also need a reverse look-up process that returns the index from the binary string. This is realised by a Lin table.</p><p>In the example of Ising model, there are two QNDiags, <em>viz.</em> the particle number and the angular momentum. </p><p class="math-container">\[\begin{aligned}
Q_1&amp;=N_e,&amp; q_{1,m\sigma}&amp;=1\\
Q_2&amp;=2L_z,&amp;q_{2,m\sigma}&amp;=2m
\end{aligned}\]</p><p>The full code to generating the configurations in the <span>$L_z=0$</span> sector is </p><pre><code class="language-julia hljs">qnd = [ 
    QNDiag(fill(1, no)), 
    QNDiag([ 2 * m - nm - 1 for m = 1 : nm for f = 1 : nf ])
]
cfs = Confs(no, [nm, 0], qnd)</code></pre><p>Alternatively, using the built-in models, </p><pre><code class="language-julia hljs">qnd = [ 
    GetNeQNDiag(no), 
    GetLz2QNDiag(nm, nf) 
]
cfs = Confs(no, [nm, 0], qnd)</code></pre><h3 id="Constructing-the-basis"><a class="docs-heading-anchor" href="#Constructing-the-basis">Constructing the basis</a><a id="Constructing-the-basis-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-the-basis" title="Permalink"></a></h3><p>Having constructed the configurations, we now construct the basis of the Hilbert space. The `<em>basis</em>&#39; is the collection of states that are linear combinations of the configuration carrying certain diagonal and <span>$\mathbb{Z}_p$</span> off-diagonal quantum numbers (QNOffd). </p><p>The QNOffds supported by FuzzifiED are the <span>$\mathbb{Z}_p$</span> symmetry that are in the form of </p><p class="math-container">\[    \mathcal{Z}:\ c_o\to \alpha_o^* c^{(p_o)}_{\pi_o},\quad c_o^\dagger\to \alpha_o c^{(1-p_o)}_{\pi_o}\]</p><p>where we use a notation <span>$c^{(1)}=c^\dagger$</span> and <span>$c^{(0)}=c$</span> for convenience, <span>$\pi_o$</span> is a permutation of the sites <span>$1,\dots N_o$</span>, <span>$\alpha_o$</span> is a coefficient, and <span>$p_o$</span> specified whether or not particle-hole transformation is performed for the site. Note that one must guarentee that all these transformations commute with each other and also commute with the diagonal quantum numbers. In FuzzifiED, the QNOffds are recorded in the mutable type <a href="../core/#FuzzifiED.QNOffd"><code>QNOffd</code></a>. Several useful QNOffds are <a href="../models/#Off-diagonal-quantum-numbers-on-fuzzy-sphere">built-in</a>.</p><p>After implementing the QNOffds, a state in the new basis should look like </p><p class="math-container">\[    |I\rangle=\lambda_{i_{I1}}|i_{I1}\rangle+\lambda_{i_{I2}}|i_{I2}\rangle+\cdots+\lambda_{i_{Im_I}}|i_{Im_I}\rangle\]</p><p>where the <span>$|i\rangle$</span>&#39;s are configurations, and <span>$|I\rangle$</span> is a linear combination of them. This process can be regarded as organising the configurations into groups of size <span>$m_I$</span>. </p><p>In FuzzifiED, the basis <span>$\{|I\rangle\}$</span> is recorded in the mutable type <a href="../core/#FuzzifiED.Basis"><code>Basis</code></a>. It can be constructed by the methods </p><pre><code class="language-julia hljs">Basis(cfs :: Confs, secf :: Vector{ComplexF64}, qnf :: Vector{QNOffd})
Basis(cfs :: Confs)</code></pre><p>where <code>secf</code> records the eigenvalue of each transformation, typically in the form <span>$e^{i2\pi q/p}$</span> where <span>$p$</span> is the cycle and <span>$q$</span> is the <span>$\mathbb{Z}_p$</span> charge. </p><p>In the example of Ising model, There are three <span>$\mathbb{Z}_2$</span> symmetries, <em>viz.</em> the particle-hole transformation <span>$\mathcal{P}$</span>, the <span>$\pi$</span>-rotation along the <span>$y$</span>-axis <span>$\mathcal{R}_y$</span>, and the flavour (Ising) symmetry <span>$\mathcal{Z}$</span></p><p class="math-container">\[\begin{aligned}
    \mathscr{P}:c^\dagger_{\sigma m}&amp;\to\sigma c_{-\sigma,m}\\
    \mathscr{Z}:c^\dagger_{\sigma m}&amp;\to c^\dagger_{-\sigma,m}\\
    \mathscr{R}_y:c^\dagger_{\sigma m}&amp;\to c^\dagger_{\sigma,-m}\\
\end{aligned}\]</p><p>The code to generate the basis in the all-positive sector is </p><pre><code class="language-julia hljs">qnf = [
    # Parity (Particle-hole)
    QNOffd([ (m - 1) * nf + [2, 1][f] for m = 1 : nm for f = 1 : nf ], true, 
        ComplexF64[ [-1, 1][f] for m = 1 : nm for f = 1 : nf ]),
    # Flavour symmetry
    QNOffd([ (m - 1) * nf + [2, 1][f] for m = 1 : nm for f = 1 : nf ]),
    # Y-axis pi-rotation
    QNOffd([ (nm - m) * nf + f for m = 1 : nm for f = 1 : nf], 
        ComplexF64[ iseven(m) ? 1 : -1 for m = 1 : nm for f = 1 : nf ])
]
bs = Basis(cfs, [1, 1, 1], qnf) </code></pre><p>Alternatively, using the built-in functions</p><pre><code class="language-julia hljs">qnf = [ 
    GetParityQNOffd(nm, 2, [2, 1], [-1, 1]), 
    GetFlavPermQNOffd(nm, 2, [2, 1]), 
    GetRotyQNOffd(nm, 2) 
]
bs = Basis(cfs, [1, 1, 1], qnf)
# The second argument gives the eigenvalues under the transformations, for Z_2 put 1,-1 ; for Z_n put exp(2im*pi*q/p)</code></pre><h3 id="Recording-the-many-body-operator-terms"><a class="docs-heading-anchor" href="#Recording-the-many-body-operator-terms">Recording the many-body operator terms</a><a id="Recording-the-many-body-operator-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Recording-the-many-body-operator-terms" title="Permalink"></a></h3><p>Having constructed the basis, we now construct the many-body operators. A general many-body operator can be written as</p><p class="math-container">\[    \mathscr{O}=\sum_{t=1}^{N_t}U_tc^{(p_{t1})}_{o_{t1}}c^{(p_{t2})}_{o_{t2}}\dots c^{(p_{tl_t})}_{o_{tl_t}}\]</p><p>where <span>$c^{(0)}=c$</span> and <span>$c^{(1)}=c^\dagger$</span>. In FuzzifiED, this is recorded as an array of <code>Term</code>, and each <code>Term</code> records the building block <span>$Uc^{(p_{1})}_{o_{1}}c^{(p_{2})}_{o_{2}}\dots c^{(p_{l})}_{o_{l}}$</span>. It can be initialised by the method </p><pre><code class="language-julia hljs">Term(coeff :: ComplexF64, cstr :: Vector{Int64})</code></pre><p>The addition and multiplication of terms are supported, and the terms can be simplified by the method <a href="../core/#FuzzifiED.SimplifyTerms-Tuple{Vector{Term}}"><code>SimplifyTerms</code></a></p><pre><code class="language-julia hljs">SimplifyTerms(tms :: Vector{Term})</code></pre><p>In FuzzifiED, several useful operator terms are <a href="../models/#Operators-on-fuzzy-sphere">built-in</a>.</p><p>In the example of Ising model, the full code that records the Hamiltonian is </p><pre><code class="language-julia hljs">using WignerSymbols
# Input the parameters of the Hamiltonian
ps_pot = [ 4.75, 1. ] * 2.
h = 3.16
tms_hmt = Term[]
# Go through all the m1-up, m2-down, m3-down, m4-up and m4 = m1 + m2 - m
m = zeros(Int64, 4)
for m[1] = 0 : nm - 1, m[2] = 0 : nm - 1, m[3] = 0 : nm - 1
    m[4] = m[1] + m[2] - m[3]
    (m[4] &lt; 0 || m[4] &gt;= nm) &amp;&amp; continue
    f = [0, 1, 1, 0]
    o = m .* nf .+ f .+ 1
    mr = m .- s
    
    # Calculate the matrix element val from pseudopotentials
    val = ComplexF64(0)
    for l in eachindex(ps_pot)
        (abs(mr[1] + mr[2]) &gt; nm - l || abs(mr[3] + mr[4]) &gt; nm - l) &amp;&amp; break 
        val += ps_pot[l] * (2 * nm - 2 * l + 1) * wigner3j(s, s, nm - l, mr[1], mr[2], -mr[1] - mr[2]) * wigner3j(s, s, nm - l, mr[4], mr[3], -mr[3] - mr[4])
    end 
    # Record the interaction term val, &quot;Cdag&quot;, o1, &quot;Cdag&quot;, o2, &quot;C&quot;, o3, &quot;C&quot;, o4
    tms_hmt += Terms(val, [1, o[1], 1, o[2], 0, o[3], 0, o[4]])
end 
for m = 0 : nm - 1
    o = m * nf .+ [1, 2]
    # Record the transverse field term
    tms_hmt += Terms(-h, [1, o[1], 0, o[2]])
    tms_hmt += Terms(-h, [1, o[2], 0, o[1]])
end</code></pre><p>Alternatively, using the built-in functions</p><pre><code class="language-julia hljs">σ1 = [ 1 0 ; 0 0 ]
σ2 = [ 0 0 ; 0 1 ]
σx = [ 0 1 ; 1 0 ]
σz = [ 1 0 ; 0 -1]
ps_pot = [ 4.75, 1.0 ] * 2.0
fld_h = 3.16
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2, ps_pot, σ1, σ2)
    - fld_h * GetPolTerms(nm, 2, σx) 
)</code></pre><p>We also need to construct the total angular momentum. It is defined as </p><p class="math-container">\[    L^2=L^+L^-+(L^z)^2-L^z,\]</p><p>as <span>$c_m$</span> carries the <span>$\mathrm{SO}(3)$</span> spin-<span>$s$</span> representation, </p><p class="math-container">\[    L^z=\sum_{mf}mc_m^\dagger c_m,\quad L^\pm=\sum_{mf}\sqrt{(s\mp m)(s\pm m+1)}c^\dagger_{m\pm 1}c_m\]</p><p>we can first construt its building blocks and use the addition and multiplication of the terms</p><pre><code class="language-julia hljs">tms_lz = [ Term(m - s - 1, [1, (m - 1) * nf + f, 0, (m - 1) * nf + f]) for m = 1 : nm for f = 1 : nf ]
tms_lp = [ Term(sqrt((nm - m) * m), [1, m * nf + f, 0, (m - 1) * nf + f]) for m = 1 : nm - 1 for f = 1 : nf ]
tms_lm = tms_lp&#39; 
tms_l2 = SimplifyTerms(tms_lz * tms_lz - tms_lz + tms_lp * tms_lm)</code></pre><p>Alternatively, using the built-in functions,</p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, nf)</code></pre><h3 id="Generating-sparse-matrix"><a class="docs-heading-anchor" href="#Generating-sparse-matrix">Generating sparse matrix</a><a id="Generating-sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-sparse-matrix" title="Permalink"></a></h3><p>Having gotten the terms in the many-body operator, we now need to generate the matrix elements given the initial and final basis and find its eigenstates. </p><p>In FuzzifiED, the mutable type <a href="../core/#FuzzifiED.Operator"><code>Operator</code></a> records the terms together with information about its symmetry and the basis of the state it acts on and the basis of the resulting state.  be initialised with the <a href="../core/#FuzzifiED.Operator-Tuple{Basis, Basis, Vector{Term}}">method</a> </p><pre><code class="language-julia hljs">Operator(bsd :: Basis[, bsf :: Basis], terms :: Vector{Term} ; red_q :: Int64, sym_q :: Int64)</code></pre><p>In FuzzifiED, the sparse matrix is stored in the mutable type <a href="../core/#FuzzifiED.OpMat"><code>OpMat{T}</code></a> where <code>T</code> is the type of the elements (<code>ComplexF64</code> or <code>Float64</code>). It can be generated from the method</p><pre><code class="language-julia hljs">OpMat[{T}](op :: Operator)</code></pre><h3 id="Finding-the-eigenstates"><a class="docs-heading-anchor" href="#Finding-the-eigenstates">Finding the eigenstates</a><a id="Finding-the-eigenstates-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-eigenstates" title="Permalink"></a></h3><p>After generating the sparse matrix, the method <a href="../core/#FuzzifiED.GetEigensystem-Tuple{OpMat{ComplexF64}, Int64}"><code>GetEigensystem</code></a> uses the Fortran Arpack package to calculate its lowest eigenstates. </p><p>In the example of Ising model, the full code to calculate the lowest <span>$N_\mathrm{st}=10$</span> eigenstates from the basis and the terms is </p><pre><code class="language-julia hljs">nst = 10
hmt = Operator(bs, tms_hmt)
hmt_mat = OpMat(hmt)
enrg, st = GetEigensystem(hmt_mat, nst)</code></pre><h3 id="Write-the-sparse-matrix-into-HDF5-file"><a class="docs-heading-anchor" href="#Write-the-sparse-matrix-into-HDF5-file">Write the sparse matrix into HDF5 file</a><a id="Write-the-sparse-matrix-into-HDF5-file-1"></a><a class="docs-heading-anchor-permalink" href="#Write-the-sparse-matrix-into-HDF5-file" title="Permalink"></a></h3><p>It is sometimes needed to write the sparse matrix into file to avoid extra effort to generate it again in another calculation. </p><pre><code class="language-julia hljs">using HDF5 
f = h5open(&quot;data.h5&quot;, &quot;cw&quot;)
write(f, &quot;hmt_mat&quot;, hmt_mat)
close(f)</code></pre><p>To read from the file</p><pre><code class="language-julia hljs">f = h5open(&quot;data.h5&quot;, &quot;r&quot;) 
hmt_mat = read(f, &quot;hmt_mat&quot;, OpMat{ComplexF64})
close(f)</code></pre><p>Apart from <code>OpMat</code>, the supported types for writing include <code>Confs</code>, <code>Basis</code>, <code>Terms</code>, <code>Operator</code>, <code>OpMat{ComplexF64}</code> and <code>OpMat{Float64}</code>. </p><h3 id="Inner-product-of-states,-operators-and-transformations"><a class="docs-heading-anchor" href="#Inner-product-of-states,-operators-and-transformations">Inner product of states, operators and transformations</a><a id="Inner-product-of-states,-operators-and-transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Inner-product-of-states,-operators-and-transformations" title="Permalink"></a></h3><p>Having obtained the eigenstates, we need to make measurements on it. The simplest kind of measurements is the inner product of a many body operator with two states <span>$\langle j|\mathcal{O}|i\rangle$</span>. FuzzifiED supports the inner product and vector product of <code>Operator</code> and <code>OpMat{T}</code> with vectors that represent the state</p><pre><code class="language-julia hljs">(op :: Operator) * (st_d :: Vector{T}) :: Vector{T}
(mat :: OpMat{T}) * (st_d :: Vector{T}) :: Vector{T}
(st_f :: Vector{T}) * (op :: Operator) * (st_d :: Vector{T}) :: T
(st_f :: Vector{T}) * (mat :: OpMat{T}) * (st_d :: Vector{T}) :: T</code></pre><p>For example, the code to measure the angular momenta of each state is</p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)
l2 = Operator(bs, tms_l2)
l2_mat = OpMat(l2)
l2_val = [ st[:, i]&#39; * l2_mat * st[:, i] for i in eachindex(enrg)]</code></pre><h3 id="Go-through-all-the-sectors"><a class="docs-heading-anchor" href="#Go-through-all-the-sectors">Go through all the sectors</a><a id="Go-through-all-the-sectors-1"></a><a class="docs-heading-anchor-permalink" href="#Go-through-all-the-sectors" title="Permalink"></a></h3><p>One can repeat the calculation for all the sectors and records the results</p><pre><code class="language-julia hljs">result = []
for P in [1, -1], Z in [1, -1], R in [1, -1]
    bs = Basis(cfs, [P, Z, R], qnf)
    hmt = Operator(bs, tms_hmt)
    hmt_mat = OpMat(hmt)
    enrg, st = GetEigensystem(hmt_mat, 10)

    l2 = Operator(bs, tms_l2)
    l2_mat = OpMat(l2)
    l2_val = [ st[:, i]&#39; * l2_mat * st[:, i] for i in eachindex(enrg)]

    for i in eachindex(enrg)
        push!(result, round.([enrg[i], l2_val[i], P, Z], digits = 6))
    end
end</code></pre><p>We then sort the eigenstates, find the energy of ground state and stress tensor, and calibrate the scaling dimensions. </p><pre><code class="language-julia hljs">sort!(result, by = st -&gt; real(st[1]))
enrg_0 = result[1][1]
enrg_T = filter(st -&gt; st[2] ≊ 6 &amp;&amp; st[3] ≊ 1 &amp;&amp; st[4] ≊ 1, result)[1][1]
result_dim = [ [ 3 * (st[1] - enrg_0) / (enrg_T - enrg_0) ; st] for st in result ]
display(permutedims(hcat(result_dim...)))</code></pre><h3 id="Measuring-local-observables"><a class="docs-heading-anchor" href="#Measuring-local-observables">Measuring local observables</a><a id="Measuring-local-observables-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-local-observables" title="Permalink"></a></h3><p>Local observables are a kind of particularly useful operators on fuzzy sphere. Their value at a point on the sphere can be decomposed into spherical components, and the multiplication of the components follows the triple integral formula of monopole spherical harmonics</p><p class="math-container">\[\begin{aligned}
    \mathcal{O}(\hat{\mathbf{n}})&amp;=\sum_{lm}Y^{(s)}_{lm}(\hat{\mathbf{n}})\mathcal{O}_{lm}\\
    (\mathcal{O}_1\mathcal{O}_2)_{lm}&amp;=\sum_{l_1l_2m_1m_2}(\mathcal{O}_1)_{l_1m_1}(\mathcal{O}_2)_{l_2m_2}\\
    &amp;\qquad\qquad\times(-1)^{s+m}\sqrt{\frac{(2l_1+1)(2l_2+1)(2l_3+1)}{4\pi}}\begin{pmatrix}l_1&amp;l_2&amp;l\\m_1&amp;m_2&amp;-m\end{pmatrix}\begin{pmatrix}l_1&amp;l_2&amp;l\\-s_1&amp;-s_2&amp;s\end{pmatrix}
\end{aligned}\]</p><p>In FuzzifiED, they are stored in the type <a href="../models/#FuzzifiED.SphereObs"><code>SphereObs</code></a> and can be initialised from either a function or a dictionary that specifies the components</p><pre><code class="language-julia hljs">SphereObs(s2 :: Int64, l2m :: Int64, get_comp :: Function)
SphereObs(s2 :: Int64, l2m :: Int64, comps :: Dict)</code></pre><p>Their adjoint, addition, multiplication and <a href="../models/#FuzzifiED.Laplacian-Tuple{SphereObs}">Laplacian</a> are supported. The related functions are <a href="../models/#FuzzifiED.StoreComps-Tuple{SphereObs}"><code>StoreComps</code></a> that stores all the components, <a href="../models/#FuzzifiED.GetComponent-Tuple{SphereObs, Number, Number}"><code>GetComponent</code></a> and <a href="../models/#FuzzifiED.GetPointValue-Tuple{SphereObs, Float64, Float64}"><code>GetPointValue</code></a> that evaluate a spherical component <span>$\mathcal{O}_{lm}$</span> or value at one point <span>$\mathcal{O}(\hat{\mathbf{n}})$</span>. Several important types of spherical observables are built-in in FuzzifiED, <em>viz.</em>, <a href="../models/#FuzzifiED.GetElectronObs-Tuple{Int64, Int64, Int64}">electron</a>, <a href="../models/#FuzzifiED.GetDensityObs-Tuple{Int64, Int64, Matrix{&lt;:Number}}">density operator</a> and <a href="../models/#FuzzifiED.GetPairingObs-Tuple{Int64, Int64, Matrix{&lt;:Number}}">pairing operator</a>.</p><p>In the example of Ising model, to calculate the OPE coefficient <span>$f_{\sigma\sigma\epsilon}=\langle \sigma|n^z_{00}|\epsilon\rangle/\langle \sigma|n^z_{00}|0\rangle$</span>, one need to first calculate the eigenstates in the <span>$\mathbb{Z}_2$</span>-odd sector</p><pre><code class="language-julia hljs">bs_m = Basis(cfs, [1, -1, 1], qnf)
hmt_m = Operator(bs_m, bs_m, tms_hmt ; red_q = 1, sym_q = 1) 
hmt_mat_m = OpMat(hmt_m)
enrg_m, st_m = GetEigensystem(hmt_mat_m, 10)
st0 = st[:, 1] 
ste = st[:, 2] 
sts = st_m[:, 1]</code></pre><p>and then construct the density operator</p><pre><code class="language-julia hljs">obs_nz = GetDensityObs(nm, 2, σz)
tms_nz00 = SimplifyTerms(GetComponent(obs_nz, 0.0, 0.0))
nz00 = Operator(bs, bs_m, tms_nz00 ; red_q = 1) 
f_sse = abs((sts&#39; * nz00 * ste) / (sts&#39; * nz00 * st0))</code></pre><p>Besides the spherical observable, we also provide a type <a href="../models/#FuzzifiED.AngModes"><code>AngModes</code></a> that superposes under the rule of angular momentum superposition instead of spherical harmonics triple integral</p><p class="math-container">\[    (\mathscr{A}_1\mathscr{A}_2)_{lm}=\sum_{l_1m_1l_2m_2}(\mathcal{A}_1)_{l_1m_1}(\mathcal{A}_2)_{l_2m_2}\langle l_1m_1l_2m_2|lm\rangle.\]</p><p>The interfaces are similar.</p><h3 id="Measuring-the-entanglement"><a class="docs-heading-anchor" href="#Measuring-the-entanglement">Measuring the entanglement</a><a id="Measuring-the-entanglement-1"></a><a class="docs-heading-anchor-permalink" href="#Measuring-the-entanglement" title="Permalink"></a></h3><p>A non-local quantity that bears particular significance is the entanglement. To calculate the entanglement, we divide the sphere into two parts <span>$A$</span> and <span>$B$</span>. The reduced density matrix of part <span>$A$</span> is obtained by tracing the density matrix over the part <span>$B$</span></p><p class="math-container">\[    \rho_A(\Psi)=\operatorname{tr}_B|\Psi\rangle\langle\Psi|\]</p><p>The entanglement entropy is <span>$S=-\operatorname{tr}\rho_A\log\rho_A$</span> and the entanglement spectrum is the collection of eigenvalues of <span>$\rho_A$</span> taken negative logarithm. </p><p>The detail of the calculation is given in <a href="https://dx.doi.org/10.1103/PhysRevB.85.125308">PRB 85, 125308 (2012)</a>. Here we only sketch the process. The creation operator in each orbital is divided into the creation on <span>$A$</span> part and the creation on <span>$B$</span> part. </p><p class="math-container">\[    c^\dagger_o=\alpha_oc^\dagger_{o,A}+\beta_mc^\dagger_{o,B}\]</p><p>where <span>$|\alpha_o|^2+|\beta_o|^2=1$</span>. For the cut in orbital space <span>$m_c$</span>, </p><p class="math-container">\[    \alpha_{mf}=\Theta(m_c-m)\]</p><p>where <span>$\Theta$</span> is the Heaviside function ; for the cut in real space along latitude circle <span>$\theta_c$</span>,</p><p class="math-container">\[    \alpha_{mf}=\Beta_{\cos^2\theta_c/2}(s-m+1,s+m+1)^{1/2}\]</p><p>where <span>$\Beta$</span> is the incomplete beta function. </p><p>To calculate the reduced density matrix, we decompose the state into the direct-product basis of two subsystems</p><p class="math-container">\[    |\Psi\rangle=\sum_{K_0}v_{K_0}|K_0\rangle=\sum_{I_AJ_B}M_{I_AJ_B}|I_A\rangle|J_B\rangle\]</p><p>where the indices <span>$K_0\in\mathcal{H},I_A\in\mathscr{H_A},J_B\in\mathscr{H_B}$</span> are in the overall Hilbert space and the Hilbert space of subsystem <span>$A$</span> and <span>$B$</span>. The density matrix is then </p><p class="math-container">\[    \rho_A=\mathbf{M}\mathbf{M}^\dagger\]</p><p>and the entanglement spectrum can be obtained from the SVD decomposition of the <span>$\mathbf{M}$</span> matrix. Like the Hamiltonian, the <span>$\mathbf{M}$</span> matrix is block diagonal, and each block carries different quantum numbers of the Hilbert spaces of <span>$A$</span> and <span>$B$</span> subsystem. </p><p>In FuzzifiED, the decomposition of states into matrix <span>$M_{I_AJ_B}$</span> is done by the funciton <a href="../core/#FuzzifiED.StateDecompMat-Tuple{Vector{&lt;:Number}, Basis, Basis, Basis, Vector{&lt;:Number}, Vector{&lt;:Number}}">StateDecompMat</a>, and the calculation of entanglement spectrum is done by the funciton <a href="../core/#FuzzifiED.GetEntSpec-Tuple{Vector{&lt;:Number}, Basis, Vector{Vector{Vector{Int64}}}, Vector{Vector{Vector{Int64}}}}">GetEntSpec</a>.</p><p>In the example of Ising model, to calculate the entanglement entropy cut from the equator, we first need to specify the quantum numbers of the subsystems : the conservation of <span>$N_e$</span>, <span>$L_z$</span> and the <span>$\mathbb{Z}_2$</span> symmetry.</p><pre><code class="language-julia hljs">qnd_a = [ GetNeQNDiag(no), GetLz2QNDiag(nm, nf) ]
qnf_a = [ GetFlavPermQNOffd(nm, nf, [2, 1]) ]</code></pre><p>we then specify the sectors to calculate : The number of electrons in subsystem <span>$A$</span> run from <span>$0$</span> to <span>$N_m$</span> ; the angular momenta in subsystem <span>$A$</span> can take all permitted values ; for subsystem <span>$B$</span>, <span>$N_{e,B}=N_m-N_{e,A}$</span>, <span>$L_{z,B}=-L_{z,A}$</span> ; the <span>$\mathbb{Z}_2$</span> sectors of the two subsystems are the same. </p><pre><code class="language-julia hljs">secd_lst = Vector{Vector{Int64}}[]
for nea = 0 : nm 
    neb = nm - nea 
    for lza = -min(nea, neb) * (nm - 1) : 2 : min(nea, neb) * (nm - 1)
        lzb = -lza 
        push!(secd_lst, [[nea, lza], [neb, lzb]])
    end
end
secf_lst = [ [[1], [1]], [[-1], [-1]] ]</code></pre><p>Finally, we specify the list of amplitute <span>$\alpha_m$</span>.</p><pre><code class="language-julia hljs">amp_oa = [ sqrt(beta_inc(m, nm - m + 1, 0.5)) for f = 1 : 2 for m = 1 : nm]</code></pre><p>To calculate the entanglement spectrum, </p><pre><code class="language-julia hljs">ent_spec = GetEntSpec(st_g, bs, secd_lst, secf_lst ; qnd_a, qnf_a, amp_oa)</code></pre><p>The entanglement entropy can be calculated by collecting all the eigenvalues of the density matrix.</p><pre><code class="language-julia hljs">eig_rho = vcat(values(ent_spec)...)
ent_entropy = -sum(eig_rho .* log.(eig_rho))</code></pre><h2 id="DMRG-with-FuzzifiED"><a class="docs-heading-anchor" href="#DMRG-with-FuzzifiED">DMRG with FuzzifiED</a><a id="DMRG-with-FuzzifiED-1"></a><a class="docs-heading-anchor-permalink" href="#DMRG-with-FuzzifiED" title="Permalink"></a></h2><p>Having introduced ED, we now turn to density matrix renormalisation group (DMRG) that deals with larger systems. We briefly describe its procedure  and give an instruction for using FuzzifiED for DMRG. </p><p>Practically, the <code>dmrg</code> function in ITensor package automatically uses DMRG to optimise a matrix product state (MPS) to be the lowest eigenstate of a Hermitian Hamiltonian represented as a matrix product operator (MPO). To generate the input of the function, one needs to </p><ul><li>construct a set of sites that carries a certain set of QNDiags,</li><li>construct a MPO representing the Hamiltonian on the sites from a set of terms (or OpSum in ITensor), and </li><li>construct an initial MPS on the sites in the desired symmetry sector.</li></ul><p>In FuzzifiED, a new SiteType <a href="../itensors/#ITensors.space-Tuple{SiteType{FuzzyFermion}}"><code>&quot;FuzzyFermion&quot;</code></a> is defined that behaves similar to the built-in <code>&quot;Fermion&quot;</code> type and the set of sites can be generated by the function <a href="../itensors/#FuzzifiED.GetSites-Tuple{Vector{QNDiag}}"><code>GetSites</code></a>.</p><p>In the example of Ising model, for convenience we exchange the Pauli matrices <span>$\sigma^x$</span> and <span>$\sigma^z$</span> so that the two flavours carry <span>$\mathbb{Z}_2$</span>-charge <span>$0$</span> and <span>$1$</span>. The sites can be constructed by </p><pre><code class="language-julia hljs">nm = 12
nf = 2
no = nm * nf
sites = GetSites([
    GetNeQNDiag(nm * nf), 
    GetLz2QNDiag(nm, nf),
    GetZnfChargeQNDiag(nm, nf)
])</code></pre><p>In ITensor, the MPO is generated from an OpSum and the sites. The <a href="../itensors/#ITensors.Ops.OpSum-Tuple{Vector{Term}}">OpSum</a> can be directly converted from the array of terms. In the example of Ising model, </p><pre><code class="language-julia hljs">σx = [  0  1 ;  1  0 ]
σz = [  1  0 ;  0 -1 ]
ps_pot = [4.75, 1.] ./ 2
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2, ps_pot) - 
    GetDenIntTerms(nm, 2, ps_pot, σx) - 
    3.16 * GetPolTerms(nm, nf, σz)
)
os_hmt = OpSum(tms_hmt)
hmt = MPO(os_hmt, sites)</code></pre><p>To calculate the <span>$\mathbb{Z}_2$</span>-even <span>$L^z=0$</span> sector, the initial state can be taken as the all the <span>$\mathbb{Z}_2$</span>-even sites being filled and all the <span>$\mathbb{Z}_2$</span>-odd sites being empty. (Note that ITensor takes the string <code>&quot;1&quot;</code> instead of the number <code>1</code> as occupied and <code>&quot;0&quot;</code> instead of <code>0</code> as filled.) </p><pre><code class="language-julia hljs">cfi_p = [ [1, 0][f] for m = 1 : nm for f = 1 : nf ]
sti_p = MPS(sites, string.(cfi_p))</code></pre><p>Having these ingrediants ready, we can call the <code>dmrg</code> function. To ensure performance, the maximal bond dimension should be increased gradually and the noise decreased gradually to 0. An example that deals with maximal bond dimension 500 is </p><pre><code class="language-julia hljs">E0, st0 = dmrg(hmt, sti_p ; 
    nsweeps = 10, 
    maxdim = [10,20,50,100,200,500], 
    noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], 
    cutoff = [1E-8])</code></pre><p>To generate a <span>$\mathbb{Z}_2$</span>-odd initial state, we can simply flip the spin on the first orbital</p><pre><code class="language-julia hljs">cfi_m = [ m == 1 ? [0, 1][f] : [1, 0][f] for m = 1 : nm for f = 1 : nf ]
sti_m = MPS(sites, string.(cfi_m))
Es, sts = dmrg(hmt, sti_m ; 
    nsweeps = 10, 
    maxdim = [10,20,50,100,200,500], 
    noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], 
    cutoff = [1E-8])</code></pre><p>The first excited <span>$\mathbb{Z}_2$</span>-even state can be generated by adding a projector <span>$w|0\rangle\langle0|$</span> to the MPO </p><pre><code class="language-julia hljs">Ee, ste = dmrg(hmt, [st0], sti_p ; 
    nsweeps = 10, 
    maxdim = [10,20,50,100,200,500], 
    noise = [1E-4,3E-5,1E-5,3E-6,1E-6,3E-7], 
    cutoff = [1E-8], 
    weight = 100)</code></pre><p>The inner product can be measured by the ITensor function <code>inner</code>. For example, to measure the angular momentum <span>$L^2$</span> of the ground state,</p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)
l2 = MPO(OpSum(tms_l2), sites)
val_l20 = inner(st0&#39;, l2, st0)</code></pre><p>To measure the OPE coefficient <span>$f_{\sigma\sigma\epsilon}=\langle \sigma|n^x_{00}|\epsilon\rangle/\langle \sigma|n^x_{00}|0\rangle$</span>. (Note that the indices <span>$x$</span> and <span>$z$</span> have already been exchanged here.)</p><pre><code class="language-julia hljs">obs_nx = GetDensityObs(nm, 2, σx)
tms_nx00 = SimplifyTerms(GetComponent(obs_nx, 0.0, 0.0))
nx00 = MPO(OpSum(tms_nx00), sites)
f_sse = abs(inner(sts&#39;, nx00, ste) / inner(sts&#39;, nx00, st0))</code></pre><h3 id="The-EasySweep-extension"><a class="docs-heading-anchor" href="#The-EasySweep-extension">The EasySweep extension</a><a id="The-EasySweep-extension-1"></a><a class="docs-heading-anchor-permalink" href="#The-EasySweep-extension" title="Permalink"></a></h3><p>The extension EasySweep facilitates the management of DMRG process. It automatically records the intermediate results and recover these results if a job is stopped and run again on HPC. It also manages the gradual increase of maximal bond dimensions and the determination of convergence by the criteria of energy. This extension contains the following functions : <a href="../itensors/#FuzzifiED.GetMPOSites-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{QNDiag}}"><code>GetMPOSites</code></a>, <a href="../itensors/#FuzzifiED.GetMPO-Tuple{String, Union{Sum{Scaled{ComplexF64, Prod{Op}}}, Vector{Term}}, Vector{&lt;:Index}}"><code>GetMPO</code></a>, <a href="../itensors/#FuzzifiED.SweepOne-Tuple{String, MPO, MPS, Int64}"><code>SweepOne</code></a>, <a href="../itensors/#FuzzifiED.EasySweep-Tuple{String, MPO, MPS}"><code>EasySweep</code></a>.</p><p>To use the this extension, one need to use the packages <code>ITensors</code>, <code>ItensorMPS</code> and <code>HDF5</code>. A path need to be created a priori to store the result HDF5 files. We recommend using the package <code>ITensorMPOConstruction</code> to generate the MPO, which can be installed through </p><pre><code class="language-julia hljs">using Pkg ; Pkg.add(url=&quot;https://github.com/ITensor/ITensorMPOConstruction.jl.git&quot;); </code></pre><pre><code class="language-julia hljs">using FuzzifiED
using ITensors, ITensorMPS, HDF5
using ITensorMPOConstruction
const σx = [  0  1 ;  1  0 ]
const σz = [  1  0 ;  0 -1 ]

function MyMPO(os, sites)
    operatorNames = [ &quot;I&quot;, &quot;C&quot;, &quot;Cdag&quot;, &quot;N&quot; ]
    opCacheVec = [ [OpInfo(ITensors.Op(name, n), sites[n]) for name in operatorNames] for n in eachindex(sites)  ]
    return MPO_new(os, sites ; basis_op_cache_vec = opCacheVec)
end

nm = 12
nf = 2
no = nm * nf

path = &quot;nm_$(nm)_tmp/&quot;
mkpath(path)</code></pre><p>Like the previous section, we first put in the terms for Hamiltonian and the QNDiags </p><pre><code class="language-julia hljs">ps_pot = [4.75, 1.] ./ 2
tms_hmt = SimplifyTerms(
    GetDenIntTerms(nm, 2, ps_pot) - 
    GetDenIntTerms(nm, 2, ps_pot, σx) - 
    3.16 * GetPolTerms(nm, 2, σz)
)
qnd = [ 
    GetNeQNDiag(no), 
    GetLz2QNDiag(nm, nf), 
    GetZnfChargeQNDiag(nm, nf) 
]</code></pre><p>The Sites and Hamiltonian MPO can be generated with the function <code>GetMPOSites</code>. </p><pre><code class="language-julia hljs">hmt, sites = GetMPOSites(&quot;hmt&quot;, tms_hmt, qnd ; path, mpo_method = MyMPO)</code></pre><p>To generate the initial MPS that respects the <span>$\mathbb{Z}_2$</span> symmetry, we can use a direct product state. </p><pre><code class="language-julia hljs">cfi_p = [ [1, 0][f] for m = 1 : nm for f = 1 : nf ]
sti_p = MPS(sites, string.(cfi_p))
cfi_m = [ m == 1 ? [0, 1][f] : [1, 0][f] for m = 1 : nm for f = 1 : nf ]
sti_m = MPS(sites, string.(cfi_m))</code></pre><p>The lowest eigenenergies and the eigenstate MPSs <span>$|0\rangle,|\sigma\rangle,|\epsilon\rangle$</span> can be easily generated by the function <code>EasySweep</code>.</p><pre><code class="language-julia hljs">E0, st0 = EasySweep(&quot;0&quot;, hmt, sti_p ; path)
Ee, ste = EasySweep(&quot;e&quot;, hmt, sti_p ; path, proj = [&quot;0&quot;])
Es, sts = EasySweep(&quot;s&quot;, hmt, sti_m ; path)</code></pre><p>To measure the angular momentum <span>$L^2$</span> of the ground state, we generate the MPO for <span>$L^2$</span>.</p><pre><code class="language-julia hljs">tms_l2 = GetL2Terms(nm, 2)
l2 = GetMPO(&quot;l2&quot;, tms_l2, sites ; path, mpo_method = MyMPO)
val_l20 = inner(st0&#39;, l2, st0)</code></pre><p>Similarly, to measure the OPE coefficient <span>$f_{\sigma\sigma\epsilon}=\langle \sigma|n^x_{00}|\epsilon\rangle/\langle \sigma|n^x_{00}|0\rangle$</span></p><pre><code class="language-julia hljs">obs_nx = GetDensityObs(nm, 2, σx)
tms_nx00 = SimplifyTerms(GetComponent(obs_nx, 0.0, 0.0))
nx00 = GetMPO(&quot;nx00&quot;, tms_nx00, sites ; path, mpo_method = MyMPO)
f_sse = abs(inner(sts&#39;, nx00, ste) / inner(sts&#39;, nx00, st0))</code></pre><h2 id="List-of-examples"><a class="docs-heading-anchor" href="#List-of-examples">List of examples</a><a id="List-of-examples-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-examples" title="Permalink"></a></h2><p>We offer a series of other examples that reproduces various achievements of fuzzy sphere. For a more detailed summary of the background, see the <a href="../intro/#Review-of-existing-work">Review of existing work</a>. </p><ul><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_spectrum.jl"><code>ising_spectrum.jl</code></a> calculates the spectrum of 3d Ising model on fuzzy sphere at <span>$N_m = 12$</span>. For each <span>$(P,Z,R)$</span> sector, 20 states are calculated. This example reproduces Table I and Figure 4 in <a href="../intro/#Zhu2022">Zhu 2022</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_phase_diagram.jl"><code>ising_phase_diagram.jl</code></a> calculates the phase diagram of fuzzy sphere Ising modelby calculating the order parameter <span>$\langle M^2\rangle$</span>. This example reproduces Figure 3 in <a href="../intro/#Zhu2022">Zhu 2022</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_ope.jl"><code>ising_ope.jl</code></a> calculates various OPE coefficients at <span>$N_m = 12$</span> by taking overlaps between CFT states and density operators and composite. This example reproduces Figure 2 and Table I in <a href="../intro/#Hu2023Mar">Hu 2023Mar</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_correlator.jl"><code>ising_correlator.jl</code></a> calculates the <span>$σσ$</span> two-point function on sphere and the <span>$σσσσ$</span> four-point function on sphere, 0 and <span>$∞$</span>. This example reproduces Figures 1c and 2a in <a href="../intro/#Han2023Jun">Han 2023Jun</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_optimisation.jl"><code>ising_optimisation.jl</code></a> defines a cost function as the square sum of the deviations of descendants and stress tensor to evaluate the conformal symmetry for Ising model and minimises this cost function to find the best parameter.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_full_spectrum.jl"><code>ising_full_spectrum.jl</code></a> calculates the full spectrum of 3d Ising model on fuzzy sphere at <span>$N_m = 10$</span> for sector <span>$(P,Z,R) = (1,1,1)$</span>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_space_entangle.jl"><code>ising_space_entangle.jl</code></a> calculates the entanglement entropy of the Ising ground state along the real space cut of <span>$θ = 0.500π$</span> and <span>$0.499π$</span> respectively, and use these two data to extract finite size <span>$F$</span>-function without sustracting the IQHE contribution. This example reproduces Figures 3 in <a href="../intro/#Hu2024">Hu 2024</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_space_entangle.jl"><code>ising_orbital_entangle.jl</code></a> calculates the entanglement entropy of the Ising ground state along the orbital space cut at <span>$m = 0$</span>, and also the entanglement spectrum in the half-filled <span>$l_z = 0, 1$</span> and  both <span>$\mathbb{Z}_2$</span> sectors.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_generator.jl"><code>ising_generator.jl</code></a> examines the quality of conformal symmetry at <span>$N_m = 12$</span> by examining the matrix elements of conformal generators <span>$P^z + K^z$</span> and compare the states <span>$(P^z + K^z)|Φ⟩$</span> with the CFT expectations. This example reproduces Figure 7 in <a href="../intro/#Fardelli2024">Fardelli 2024</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/defect_spectrum.jl"><code>defect_spectrum.jl</code></a> calculates the spectrum of magnetic line defect in 3d Ising model in <span>$l_z = 0, P = ±1$</span> and <span>$l_z = 1$</span> sectors, calibrated by bulk <span>$T$</span>. This example reproduces Table I in <a href="../intro/#Hu2023Aug">Hu 2023Aug</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/defect_correlator.jl"><code>defect_correlator.jl</code></a> calculates the 1-pt function <span>$σ$</span> and 2-pt function <span>$σ\hat{ϕ}$</span> of magnetic line defect in 3d Ising model. The normalisation of the correlators require extra bulk data. This example reproduces Figure 4 in <a href="../intro/#Hu2023Aug">Hu 2023Aug</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/defect_changing.jl"><code>defect_changing.jl</code></a> calculates the spectrum of the defect creation and changing operators of the magnetic line defect in 3d Ising model. This example reproduces Table 2 and Figure 5 in <a href="../intro/#Zhou2024Jan">Zhou 2024Jan</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/defect_overlap.jl"><code>defect_overlap.jl</code></a> calculates the <span>$g$</span>-function of magnetic line defect in 3d Ising model using the ovelaps between the bulk, defect ground state and the lowest defect-creation state. This example reproduces Figure 6 in <a href="../intro/#Zhou2024Jan">Zhou 2024Jan</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/cusp_dim.jl"><code>cusp_dim.jl</code></a> calculates the scaling dimension of the cusp of the magnetic line defect in 3d Ising model as a function of the angle <span>$θ$</span>. This example reproduces Table 2, upper panel in <a href="../intro/#Cuomo2024">Cuomo 2024</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/surface_ordinary_spectrum.jl"><code>surface_ordinary_spectrum.jl</code></a> calculates the spectrum of ordinary surface CFT in 3d Ising model calibrated by surface displacement operator <span>$D$</span> in the orbital boundary scheme. This example reproduces Figures 3 and 4 in <a href="../intro/#Zhou2024Jul">Zhou 2024Jul</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/surface_normal_spectrum.jl"><code>surface_normal_spectrum.jl</code></a> calculates the spectrum of normal surface CFT in 3d Ising model calibrated by surface displacement operator <span>$D$</span> in the orbital boundary scheme. This example reproduces Figure 5 in <a href="../intro/#Zhou2024Jul">Zhou 2024Jul</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/o3_wf_spectrum.jl"><code>o3_wf_spectrum.jl</code></a> calculates the spectrum of <span>$\mathrm{O}(3)$</span> Wilson-Fisher CFT using the bilayer Heisenberg model. This example reproduces Table I and Figure 2 in <a href="../intro/#Han2023Dec">Han 2023Dec</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/so5_spectrum.jl"><code>so5_spectrum.jl</code></a> calculates the spectrum of SO(5) DQCP on fuzzy sphere. This example reproduces Table II in <a href="../intro/#Zhou2023">Zhou 2023</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/sp3_spectrum.jl"><code>sp3_spectrum.jl</code></a> calculates the spectrum of Sp(3) CFT on fuzzy sphere. This example reproduces Table I in <a href="../intro/#Zhou2024Oct">Zhou 2024Oct</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_frac_fermion.jl"><code>ising_frac_fermion.jl</code></a> calculates the spectrum of 3d Ising model on fuzzy sphere for fermions at fractional filling <span>$ν = 1/3$</span>. This example reproduces Figure 10 in <a href="../intro/#Voinea2024">Voinea 2024</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_frac_boson.jl"><code>ising_frac_boson.jl</code></a> calculates the spectrum of 3d Ising model on fuzzy sphere for bosons at fractional filling <span>$ν = 1/2$</span> with the module <em>Fuzzifino</em>. This example reproduces Figure 12a,b in <a href="../intro/#Voinea2024">Voinea 2024</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/potts_spectrum.jl"><code>potts_spectrum.jl</code></a> calculates the spectrum of 3d Potts model on fuzzy sphere. This example reproduces Table I and Figure 4 in <a href="../intro/#Yang2025">Yang 2025</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/circle_ising.jl"><code>circle_ising.jl</code></a> calculates the spectrum of 2d Ising CFT on a fuzzy thin torus. This example reproduces Figure 4 and Tables I–III in <a href="../intro/#Han2025">Han 2025</a>.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/yang_lee_spectrum.jl"><code>yang_lee_spectrum.jl</code></a> calculates the spectrum of 3d non-unitary Yang-Lee CFT on fuzzy sphere. This example reproduces Figure 3c in <a href="../intro/#Fan2025">Fan 2025</a></li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_spectrum_krylov.jl"><code>ising_spectrum_krylov.jl</code></a> calculates the spectrum of 3d Ising model on fuzzy sphere by calling the eigsolve function in KrylovKit.jl instead of Arpack.</li><li><a href="https://github.com/FuzzifiED/FuzzifiED.jl/blob/main/examples/ising_spectrum_cuda.jl"><code>ising_spectrum_cuda.jl</code></a> calculates the spectrum of 3d Ising model on fuzzy sphere for one sector by performing the sparse matrix multiplication on CUDA.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intro/">« Introduction</a><a class="docs-footer-nextpage" href="../core/">Core functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>. Copyright (c) 2025 Zheng Zhou (周正) and contributors.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.3 on <span class="colophon-date" title="Monday 26 May 2025 08:30">Monday 26 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
